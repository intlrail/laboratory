(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.5.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-04-10T15:07Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.5.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( _i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = Object.create( null );

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
					dataPriv.get( this, "events" ) || Object.create( null )
				)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px";
				tr.style.height = "1px";
				trChild.style.height = "9px";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = (
					dataPriv.get( cur, "events" ) || Object.create( null )
				)[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script
			if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			if ( typeof props.top === "number" ) {
				props.top += "px";
			}
			if ( typeof props.left === "number" ) {
				props.left += "px";
			}
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{}],2:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":113,"./_root":159}],3:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":123,"./_hashDelete":124,"./_hashGet":125,"./_hashHas":126,"./_hashSet":127}],4:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":139,"./_listCacheDelete":140,"./_listCacheGet":141,"./_listCacheHas":142,"./_listCacheSet":143}],5:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":113,"./_root":159}],6:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":144,"./_mapCacheDelete":145,"./_mapCacheGet":146,"./_mapCacheHas":147,"./_mapCacheSet":148}],7:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":113,"./_root":159}],8:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":113,"./_root":159}],9:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":6,"./_setCacheAdd":160,"./_setCacheHas":161}],10:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":4,"./_stackClear":165,"./_stackDelete":166,"./_stackGet":167,"./_stackHas":168,"./_stackSet":169}],11:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":159}],12:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":159}],13:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":113,"./_root":159}],14:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],15:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],16:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],17:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf');

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

},{"./_baseIndexOf":49}],18:[function(require,module,exports){
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;

},{}],19:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":75,"./_isIndex":132,"./isArguments":208,"./isArray":209,"./isBuffer":212,"./isTypedArray":226}],20:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],21:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],22:[function(require,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],23:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],24:[function(require,module,exports){
var baseProperty = require('./_baseProperty');

/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
var asciiSize = baseProperty('length');

module.exports = asciiSize;

},{"./_baseProperty":66}],25:[function(require,module,exports){
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;

},{}],26:[function(require,module,exports){
/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

module.exports = asciiWords;

},{}],27:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":31,"./eq":189}],28:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":189}],29:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":92,"./keys":227}],30:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":92,"./keysIn":228}],31:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":104}],32:[function(require,module,exports){
/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

module.exports = baseClamp;

},{}],33:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isMap = require('./isMap'),
    isObject = require('./isObject'),
    isSet = require('./isSet'),
    keys = require('./keys'),
    keysIn = require('./keysIn');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":10,"./_arrayEach":15,"./_assignValue":27,"./_baseAssign":29,"./_baseAssignIn":30,"./_cloneBuffer":86,"./_copyArray":91,"./_copySymbols":93,"./_copySymbolsIn":94,"./_getAllKeys":109,"./_getAllKeysIn":110,"./_getTag":118,"./_initCloneArray":128,"./_initCloneByTag":129,"./_initCloneObject":130,"./isArray":209,"./isBuffer":212,"./isMap":217,"./isObject":221,"./isSet":223,"./keys":227,"./keysIn":228}],34:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":221}],35:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;

},{"./_SetCache":9,"./_arrayIncludes":17,"./_arrayIncludesWith":18,"./_arrayMap":20,"./_baseUnary":77,"./_cacheHas":80}],36:[function(require,module,exports){
var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./_baseForOwn":42,"./_createBaseEach":96}],37:[function(require,module,exports){
var baseEach = require('./_baseEach');

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;

},{"./_baseEach":36}],38:[function(require,module,exports){
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

},{}],39:[function(require,module,exports){
/**
 * The base implementation of methods like `_.findKey` and `_.findLastKey`,
 * without support for iteratee shorthands, which iterates over `collection`
 * using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the found element or its key, else `undefined`.
 */
function baseFindKey(collection, predicate, eachFunc) {
  var result;
  eachFunc(collection, function(value, key, collection) {
    if (predicate(value, key, collection)) {
      result = key;
      return false;
    }
  });
  return result;
}

module.exports = baseFindKey;

},{}],40:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"./_arrayPush":21,"./_isFlattenable":131}],41:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":97}],42:[function(require,module,exports){
var baseFor = require('./_baseFor'),
    keys = require('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":41,"./keys":227}],43:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":83,"./_toKey":174}],44:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":21,"./isArray":209}],45:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":11,"./_getRawTag":115,"./_objectToString":156}],46:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;

},{}],47:[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],48:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * The base implementation of `_.inRange` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to check.
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 */
function baseInRange(number, start, end) {
  return number >= nativeMin(start, end) && number < nativeMax(start, end);
}

module.exports = baseInRange;

},{}],49:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

},{"./_baseFindIndex":38,"./_baseIsNaN":56,"./_strictIndexOf":170}],50:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = arrayMap(array, baseUnary(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
      ? new SetCache(othIndex && array)
      : undefined;
  }
  array = arrays[0];

  var index = -1,
      seen = caches[0];

  outer:
  while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (!(seen
          ? cacheHas(seen, computed)
          : includes(result, computed, comparator)
        )) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache
              ? cacheHas(cache, computed)
              : includes(arrays[othIndex], computed, comparator))
            ) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseIntersection;

},{"./_SetCache":9,"./_arrayIncludes":17,"./_arrayIncludesWith":18,"./_arrayMap":20,"./_baseUnary":77,"./_cacheHas":80}],51:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":45,"./isObjectLike":222}],52:[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":53,"./isObjectLike":222}],53:[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":10,"./_equalArrays":105,"./_equalByTag":106,"./_equalObjects":107,"./_getTag":118,"./isArray":209,"./isBuffer":212,"./isTypedArray":226}],54:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

},{"./_getTag":118,"./isObjectLike":222}],55:[function(require,module,exports){
var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":10,"./_baseIsEqual":52}],56:[function(require,module,exports){
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

},{}],57:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":136,"./_toSource":175,"./isFunction":215,"./isObject":221}],58:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

},{"./_getTag":118,"./isObjectLike":222}],59:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":45,"./isLength":216,"./isObjectLike":222}],60:[function(require,module,exports){
var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":64,"./_baseMatchesProperty":65,"./identity":204,"./isArray":209,"./property":236}],61:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":137,"./_nativeKeys":153}],62:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":137,"./_nativeKeysIn":154,"./isObject":221}],63:[function(require,module,exports){
var baseEach = require('./_baseEach'),
    isArrayLike = require('./isArrayLike');

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

},{"./_baseEach":36,"./isArrayLike":210}],64:[function(require,module,exports){
var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":55,"./_getMatchData":112,"./_matchesStrictComparable":150}],65:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":52,"./_isKey":134,"./_isStrictComparable":138,"./_matchesStrictComparable":150,"./_toKey":174,"./get":200,"./hasIn":202}],66:[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],67:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":43}],68:[function(require,module,exports){
/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;

},{}],69:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

module.exports = baseRandom;

},{}],70:[function(require,module,exports){
/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;

},{}],71:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor;

/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */
function baseRepeat(string, n) {
  var result = '';
  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
    return result;
  }
  // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do {
    if (n % 2) {
      result += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

module.exports = baseRepeat;

},{}],72:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":158,"./_setToString":163,"./identity":204}],73:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":104,"./constant":185,"./identity":204}],74:[function(require,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],75:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],76:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":11,"./_arrayMap":20,"./isArray":209,"./isSymbol":225}],77:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],78:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    cacheHas = require('./_cacheHas'),
    createSet = require('./_createSet'),
    setToArray = require('./_setToArray');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;

},{"./_SetCache":9,"./_arrayIncludes":17,"./_arrayIncludesWith":18,"./_cacheHas":80,"./_createSet":102,"./_setToArray":162}],79:[function(require,module,exports){
var arrayMap = require('./_arrayMap');

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;

},{"./_arrayMap":20}],80:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],81:[function(require,module,exports){
var isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}

module.exports = castArrayLikeObject;

},{"./isArrayLikeObject":211}],82:[function(require,module,exports){
var identity = require('./identity');

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

},{"./identity":204}],83:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":134,"./_stringToPath":173,"./isArray":209,"./toString":248}],84:[function(require,module,exports){
var baseSlice = require('./_baseSlice');

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;

},{"./_baseSlice":74}],85:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":12}],86:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":159}],87:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":85}],88:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],89:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":11}],90:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":85}],91:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],92:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":27,"./_baseAssignValue":31}],93:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":92,"./_getSymbols":116}],94:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":92,"./_getSymbolsIn":117}],95:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":159}],96:[function(require,module,exports){
var isArrayLike = require('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":210}],97:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],98:[function(require,module,exports){
var arrayReduce = require('./_arrayReduce'),
    deburr = require('./deburr'),
    words = require('./words');

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

module.exports = createCompounder;

},{"./_arrayReduce":22,"./deburr":186,"./words":253}],99:[function(require,module,exports){
var baseIteratee = require('./_baseIteratee'),
    isArrayLike = require('./isArrayLike'),
    keys = require('./keys');

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;

},{"./_baseIteratee":60,"./isArrayLike":210,"./keys":227}],100:[function(require,module,exports){
var baseRepeat = require('./_baseRepeat'),
    baseToString = require('./_baseToString'),
    castSlice = require('./_castSlice'),
    hasUnicode = require('./_hasUnicode'),
    stringSize = require('./_stringSize'),
    stringToArray = require('./_stringToArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil;

/**
 * Creates the padding for `string` based on `length`. The `chars` string
 * is truncated if the number of characters exceeds `length`.
 *
 * @private
 * @param {number} length The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padding for `string`.
 */
function createPadding(length, chars) {
  chars = chars === undefined ? ' ' : baseToString(chars);

  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat(chars, length) : chars;
  }
  var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
  return hasUnicode(chars)
    ? castSlice(stringToArray(result), 0, length).join('')
    : result.slice(0, length);
}

module.exports = createPadding;

},{"./_baseRepeat":71,"./_baseToString":76,"./_castSlice":84,"./_hasUnicode":121,"./_stringSize":171,"./_stringToArray":172}],101:[function(require,module,exports){
var root = require('./_root'),
    toInteger = require('./toInteger'),
    toNumber = require('./toNumber'),
    toString = require('./toString');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsFinite = root.isFinite,
    nativeMin = Math.min;

/**
 * Creates a function like `_.round`.
 *
 * @private
 * @param {string} methodName The name of the `Math` method to use when rounding.
 * @returns {Function} Returns the new round function.
 */
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber(number);
    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
    if (precision && nativeIsFinite(number)) {
      // Shift with exponential notation to avoid floating-point issues.
      // See [MDN](https://mdn.io/round#Examples) for more details.
      var pair = (toString(number) + 'e').split('e'),
          value = func(pair[0] + 'e' + (+pair[1] + precision));

      pair = (toString(value) + 'e').split('e');
      return +(pair[0] + 'e' + (+pair[1] - precision));
    }
    return func(number);
  };
}

module.exports = createRound;

},{"./_root":159,"./toInteger":245,"./toNumber":247,"./toString":248}],102:[function(require,module,exports){
var Set = require('./_Set'),
    noop = require('./noop'),
    setToArray = require('./_setToArray');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;

},{"./_Set":8,"./_setToArray":162,"./noop":234}],103:[function(require,module,exports){
var basePropertyOf = require('./_basePropertyOf');

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

module.exports = deburrLetter;

},{"./_basePropertyOf":68}],104:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":113}],105:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":9,"./_arraySome":23,"./_cacheHas":80}],106:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":11,"./_Uint8Array":12,"./_equalArrays":105,"./_mapToArray":149,"./_setToArray":162,"./eq":189}],107:[function(require,module,exports){
var getAllKeys = require('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":109}],108:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],109:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":44,"./_getSymbols":116,"./keys":227}],110:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":44,"./_getSymbolsIn":117,"./keysIn":228}],111:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":135}],112:[function(require,module,exports){
var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":138,"./keys":227}],113:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":57,"./_getValue":119}],114:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":157}],115:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":11}],116:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":16,"./stubArray":241}],117:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":21,"./_getPrototype":114,"./_getSymbols":116,"./stubArray":241}],118:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":2,"./_Map":5,"./_Promise":7,"./_Set":8,"./_WeakMap":13,"./_baseGetTag":45,"./_toSource":175}],119:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],120:[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":83,"./_isIndex":132,"./_toKey":174,"./isArguments":208,"./isArray":209,"./isLength":216}],121:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;

},{}],122:[function(require,module,exports){
/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

module.exports = hasUnicodeWord;

},{}],123:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":152}],124:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],125:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":152}],126:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":152}],127:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":152}],128:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],129:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":85,"./_cloneDataView":87,"./_cloneRegExp":88,"./_cloneSymbol":89,"./_cloneTypedArray":90}],130:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":34,"./_getPrototype":114,"./_isPrototype":137}],131:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

},{"./_Symbol":11,"./isArguments":208,"./isArray":209}],132:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],133:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":132,"./eq":189,"./isArrayLike":210,"./isObject":221}],134:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":209,"./isSymbol":225}],135:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],136:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":95}],137:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],138:[function(require,module,exports){
var isObject = require('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":221}],139:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],140:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":28}],141:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":28}],142:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":28}],143:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":28}],144:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":3,"./_ListCache":4,"./_Map":5}],145:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":111}],146:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":111}],147:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":111}],148:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":111}],149:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],150:[function(require,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],151:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":233}],152:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":113}],153:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":157}],154:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],155:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":108}],156:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],157:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],158:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":14}],159:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":108}],160:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],161:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],162:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],163:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":73,"./_shortOut":164}],164:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],165:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":4}],166:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],167:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],168:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],169:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":4,"./_Map":5,"./_MapCache":6}],170:[function(require,module,exports){
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

},{}],171:[function(require,module,exports){
var asciiSize = require('./_asciiSize'),
    hasUnicode = require('./_hasUnicode'),
    unicodeSize = require('./_unicodeSize');

/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize(string) {
  return hasUnicode(string)
    ? unicodeSize(string)
    : asciiSize(string);
}

module.exports = stringSize;

},{"./_asciiSize":24,"./_hasUnicode":121,"./_unicodeSize":176}],172:[function(require,module,exports){
var asciiToArray = require('./_asciiToArray'),
    hasUnicode = require('./_hasUnicode'),
    unicodeToArray = require('./_unicodeToArray');

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;

},{"./_asciiToArray":25,"./_hasUnicode":121,"./_unicodeToArray":177}],173:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":151}],174:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":225}],175:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],176:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}

module.exports = unicodeSize;

},{}],177:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;

},{}],178:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

module.exports = unicodeWords;

},{}],179:[function(require,module,exports){
var createRound = require('./_createRound');

/**
 * Computes `number` rounded up to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round up.
 * @param {number} [precision=0] The precision to round up to.
 * @returns {number} Returns the rounded up number.
 * @example
 *
 * _.ceil(4.006);
 * // => 5
 *
 * _.ceil(6.004, 2);
 * // => 6.01
 *
 * _.ceil(6040, -2);
 * // => 6100
 */
var ceil = createRound('ceil');

module.exports = ceil;

},{"./_createRound":101}],180:[function(require,module,exports){
var baseSlice = require('./_baseSlice'),
    isIterateeCall = require('./_isIterateeCall'),
    toInteger = require('./toInteger');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array, size, guard) {
  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
    size = 1;
  } else {
    size = nativeMax(toInteger(size), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil(length / size));

  while (index < length) {
    result[resIndex++] = baseSlice(array, index, (index += size));
  }
  return result;
}

module.exports = chunk;

},{"./_baseSlice":74,"./_isIterateeCall":133,"./toInteger":245}],181:[function(require,module,exports){
var baseClamp = require('./_baseClamp'),
    toNumber = require('./toNumber');

/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */
function clamp(number, lower, upper) {
  if (upper === undefined) {
    upper = lower;
    lower = undefined;
  }
  if (upper !== undefined) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== undefined) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}

module.exports = clamp;

},{"./_baseClamp":32,"./toNumber":247}],182:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":33}],183:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":33}],184:[function(require,module,exports){
/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = compact;

},{}],185:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],186:[function(require,module,exports){
var deburrLetter = require('./_deburrLetter'),
    toString = require('./toString');

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;

},{"./_deburrLetter":103,"./toString":248}],187:[function(require,module,exports){
/**
 * Checks `value` to determine whether a default value should be returned in
 * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
 * or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.14.0
 * @category Util
 * @param {*} value The value to check.
 * @param {*} defaultValue The default value.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * _.defaultTo(1, 10);
 * // => 1
 *
 * _.defaultTo(undefined, 10);
 * // => 10
 */
function defaultTo(value, defaultValue) {
  return (value == null || value !== value) ? defaultValue : value;
}

module.exports = defaultTo;

},{}],188:[function(require,module,exports){
var baseDifference = require('./_baseDifference'),
    baseFlatten = require('./_baseFlatten'),
    baseRest = require('./_baseRest'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

module.exports = difference;

},{"./_baseDifference":35,"./_baseFlatten":40,"./_baseRest":72,"./isArrayLikeObject":211}],189:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],190:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    baseFilter = require('./_baseFilter'),
    baseIteratee = require('./_baseIteratee'),
    isArray = require('./isArray');

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 *
 * // Combining several predicates using `_.overEvery` or `_.overSome`.
 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
 * // => objects for ['fred', 'barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;

},{"./_arrayFilter":16,"./_baseFilter":37,"./_baseIteratee":60,"./isArray":209}],191:[function(require,module,exports){
var createFind = require('./_createFind'),
    findIndex = require('./findIndex');

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;

},{"./_createFind":99,"./findIndex":192}],192:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIteratee = require('./_baseIteratee'),
    toInteger = require('./toInteger');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;

},{"./_baseFindIndex":38,"./_baseIteratee":60,"./toInteger":245}],193:[function(require,module,exports){
var baseFindKey = require('./_baseFindKey'),
    baseForOwn = require('./_baseForOwn'),
    baseIteratee = require('./_baseIteratee');

/**
 * This method is like `_.find` except that it returns the key of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Object
 * @param {Object} object The object to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {string|undefined} Returns the key of the matched element,
 *  else `undefined`.
 * @example
 *
 * var users = {
 *   'barney':  { 'age': 36, 'active': true },
 *   'fred':    { 'age': 40, 'active': false },
 *   'pebbles': { 'age': 1,  'active': true }
 * };
 *
 * _.findKey(users, function(o) { return o.age < 40; });
 * // => 'barney' (iteration order is not guaranteed)
 *
 * // The `_.matches` iteratee shorthand.
 * _.findKey(users, { 'age': 1, 'active': true });
 * // => 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findKey(users, ['active', false]);
 * // => 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.findKey(users, 'active');
 * // => 'barney'
 */
function findKey(object, predicate) {
  return baseFindKey(object, baseIteratee(predicate, 3), baseForOwn);
}

module.exports = findKey;

},{"./_baseFindKey":39,"./_baseForOwn":42,"./_baseIteratee":60}],194:[function(require,module,exports){
var createFind = require('./_createFind'),
    findLastIndex = require('./findLastIndex');

/**
 * This method is like `_.find` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=collection.length-1] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * _.findLast([1, 2, 3, 4], function(n) {
 *   return n % 2 == 1;
 * });
 * // => 3
 */
var findLast = createFind(findLastIndex);

module.exports = findLast;

},{"./_createFind":99,"./findLastIndex":195}],195:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIteratee = require('./_baseIteratee'),
    toInteger = require('./toInteger');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * This method is like `_.findIndex` except that it iterates over elements
 * of `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
 * // => 2
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
 * // => 0
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastIndex(users, ['active', false]);
 * // => 2
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastIndex(users, 'active');
 * // => 0
 */
function findLastIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== undefined) {
    index = toInteger(fromIndex);
    index = fromIndex < 0
      ? nativeMax(length + index, 0)
      : nativeMin(index, length - 1);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index, true);
}

module.exports = findLastIndex;

},{"./_baseFindIndex":38,"./_baseIteratee":60,"./toInteger":245}],196:[function(require,module,exports){
module.exports = require('./head');

},{"./head":203}],197:[function(require,module,exports){
var baseFlatten = require('./_baseFlatten');

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

},{"./_baseFlatten":40}],198:[function(require,module,exports){
var createRound = require('./_createRound');

/**
 * Computes `number` rounded down to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round down.
 * @param {number} [precision=0] The precision to round down to.
 * @returns {number} Returns the rounded down number.
 * @example
 *
 * _.floor(4.006);
 * // => 4
 *
 * _.floor(0.046, 2);
 * // => 0.04
 *
 * _.floor(4060, -2);
 * // => 4000
 */
var floor = createRound('floor');

module.exports = floor;

},{"./_createRound":101}],199:[function(require,module,exports){
var arrayEach = require('./_arrayEach'),
    baseEach = require('./_baseEach'),
    castFunction = require('./_castFunction'),
    isArray = require('./isArray');

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

},{"./_arrayEach":15,"./_baseEach":36,"./_castFunction":82,"./isArray":209}],200:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":43}],201:[function(require,module,exports){
var baseHas = require('./_baseHas'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;

},{"./_baseHas":46,"./_hasPath":120}],202:[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":47,"./_hasPath":120}],203:[function(require,module,exports){
/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

module.exports = head;

},{}],204:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],205:[function(require,module,exports){
var baseInRange = require('./_baseInRange'),
    toFinite = require('./toFinite'),
    toNumber = require('./toNumber');

/**
 * Checks if `n` is between `start` and up to, but not including, `end`. If
 * `end` is not specified, it's set to `start` with `start` then set to `0`.
 * If `start` is greater than `end` the params are swapped to support
 * negative ranges.
 *
 * @static
 * @memberOf _
 * @since 3.3.0
 * @category Number
 * @param {number} number The number to check.
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 * @see _.range, _.rangeRight
 * @example
 *
 * _.inRange(3, 2, 4);
 * // => true
 *
 * _.inRange(4, 8);
 * // => true
 *
 * _.inRange(4, 2);
 * // => false
 *
 * _.inRange(2, 2);
 * // => false
 *
 * _.inRange(1.2, 2);
 * // => true
 *
 * _.inRange(5.2, 4);
 * // => false
 *
 * _.inRange(-3, -2, -6);
 * // => true
 */
function inRange(number, start, end) {
  start = toFinite(start);
  if (end === undefined) {
    end = start;
    start = 0;
  } else {
    end = toFinite(end);
  }
  number = toNumber(number);
  return baseInRange(number, start, end);
}

module.exports = inRange;

},{"./_baseInRange":48,"./toFinite":244,"./toNumber":247}],206:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf'),
    isArrayLike = require('./isArrayLike'),
    isString = require('./isString'),
    toInteger = require('./toInteger'),
    values = require('./values');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

module.exports = includes;

},{"./_baseIndexOf":49,"./isArrayLike":210,"./isString":224,"./toInteger":245,"./values":251}],207:[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseIntersection = require('./_baseIntersection'),
    baseRest = require('./_baseRest'),
    castArrayLikeObject = require('./_castArrayLikeObject');

/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */
var intersection = baseRest(function(arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped)
    : [];
});

module.exports = intersection;

},{"./_arrayMap":20,"./_baseIntersection":50,"./_baseRest":72,"./_castArrayLikeObject":81}],208:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":51,"./isObjectLike":222}],209:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],210:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":215,"./isLength":216}],211:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":210,"./isObjectLike":222}],212:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":159,"./stubFalse":242}],213:[function(require,module,exports){
var baseKeys = require('./_baseKeys'),
    getTag = require('./_getTag'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLike = require('./isArrayLike'),
    isBuffer = require('./isBuffer'),
    isPrototype = require('./_isPrototype'),
    isTypedArray = require('./isTypedArray');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;

},{"./_baseKeys":61,"./_getTag":118,"./_isPrototype":137,"./isArguments":208,"./isArray":209,"./isArrayLike":210,"./isBuffer":212,"./isTypedArray":226}],214:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

},{"./_baseIsEqual":52}],215:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":45,"./isObject":221}],216:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],217:[function(require,module,exports){
var baseIsMap = require('./_baseIsMap'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;

},{"./_baseIsMap":54,"./_baseUnary":77,"./_nodeUtil":155}],218:[function(require,module,exports){
var isNumber = require('./isNumber');

/**
 * Checks if `value` is `NaN`.
 *
 * **Note:** This method is based on
 * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
 * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
 * `undefined` and other non-number values.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 * @example
 *
 * _.isNaN(NaN);
 * // => true
 *
 * _.isNaN(new Number(NaN));
 * // => true
 *
 * isNaN(undefined);
 * // => true
 *
 * _.isNaN(undefined);
 * // => false
 */
function isNaN(value) {
  // An `NaN` primitive is the only value that is not equal to itself.
  // Perform the `toStringTag` check first to avoid errors with some
  // ActiveX objects in IE.
  return isNumber(value) && value != +value;
}

module.exports = isNaN;

},{"./isNumber":220}],219:[function(require,module,exports){
/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil(value) {
  return value == null;
}

module.exports = isNil;

},{}],220:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;

},{"./_baseGetTag":45,"./isObjectLike":222}],221:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],222:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],223:[function(require,module,exports){
var baseIsSet = require('./_baseIsSet'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;

},{"./_baseIsSet":58,"./_baseUnary":77,"./_nodeUtil":155}],224:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

},{"./_baseGetTag":45,"./isArray":209,"./isObjectLike":222}],225:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":45,"./isObjectLike":222}],226:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":59,"./_baseUnary":77,"./_nodeUtil":155}],227:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":19,"./_baseKeys":61,"./isArrayLike":210}],228:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":19,"./_baseKeysIn":62,"./isArrayLike":210}],229:[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],230:[function(require,module,exports){
var createCompounder = require('./_createCompounder');

/**
 * Converts `string`, as space separated words, to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the lower cased string.
 * @example
 *
 * _.lowerCase('--Foo-Bar--');
 * // => 'foo bar'
 *
 * _.lowerCase('fooBar');
 * // => 'foo bar'
 *
 * _.lowerCase('__FOO_BAR__');
 * // => 'foo bar'
 */
var lowerCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + word.toLowerCase();
});

module.exports = lowerCase;

},{"./_createCompounder":98}],231:[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseIteratee = require('./_baseIteratee'),
    baseMap = require('./_baseMap'),
    isArray = require('./isArray');

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;

},{"./_arrayMap":20,"./_baseIteratee":60,"./_baseMap":63,"./isArray":209}],232:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    baseForOwn = require('./_baseForOwn'),
    baseIteratee = require('./_baseIteratee');

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;

},{"./_baseAssignValue":31,"./_baseForOwn":42,"./_baseIteratee":60}],233:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":6}],234:[function(require,module,exports){
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

},{}],235:[function(require,module,exports){
var createPadding = require('./_createPadding'),
    stringSize = require('./_stringSize'),
    toInteger = require('./toInteger'),
    toString = require('./toString');

/**
 * Pads `string` on the right side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padEnd('abc', 6);
 * // => 'abc   '
 *
 * _.padEnd('abc', 6, '_-');
 * // => 'abc_-_'
 *
 * _.padEnd('abc', 3);
 * // => 'abc'
 */
function padEnd(string, length, chars) {
  string = toString(string);
  length = toInteger(length);

  var strLength = length ? stringSize(string) : 0;
  return (length && strLength < length)
    ? (string + createPadding(length - strLength, chars))
    : string;
}

module.exports = padEnd;

},{"./_createPadding":100,"./_stringSize":171,"./toInteger":245,"./toString":248}],236:[function(require,module,exports){
var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":66,"./_basePropertyDeep":67,"./_isKey":134,"./_toKey":174}],237:[function(require,module,exports){
var baseRandom = require('./_baseRandom'),
    isIterateeCall = require('./_isIterateeCall'),
    toFinite = require('./toFinite');

/** Built-in method references without a dependency on `root`. */
var freeParseFloat = parseFloat;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min,
    nativeRandom = Math.random;

/**
 * Produces a random number between the inclusive `lower` and `upper` bounds.
 * If only one argument is provided a number between `0` and the given number
 * is returned. If `floating` is `true`, or either `lower` or `upper` are
 * floats, a floating-point number is returned instead of an integer.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @memberOf _
 * @since 0.7.0
 * @category Number
 * @param {number} [lower=0] The lower bound.
 * @param {number} [upper=1] The upper bound.
 * @param {boolean} [floating] Specify returning a floating-point number.
 * @returns {number} Returns the random number.
 * @example
 *
 * _.random(0, 5);
 * // => an integer between 0 and 5
 *
 * _.random(5);
 * // => also an integer between 0 and 5
 *
 * _.random(5, true);
 * // => a floating-point number between 0 and 5
 *
 * _.random(1.2, 5.2);
 * // => a floating-point number between 1.2 and 5.2
 */
function random(lower, upper, floating) {
  if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
    upper = floating = undefined;
  }
  if (floating === undefined) {
    if (typeof upper == 'boolean') {
      floating = upper;
      upper = undefined;
    }
    else if (typeof lower == 'boolean') {
      floating = lower;
      lower = undefined;
    }
  }
  if (lower === undefined && upper === undefined) {
    lower = 0;
    upper = 1;
  }
  else {
    lower = toFinite(lower);
    if (upper === undefined) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom();
    return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
  }
  return baseRandom(lower, upper);
}

module.exports = random;

},{"./_baseRandom":69,"./_isIterateeCall":133,"./toFinite":244}],238:[function(require,module,exports){
var arrayReduce = require('./_arrayReduce'),
    baseEach = require('./_baseEach'),
    baseIteratee = require('./_baseIteratee'),
    baseReduce = require('./_baseReduce'),
    isArray = require('./isArray');

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;

},{"./_arrayReduce":22,"./_baseEach":36,"./_baseIteratee":60,"./_baseReduce":70,"./isArray":209}],239:[function(require,module,exports){
var createRound = require('./_createRound');

/**
 * Computes `number` rounded to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round.
 * @param {number} [precision=0] The precision to round to.
 * @returns {number} Returns the rounded number.
 * @example
 *
 * _.round(4.006);
 * // => 4
 *
 * _.round(4.006, 2);
 * // => 4.01
 *
 * _.round(4060, -2);
 * // => 4100
 */
var round = createRound('round');

module.exports = round;

},{"./_createRound":101}],240:[function(require,module,exports){
var baseClamp = require('./_baseClamp'),
    baseToString = require('./_baseToString'),
    toInteger = require('./toInteger'),
    toString = require('./toString');

/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */
function startsWith(string, target, position) {
  string = toString(string);
  position = position == null
    ? 0
    : baseClamp(toInteger(position), 0, string.length);

  target = baseToString(target);
  return string.slice(position, position + target.length) == target;
}

module.exports = startsWith;

},{"./_baseClamp":32,"./_baseToString":76,"./toInteger":245,"./toString":248}],241:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],242:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],243:[function(require,module,exports){
var baseSlice = require('./_baseSlice');

/**
 * Gets all but the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.tail([1, 2, 3]);
 * // => [2, 3]
 */
function tail(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice(array, 1, length) : [];
}

module.exports = tail;

},{"./_baseSlice":74}],244:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":247}],245:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":244}],246:[function(require,module,exports){
var toString = require('./toString');

/**
 * Converts `string`, as a whole, to lower case just like
 * [String#toLowerCase](https://mdn.io/toLowerCase).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the lower cased string.
 * @example
 *
 * _.toLower('--Foo-Bar--');
 * // => '--foo-bar--'
 *
 * _.toLower('fooBar');
 * // => 'foobar'
 *
 * _.toLower('__FOO_BAR__');
 * // => '__foo_bar__'
 */
function toLower(value) {
  return toString(value).toLowerCase();
}

module.exports = toLower;

},{"./toString":248}],247:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":221,"./isSymbol":225}],248:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":76}],249:[function(require,module,exports){
var baseUniq = require('./_baseUniq');

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length) ? baseUniq(array) : [];
}

module.exports = uniq;

},{"./_baseUniq":78}],250:[function(require,module,exports){
var toString = require('./toString');

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

module.exports = uniqueId;

},{"./toString":248}],251:[function(require,module,exports){
var baseValues = require('./_baseValues'),
    keys = require('./keys');

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

},{"./_baseValues":79,"./keys":227}],252:[function(require,module,exports){
var baseDifference = require('./_baseDifference'),
    baseRest = require('./_baseRest'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.pull`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([2, 1, 2, 3], 1, 2);
 * // => [3]
 */
var without = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, values)
    : [];
});

module.exports = without;

},{"./_baseDifference":35,"./_baseRest":72,"./isArrayLikeObject":211}],253:[function(require,module,exports){
var asciiWords = require('./_asciiWords'),
    hasUnicodeWord = require('./_hasUnicodeWord'),
    toString = require('./toString'),
    unicodeWords = require('./_unicodeWords');

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = words;

},{"./_asciiWords":26,"./_hasUnicodeWord":122,"./_unicodeWords":178,"./toString":248}],254:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);



}).call(this,require('_process'))

},{"_process":255}],255:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],256:[function(require,module,exports){
(function (global){
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":254}],257:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _AppController = _interopRequireDefault(require("./AppController"));

var _EventBus = _interopRequireDefault(require("./lib/EventBus"));

var _TimeKeeper = _interopRequireDefault(require("./engine/TimeKeeper"));

var _airportConstants = require("./constants/airportConstants");

var _eventNames = require("./constants/eventNames");

var _logLevel = require("./constants/logLevel");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

window.zlsa = {};
window.zlsa.atc = {}; // TODO: KILL THE PROP!

var prop = {}; // IIEFs are pulled in here to add functions to the global space.
//
// This will need to be re-worked, and current global functions should be exported and
// imported as needed in each file.

require('./util'); // are you using a main loop? (you must call update() afterward disable/re-enable)


var UPDATE = true;
/**
 * @class App
 */

var App =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param $element {HTML Element|null}
   * @param airportLoadList {array<object>}  List of airports to load
   * @param initialAirportToLoad {string}    ICAO id of the initial airport. may be the default or a stored airport
   */
  function App(element, airportLoadList, initialAirportToLoad) {
    _classCallCheck(this, App);

    /**
     * Root DOM element.
     *
     * @property $element
     * @type {jQuery|HTML Element}
     * @default body
     */
    this.$element = (0, _jquery["default"])(element);
    this._appController = new _AppController["default"](this.$element);
    this.eventBus = _EventBus["default"];
    window.prop = prop;
    this.prop = prop;
    this.prop.complete = false;
    this.prop.log = _logLevel.LOG.DEBUG;
    this.prop.loaded = false;
    return this.setupHandlers().loadInitialAirport(airportLoadList, initialAirportToLoad);
  }
  /**
   * Create event handlers
   *
   * @for App
   * @method setupHandlers
   * @chainable
   */


  _createClass(App, [{
    key: "setupHandlers",
    value: function setupHandlers() {
      this.loadDefaultAiportAfterStorageIcaoFailureHandler = this.loadDefaultAiportAfterStorageIcaoFailure.bind(this);
      this.loadAirlinesAndAircraftHandler = this.loadAirlinesAndAircraft.bind(this);
      this.setupChildrenHandler = this.setupChildren.bind(this);
      this.onPauseHandler = this._onPause.bind(this);
      this.onUpdateHandler = this.update.bind(this);
      this.eventBus.on(_eventNames.EVENT.PAUSE_UPDATE_LOOP, this.onPauseHandler);
      return this;
    }
    /**
     * Used to load data for the initial airport using an icao from
     * either localStorage or `DEFAULT_AIRPORT_ICAO`
     *
     * If a localStorage airport cannot be found, we will attempt
     * to load the `DEFAULT_AIRPORT_ICAO`
     *
     * Lifecycle method. Should be called only once on initialization
     *
     * @for App
     * @method loadInitialAirport
     * @param airportLoadList {array<object>}  List of airports to load
     */

  }, {
    key: "loadInitialAirport",
    value: function loadInitialAirport(airportLoadList, initialAirportToLoad) {
      var _this = this;

      var initialAirportIcao = initialAirportToLoad.toLowerCase();

      _jquery["default"].getJSON("assets/airports/".concat(initialAirportIcao, ".json")).then(function (response) {
        return _this.loadAirlinesAndAircraftHandler(airportLoadList, initialAirportIcao, response);
      })["catch"](function (error) {
        return _this.loadDefaultAiportAfterStorageIcaoFailureHandler(airportLoadList);
      });
    }
    /**
     * Used only when an attempt to load airport data with an icao in localStorage fails.
     * In this case we attempt to load the default airport with this method
     *
     * Lifecycle method. Should be called only once on initialization
     *
     * @for App
     * @method onLoadDefaultAirportAfterStorageIcaoFailure
     * @param {array<object>} airportLoadList
     */

  }, {
    key: "loadDefaultAiportAfterStorageIcaoFailure",
    value: function loadDefaultAiportAfterStorageIcaoFailure(airportLoadList) {
      var _this2 = this;

      _jquery["default"].getJSON("assets/airports/".concat(_airportConstants.DEFAULT_AIRPORT_ICAO, ".json")).then(function (defaultAirportResponse) {
        return _this2.loadAirlinesAndAircraftHandler(airportLoadList, _airportConstants.DEFAULT_AIRPORT_ICAO, defaultAirportResponse);
      });
    }
    /**
     * Handler method called after data has loaded for the airline and aircraftTypeDefinitions datasets.
     *
     * Lifecycle method. Should be called only once on initialization
     *
     * @for App
     * @method loadAirlinesAndAircraft
     * @param {array>object>} airportLoadList
     * @param {string} initialAirportIcao
     * @param {object<string>} initialAirportResponse
     */

  }, {
    key: "loadAirlinesAndAircraft",
    value: function loadAirlinesAndAircraft(airportLoadList, initialAirportIcao, initialAirportResponse) {
      var _this3 = this;

      var airlineListPromise = _jquery["default"].getJSON('assets/airlines/airlines.json');

      var aircraftListPromise = _jquery["default"].getJSON('assets/aircraft/aircraft.json');

      var airportGuideListPromise = _jquery["default"].getJSON('assets/guides/guides.json'); // This is provides a way to get async data from several sources in the app before anything else runs
      // we need to resolve data from two sources before the app can proceede. This data should always
      // exist, if it doesn't, something has gone terribly wrong.


      _jquery["default"].when(airlineListPromise, aircraftListPromise, airportGuideListPromise).done(function (airlineResponse, aircraftResponse, airportGuideResponse) {
        _this3.setupChildrenHandler(airportLoadList, initialAirportIcao, initialAirportResponse, airlineResponse[0].airlines, aircraftResponse[0].aircraft, airportGuideResponse[0]);
      });
    }
    /**
     * Callback for a successful data load
     *
     * A first load of data occurs on startup where we load the initial airport, airline definitions and
     * aircraft type definitiions. this method is called onComplete of that data load and is used to
     * instantiate various classes with the loaded data.
     *
     * This method will fire `.enable()` that will finish the initialization lifecycle and begine the game loop.
     * Lifecycle method. Should be called only once on initialization
     *
     * @for App
     * @method setupChildren
     * @param airportLoadList {array}         List of all airports
     * @param initialAirportData {object}     Airport json for the initial airport, could be default or stored airport
     * @param airlineList {array}             List of all Airline definitions
     * @param aircraftTypeDefinitionList {array}  List of all Aircraft definitions
     * @param airportGuides {object}          Airport guide JSON
     */

  }, {
    key: "setupChildren",
    value: function setupChildren(airportLoadList, initialAirportIcao, initialAirportData, airlineList, aircraftTypeDefinitionList, airportGuides) {
      this._appController.setupChildren(airportLoadList, initialAirportIcao, initialAirportData, airlineList, aircraftTypeDefinitionList, airportGuides);

      this.enable();
    }
    /**
     * Lifecycle method. Should be called only once on initialization.
     *
     * Used to fire off `init` and `init_pre` methods and also start the game loop
     *
     * @for App
     * @method enable
     */

  }, {
    key: "enable",
    value: function enable() {
      return this.init_pre().init().done();
    }
    /**
     * @for App
     * @method disable
     */

  }, {
    key: "disable",
    value: function disable() {
      return this.destroy();
    }
    /**
     * Tear down the application
     *
     * Should never be called directly, only cia `this.disable()`
     *
     * @for App
     * @method destroy
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.$element = null;
      return this;
    } // === CALLBACKS (all optional and do not need to be defined) ===
    // INIT:
    // module_init_pre()
    // module_init()
    // module_init_post()
    // module_done()
    // -- wait until all async has finished (could take a long time)
    // module_ready()
    // -- wait until first frame is ready (only triggered if UPDATE == true)
    // module_complete()
    // UPDATE:
    // module_update_pre()
    // module_update()
    // module_update_post()
    // RESIZE (called at least once during init and whenever page changes size)
    // module_resize()

    /**
     * @for App
     * @method init_pre
     */

  }, {
    key: "init_pre",
    value: function init_pre() {
      this._appController.init_pre();

      return this;
    }
    /**
     * @for App
     * @method init
     */

  }, {
    key: "init",
    value: function init() {
      this._appController.init();

      return this;
    }
    /**
     * @for App
     * @method init_post
     */

  }, {
    key: "init_post",
    value: function init_post() {
      return this;
    }
    /**
     * @for App
     * @method done
     */

  }, {
    key: "done",
    value: function done() {
      this._appController.done();

      this._appController.resize();

      this.prop.loaded = true;

      if (UPDATE) {
        requestAnimationFrame(this.onUpdateHandler);
      }

      return this;
    }
    /**
     * @for App
     * @method complete
     */

  }, {
    key: "complete",
    value: function complete() {
      this._appController.complete();

      return this;
    }
    /**
     * @for App
     * @method updatePre
     */

  }, {
    key: "updatePre",
    value: function updatePre() {
      this._appController.updatePre();

      return this;
    }
    /**
     * @for App
     * @method updatePost
     */

  }, {
    key: "updatePost",
    value: function updatePost() {
      this._appController.updatePost();

      return this;
    }
    /**
     * @for App
     * @method update
     */

  }, {
    key: "update",
    value: function update() {
      if (!this.prop.complete) {
        this.complete();
        this.prop.complete = true;
      }

      if (!UPDATE) {
        return this;
      }

      requestAnimationFrame(this.onUpdateHandler);
      this.updatePre();
      this.updatePost();

      _TimeKeeper["default"].update();

      return this;
    }
    /**
     * @for App
     * @method _onPause
     * @param shouldUpdate {boolean}
     */

  }, {
    key: "_onPause",
    value: function _onPause(shouldUpdate) {
      if (!UPDATE && shouldUpdate) {
        requestAnimationFrame(this.onUpdateHandler);
      }

      UPDATE = shouldUpdate;
    }
  }]);

  return App;
}();

exports["default"] = App;

},{"./AppController":258,"./constants/airportConstants":305,"./constants/eventNames":308,"./constants/logLevel":312,"./engine/TimeKeeper":338,"./lib/EventBus":346,"./util":386,"jquery":1}],258:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _AircraftCommander = _interopRequireDefault(require("./aircraft/AircraftCommander"));

var _AircraftController = _interopRequireDefault(require("./aircraft/AircraftController"));

var _AirlineController = _interopRequireDefault(require("./airline/AirlineController"));

var _AirportController = _interopRequireDefault(require("./airport/AirportController"));

var _AirportGuideViewController = _interopRequireDefault(require("./airportGuide/AirportGuideViewController"));

var _CanvasController = _interopRequireDefault(require("./canvas/CanvasController"));

var _AirportInfoController = _interopRequireDefault(require("./info/AirportInfoController"));

var _ChangelogController = _interopRequireDefault(require("./changelog/ChangelogController"));

var _ContentQueue = _interopRequireDefault(require("./contentQueue/ContentQueue"));

var _EventTracker = _interopRequireDefault(require("./EventTracker"));

var _GameController = _interopRequireDefault(require("./game/GameController"));

var _InputController = _interopRequireDefault(require("./InputController"));

var _EventBus = _interopRequireDefault(require("./lib/EventBus"));

var _LoadingView = _interopRequireDefault(require("./LoadingView"));

var _NavigationLibrary = _interopRequireDefault(require("./navigationLibrary/NavigationLibrary"));

var _ScopeModel = _interopRequireDefault(require("./scope/ScopeModel"));

var _SpawnPatternCollection = _interopRequireDefault(require("./trafficGenerator/SpawnPatternCollection"));

var _SpawnScheduler = _interopRequireDefault(require("./trafficGenerator/SpawnScheduler"));

var _UiController = _interopRequireDefault(require("./ui/UiController"));

var _ScoreController = _interopRequireDefault(require("./game/ScoreController"));

var _speech = require("./speech");

var _eventNames = require("./constants/eventNames");

var _selectors = require("./constants/selectors");

var _trackableEvents = require("./constants/trackableEvents");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Root controller class
 *
 * Responsible for instantiating child classes
 * Provides public API used by `App` that is used to fire lifecycle methods
 * in each of the children classes.
 *
 * @class AppController
 */
var AppController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param element {jQuery|HTML Element}
   */
  function AppController(element) {
    _classCallCheck(this, AppController);

    /**
     * Root DOM element.
     *
     * @property $element
     * @type {jQuery|HTML Element}
     * @default body
     */
    this.$element = (0, _jquery["default"])(element);
    this.$canvasesElement = null;
    this._eventBus = _EventBus["default"];
    this.loadingView = null;
    this.contentQueue = null;
    this.airlineCollection = null;
    this.aircraftCommander = null;
    this.airportGuideController = null;
    this.inputController = null;
    this.canvasController = null;
    this.changelogController = null;
    return this._init().setupHandlers().enable();
  }
  /**
   * @for AppController
   * @method _init
   * @chainable
   * @private
   */


  _createClass(AppController, [{
    key: "_init",
    value: function _init() {
      return this;
    }
    /**
     * Create and bind handler methods
     *
     * @for AppController
     * @method setupHandlers
     * @chainable
     */

  }, {
    key: "setupHandlers",
    value: function setupHandlers() {
      this.onAirportChangeHandler = this.onAirportChange.bind(this);
      return this;
    }
    /**
     * @for AppController
     * @method enable
     * @chainable
     */

  }, {
    key: "enable",
    value: function enable() {
      this._eventBus.on(_eventNames.EVENT.AIRPORT_CHANGE, this.onAirportChangeHandler);

      return this;
    }
    /**
     * @for AppController
     * @method destroy
     * @chainable
     */

  }, {
    key: "disable",
    value: function disable() {
      this._eventBus.off(_eventNames.EVENT.AIRPORT_CHANGE, this.onAirportChangeHandler);

      return this.destroy();
    }
    /**
     * @for AppController
     * @method destroy
     * @chainable
     */

  }, {
    key: "destroy",
    value: function destroy() {
      // TODO: add static class.destroy() here
      this.$element = null;
      this.$canvasesElement = null;
      this._eventBus = null;
      this.loadingView = null;
      this.contentQueue = null;
      this.airlineCollection = null;
      this.aircraftCommander = null;
      this.airportGuideController = null;
      this.inputController = null;
      this.canvasController = null;
      return this;
    }
    /**
     * Create child instances and initialize singletons.
     *
     * Called from `App.setupChildren()` only after all the required data has been retrieved
     * This method will be called
     *
     * @for AppController
     * @method setupChildren
     * @param airportLoadList {array<object>}
     * @param initialAirportIcao {string}
     * @param initialAirportData {object}
     * @param airlineList {array<object>}
     * @param aircraftTypeDefinitionList {array<object>}
     * @param airportGuideData {object}
     */

  }, {
    key: "setupChildren",
    value: function setupChildren(airportLoadList, initialAirportIcao, initialAirportData, airlineList, aircraftTypeDefinitionList, airportGuideData) {
      var _this = this;

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.AIRPORTS, 'initial-load', initialAirportIcao);

      this.$canvasesElement = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.CANVASES); // TODO: this entire method needs to be re-written. this is a temporary implemenation used to
      // get things working in a more cohesive manner. soon, all this instantiation should happen
      // in a different class and the window methods should disappear.

      this.loadingView = new _LoadingView["default"]();
      this.contentQueue = new _ContentQueue["default"](this.loadingView);

      zlsa.atc.loadAsset = function (options) {
        return _this.contentQueue.add(options);
      }; // IMPORTANT:
      // The order in which the following classes are instantiated is extremely important. Changing
      // this order could break a lot of things. This interdependency is something we should
      // work on reducing in the future.


      _AirportController["default"].init(initialAirportIcao, initialAirportData, airportLoadList);

      _NavigationLibrary["default"].init(initialAirportData);

      _SpawnPatternCollection["default"].init(initialAirportData);

      this.airlineController = new _AirlineController["default"](airlineList);
      this.scopeModel = new _ScopeModel["default"]();
      this.aircraftController = new _AircraftController["default"](aircraftTypeDefinitionList, this.airlineController, this.scopeModel);
      this.scoreController = new _ScoreController["default"](this.aircraftController);

      _SpawnScheduler["default"].init(this.aircraftController); // TEMPORARY!
      // some instances are attached to the window here as an intermediate step away from global functions.
      // this allows for any module file to call window.{module}.{method} and will make the transition to
      // explicit instance parameters easier.


      window.aircraftController = this.aircraftController;

      _UiController["default"].init(this.$element);

      this.canvasController = new _CanvasController["default"](this.$canvasesElement, this.aircraftController, this.scopeModel);
      this.aircraftCommander = new _AircraftCommander["default"](this.aircraftController, this.aircraftController.onRequestToChangeTransponderCode);
      this.inputController = new _InputController["default"](this.$element, this.aircraftCommander, this.aircraftController, this.scopeModel);
      this.airportInfoController = new _AirportInfoController["default"](this.$element);
      this.airportGuideController = new _AirportGuideViewController["default"](this.$element, airportGuideData, initialAirportData.icao);
      this.changelogController = new _ChangelogController["default"](this.contentQueue);
      this.updateViewControls();
    }
    /**
     * @for AppController
     * @method init_pre
     */

  }, {
    key: "init_pre",
    value: function init_pre() {
      _GameController["default"].init_pre();

      this.inputController.input_init_pre();
    }
    /**
     * @for AppController
     * @method init
     */

  }, {
    key: "init",
    value: function init() {
      (0, _speech.speech_init)();
      this.canvasController.canvas_init();

      _UiController["default"].ui_init();
    }
    /**
     * @for AppController
     * @method done
     */

  }, {
    key: "done",
    value: function done() {}
    /**
     * @for AppController
     * @method resize
     */

  }, {
    key: "resize",
    value: function resize() {
      this.canvasController.canvas_resize();
    }
    /**
     * @for AppController
     * @method complete
     */

  }, {
    key: "complete",
    value: function complete() {
      this.loadingView.complete();

      _GameController["default"].complete();

      this.canvasController.canvas_complete();

      _UiController["default"].ui_complete();
    }
    /**
     * @for AppController
     * @method updatePre
     */

  }, {
    key: "updatePre",
    value: function updatePre() {
      this.airportInfoController.updateClock();

      _GameController["default"].update_pre();

      this.aircraftController.update();
    }
    /**
     * @for AppController
     * @method update
     */

  }, {
    key: "update",
    value: function update() {}
    /**
     * @for AppController
     * @method updatePost
     */

  }, {
    key: "updatePost",
    value: function updatePost() {
      this.canvasController.canvasUpdatePost();
      this.aircraftController.updateAircraftStrips();
    }
    /**
     * `onChange` callback fired from within the `AirportModel` when an airport is changed.
     *
     * When an airport changes various classes need to clear and reset internal properties for
     * the new airport. this callback provides a way to orchestrate all that and send the classes
     * new data.
     *
     * This method will not run on initial load.
     *
     * @for App
     * @method onAirportChange
     * @param nextAirportJson {object}  response or cached object from airport json
     */

  }, {
    key: "onAirportChange",
    value: function onAirportChange(nextAirportJson) {
      if (!_AirportController["default"].current) {
        // if `current` is null, then this is the initial load and we dont need to reset andything
        return;
      }

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.AIRPORTS, 'airport-switcher', nextAirportJson.icao);

      _NavigationLibrary["default"].reset();

      this.airlineController.reset();
      this.aircraftController.aircraft_remove_all();
      this.scopeModel.radarTargetCollection.reset();

      _SpawnPatternCollection["default"].reset();

      _GameController["default"].destroyTimers();

      _NavigationLibrary["default"].init(nextAirportJson);

      _SpawnPatternCollection["default"].init(nextAirportJson);

      _SpawnScheduler["default"].startScheduler();

      this.updateViewControls();
    } // TODO: this should live in a view class somewhere. temporary inclusion here to prevent tests from failing
    // due to jQuery and because this does not belong in the `AirportModel`

    /**
     * Update visibility of icons at the bottom of the view that allow toggling of
     * certain view elements.
     *
     * Abstracted from `AirportModel`
     *
     * @for App
     * @method updateViewControls
     */

  }, {
    key: "updateViewControls",
    value: function updateViewControls() {
      var airport = _AirportController["default"].current;

      this._eventBus.trigger(_eventNames.EVENT.MARK_SHALLOW_RENDER);

      (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_RESTRICTED_AREAS).toggle((airport.restricted_areas || []).length > 0);
      (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_SIDS).toggle(_NavigationLibrary["default"].hasSids);
      (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_TERRAIN).toggle(airport.data.has_terrain);
    }
  }]);

  return AppController;
}();

exports["default"] = AppController;

},{"./EventTracker":259,"./InputController":260,"./LoadingView":261,"./aircraft/AircraftCommander":262,"./aircraft/AircraftController":264,"./airline/AirlineController":280,"./airport/AirportController":284,"./airportGuide/AirportGuideViewController":293,"./canvas/CanvasController":300,"./changelog/ChangelogController":302,"./constants/eventNames":308,"./constants/selectors":316,"./constants/trackableEvents":334,"./contentQueue/ContentQueue":336,"./game/GameController":339,"./game/ScoreController":341,"./info/AirportInfoController":343,"./lib/EventBus":346,"./navigationLibrary/NavigationLibrary":361,"./scope/ScopeModel":374,"./speech":375,"./trafficGenerator/SpawnPatternCollection":376,"./trafficGenerator/SpawnScheduler":378,"./ui/UiController":385,"jquery":1}],259:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _trackableEvents = require("./constants/trackableEvents");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Provide methods to send tracking events to google analytics
 *
 * Exported as a singleton
 *
 * @class EventTracker
 */
var EventTracker =
/*#__PURE__*/
function () {
  /**
   * @for EventTracker
   * @constructor
   */
  function EventTracker() {
    _classCallCheck(this, EventTracker);

    if (!this._isEnabled()) {
      console.error('Event tracking is disabled because we couldn\'t find `gtag` on the window');
      return;
    }

    this._gtag = window.gtag;
  } // TODO: UiController.onToggleTerrain() and other toggle methods seem to be expecting a
  // different order to these arguments, possibly screwing up the way events are reported to GA

  /**
   * Send a custom event to google analytics
   *
   * @for EventTracker
   * @method recordEvent
   * @param category {TRACKABLE_EVENT}
   * @param action {string}
   * @param label {string}
   * @param value {string|null} [optional]
   */


  _createClass(EventTracker, [{
    key: "recordEvent",
    value: function recordEvent(category, action, label) {
      var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      if (!this._isEnabled()) {
        console.error('Event tracking is disabled because we couldn\'t find `gtag` on the window');
        return;
      } // using underscores here to match google analytics api


      var event = {
        event_category: category,
        event_action: action,
        event_label: label
      };

      if (value) {
        event.value = value;
      }

      return this._gtag('event', event.event_category, event);
    }
    /**
     * Track a click on an outbound link
     *
     * @for EventTracker
     * @method recordClickOnOutboundLink
     * @param url {string}
     */

  }, {
    key: "recordClickOnOutboundLink",
    value: function recordClickOnOutboundLink(url) {
      if (!this._isEnabled()) {
        console.error('Event tracking is disabled because we couldn\'t find `gtag` on the window');
        return;
      } // using underscores here to match google analytics api


      var event = {
        event_category: _trackableEvents.TRACKABLE_EVENT.OUTBOUND,
        event_label: url,
        transport_type: 'beacon'
      };
      return this._gtag('event', 'click', event);
    }
    /**
     * @private
     * @method _isEnabled
     * @returns {boolean}
     */

  }, {
    key: "_isEnabled",
    value: function _isEnabled() {
      return typeof window.gtag !== 'undefined';
    }
  }]);

  return EventTracker;
}();

var _default = new EventTracker();

exports["default"] = _default;

},{"./constants/trackableEvents":334}],260:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _AirportController = _interopRequireDefault(require("./airport/AirportController"));

var _CanvasStageModel = _interopRequireDefault(require("./canvas/CanvasStageModel"));

var _EventBus = _interopRequireDefault(require("./lib/EventBus"));

var _GameController = _interopRequireDefault(require("./game/GameController"));

var _UiController = _interopRequireDefault(require("./ui/UiController"));

var _AircraftCommandParser = _interopRequireDefault(require("./parsers/aircraftCommandParser/AircraftCommandParser"));

var _ScopeCommandModel = _interopRequireDefault(require("./parsers/scopeCommandParser/ScopeCommandModel"));

var _EventTracker = _interopRequireDefault(require("./EventTracker"));

var _MeasureTool = _interopRequireDefault(require("./measurement/MeasureTool"));

var _FixCollection = _interopRequireDefault(require("./navigationLibrary/FixCollection"));

var _core = require("./math/core");

var _eventNames = require("./constants/eventNames");

var _gameOptionConstants = require("./constants/gameOptionConstants");

var _globalConstants = require("./constants/globalConstants");

var _inputConstants = require("./constants/inputConstants");

var _selectors = require("./constants/selectors");

var _trackableEvents = require("./constants/trackableEvents");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Temporary const declaration here to attach to the window AND use as internal propert
var input = {};
/**
 * @class InputController
 */

var InputController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param $element {JQuery|HTML Element}
   * @param aircraftCommander {AircraftCommander}
   * @param scopeModel {ScopeModel}
   */
  function InputController($element, aircraftCommander, aircraftController, scopeModel) {
    var _this = this;

    _classCallCheck(this, InputController);

    _defineProperty(this, "selectAircraft", function (aircraftModel) {
      if (!aircraftModel || !aircraftModel.isControllable) {
        _this.deselectAircraft();

        return;
      } // TODO: Refactor out the prop
      // using `prop` here so CanvasController knows which aircraft is selected


      prop.input.callsign = aircraftModel.callsign;
      prop.input.command = '';
      _this.input.callsign = aircraftModel.callsign;
      _this.input.command = '';

      _this.$commandInput.val("".concat(aircraftModel.callsign, " "));

      if (!_this.$commandInput.is(':focus')) {
        _this.$commandInput.focus();
      }

      _this._eventBus.trigger(_eventNames.EVENT.SELECT_AIRCRAFT, aircraftModel);
    });

    _defineProperty(this, "selectAircraftByCallsign", function (callsign) {
      var aircraftModel = _this._aircraftController.findAircraftByCallsign(callsign);

      _this.selectAircraft(aircraftModel);
    });

    this.$element = $element;
    this.$body = null;
    this.$window = null;
    this.$commandInput = null;
    this.$canvases = null;
    this._eventBus = _EventBus["default"];
    this._aircraftCommander = aircraftCommander;
    this._aircraftController = aircraftController;
    this._scopeModel = scopeModel;
    prop.input = input;
    this.input = input;
    this.input.command = '';
    this.input.callsign = '';
    this.input.data = '';
    this.input.history = [];
    this.input.history_item = null;
    this.input.click = [0, 0];
    this._mouseDelta = [0, 0];
    this._mouseDownScreenPosition = [0, 0];
    this.input.isMouseDown = false;
    this.commandBarContext = _inputConstants.COMMAND_CONTEXT.AIRCRAFT;

    this._init();
  }
  /**
   * @for InputController
   * @method _init
   */


  _createClass(InputController, [{
    key: "_init",
    value: function _init() {
      this.$body = this.$element[0];
      this.$window = (0, _jquery["default"])(window);
      this.$commandInput = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.COMMAND);
      this.$canvases = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.CANVASES);
      return this.setupHandlers().enable();
    }
    /**
     * @for InputController
     * @method setupHandlers
     */

  }, {
    key: "setupHandlers",
    value: function setupHandlers() {
      this.onKeydownHandler = this._onKeydown.bind(this);
      this.onKeyupHandler = this._onKeyup.bind(this);
      this.onCommandInputChangeHandler = this._onCommandInputChange.bind(this);
      this.onMouseScrollHandler = this._onMouseScroll.bind(this);
      this.onMouseClickAndDragHandler = this._onMouseClickAndDrag.bind(this);
      this.onMouseUpHandler = this._onMouseUp.bind(this);
      this.onMouseDownHandler = this._onMouseDown.bind(this);
      return this;
    }
    /**
     * Enable all event handlers
     *
     * @for InputController
     * @method enable
     */

  }, {
    key: "enable",
    value: function enable() {
      this.$window.on('keydown', this.onKeydownHandler);
      this.$window.on('keyup', this.onKeyupHandler);
      this.$commandInput.on('input', this.onCommandInputChangeHandler); // TODO: these are non-standard events and will be deprecated soon. this should be moved
      // over to the `wheel` event. This should also be moved over to `.on()` instead of `.bind()`
      // https://developer.mozilla.org/en-US/docs/Web/Events/wheel
      // this.$commandInput.on('DOMMouseScroll mousewheel', this.onMouseScrollHandler);

      this.$canvases.bind('DOMMouseScroll mousewheel', this.onMouseScrollHandler);
      this.$canvases.on('mousemove', this.onMouseClickAndDragHandler);
      this.$canvases.on('mouseup', this.onMouseUpHandler);
      this.$canvases.on('mousedown', this.onMouseDownHandler);
      this.$body.addEventListener('contextmenu', function (event) {
        return event.preventDefault();
      }); // TODO: Fix this

      this._eventBus.on(_eventNames.EVENT.STRIP_CLICK, this.selectAircraftByCallsign);

      return this;
    }
    /**
     * Disable all event handlers and destroy the instance
     *
     * @for InputController
     * @method disable
     */

  }, {
    key: "disable",
    value: function disable() {
      this.$window.off('keydown', this.onKeydownHandler);
      this.$window.off('keyup', this.onKeyupHandler);
      this.$commandInput.off('input', this.onCommandInputChangeHandler); // uncomment only after `.on()` for this event has been implemented.
      // this.$commandInput.off('DOMMouseScroll mousewheel', this.onMouseScrollHandler);

      this.$canvases.off('mousemove', this.onMouseClickAndDragHandler);
      this.$canvases.off('mouseup', this.onMouseUpHandler);
      this.$canvases.off('mousedown', this.onMouseDownHandler);
      this.$body.removeEventListener('contextmenu', event.preventDefault());

      this._eventBus.off(_eventNames.EVENT.STRIP_CLICK, this.selectAircraftByCallsign);

      return this.destroy();
    }
    /**
     * @for InputController
     * @method destroy
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.$element = null;
      this.$body = null;
      this.$window = null;
      this.$commandInput = null;
      this.$canvases = null;
      this.input = input;
      this.input.command = '';
      this.input.callsign = ''; // this.input.data = '';

      this.input.history = [];
      this.input.history_item = null;
      this.input.click = [0, 0];
      this._mouseDelta = [0, 0];
      this._mouseDownScreenPosition = [0, 0];
      this.input.isMouseDown = false;
      return this;
    }
    /**
     * @for InputController
     * @method input_init_pre
     */

  }, {
    key: "input_init_pre",
    value: function input_init_pre() {
      // TODO: these prop properties can be removed except for `this.input`
      this.input = input;
      this.input.command = '';
      this.input.callsign = '';
      this.input.data = '';
      this.input.history = [];
      this.input.history_item = null;
      this.input.click = [0, 0];
      this._mouseDelta = [0, 0];
      this._mouseDownScreenPosition = [0, 0];
      this.input.isMouseDown = false;
    }
    /**
     * De-selects any selected aircraft
     *
     * This clears the current aircraft callsign from the command input
     * and de-selects an active aircraft's:
     * - flight strip
     * - radar target
     *
     * @for InputController
     * @method deselectAircraft
     */

  }, {
    key: "deselectAircraft",
    value: function deselectAircraft() {
      // TODO: Refactor out the prop
      // using `prop` here so CanvasController knows which aircraft is selected
      prop.input.callsign = '';
      prop.input.command = '';
      this.input.callsign = '';
      this.input.command = '';
      this.$commandInput.val('');

      this._eventBus.trigger(_eventNames.EVENT.DESELECT_AIRCRAFT, {});
    }
    /**
     * Adds a point to the measuring tool
     *
     * @for InputController
     * @method _addMeasurePoint
     * @param event {jquery Event}
     * @param shouldReplaceLastPoint {boolean} Indicates whether this will replace the last point
     * @private
     */

  }, {
    key: "_addMeasurePoint",
    value: function _addMeasurePoint(event) {
      var shouldReplaceLastPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var currentMousePosition = _CanvasStageModel["default"].translateMousePositionToCanvasPosition(event.pageX, event.pageY);

      var x = currentMousePosition.x,
          y = currentMousePosition.y;

      var modelToUse = this._translatePointToKilometers(x, y); // Snapping should only be done when the shift key is depressed


      if (event.originalEvent.shiftKey) {
        var _this$_findClosestAir = this._findClosestAircraftAndDistanceToMousePosition(x, y),
            _this$_findClosestAir2 = _slicedToArray(_this$_findClosestAir, 2),
            aircraftModel = _this$_findClosestAir2[0],
            distanceFromAircraft = _this$_findClosestAir2[1];

        var _this$_findClosestFix = this._findClosestFixAndDistanceToMousePosition(x, y),
            _this$_findClosestFix2 = _slicedToArray(_this$_findClosestFix, 2),
            fixModel = _this$_findClosestFix2[0],
            distanceFromFix = _this$_findClosestFix2[1];

        var distance;
        var nearestModel; // Which model is closest

        if (distanceFromFix < distanceFromAircraft) {
          distance = distanceFromFix;
          nearestModel = fixModel;
        } else {
          distance = distanceFromAircraft;
          nearestModel = aircraftModel;
        } // Only snap if the distance is with 50px, otherwise the behaviour is jarring


        if (distance < _CanvasStageModel["default"].translatePixelsToKilometers(50)) {
          modelToUse = nearestModel;
        }
      }

      if (_MeasureTool["default"].hasStarted && shouldReplaceLastPoint) {
        _MeasureTool["default"].updateLastPoint(modelToUse);
      } else {
        _MeasureTool["default"].addPoint(modelToUse);
      } // Mark for shallow render so the draw motion is smooth


      this._eventBus.trigger(_eventNames.EVENT.MARK_SHALLOW_RENDER);
    }
    /**
     * Removes the last point in the measuring tool
     *
     * @for InputController
     * @method _removePreviousMeasurePoint
     * @private
     */

  }, {
    key: "_removePreviousMeasurePoint",
    value: function _removePreviousMeasurePoint() {
      _MeasureTool["default"].removePreviousPoint(); // Mark for shallow render so the feedback is immediate


      this._eventBus.trigger(_eventNames.EVENT.MARK_SHALLOW_RENDER);
    }
    /**
     * Resets the measuring tool, clearing existing paths
     *
     * @for InputController
     * @method _resetMeasuring
     * @private
     */

  }, {
    key: "_resetMeasuring",
    value: function _resetMeasuring() {
      var hasPaths = _MeasureTool["default"].hasPaths;

      _MeasureTool["default"].reset(); // Mark for shallow render so the feedback is immediate


      if (hasPaths) {
        this._eventBus.trigger(_eventNames.EVENT.MARK_SHALLOW_RENDER);
      }
    }
    /**
     * Starts the measuring tool
     *
     * @for InputController
     * @method _startMeasuring
     * @private
     */

  }, {
    key: "_startMeasuring",
    value: function _startMeasuring() {
      if (_MeasureTool["default"].isMeasuring) {
        return;
      }

      _MeasureTool["default"].startNewPath();
    }
    /**
     * Stops the measuring tool
     *
     * @for InputController
     * @method _stopMeasuring
     * @private
     */

  }, {
    key: "_stopMeasuring",
    value: function _stopMeasuring() {
      _MeasureTool["default"].endPath();
    }
    /**
     * @for InputController
     * @method _onMouseScroll
     * @param event {jquery Event}
     */

  }, {
    key: "_onMouseScroll",
    value: function _onMouseScroll(event) {
      if (event.originalEvent.wheelDelta > 0 || event.originalEvent.detail < 0) {
        _CanvasStageModel["default"].zoomIn();

        return;
      }

      _CanvasStageModel["default"].zoomOut();
    }
    /**
     * @for InputController
     * @method _onMouseClickAndDrag
     * @param event {jquery Event}
     */

  }, {
    key: "_onMouseClickAndDrag",
    value: function _onMouseClickAndDrag(event) {
      if (_MeasureTool["default"].hasStarted) {
        this._addMeasurePoint(event, true);

        return this;
      }

      if (!this.input.isMouseDown) {
        return this;
      }

      var nextXPan = event.pageX - this._mouseDownScreenPosition[0];
      var nextYPan = event.pageY - this._mouseDownScreenPosition[1]; // TODO: investigate `_mouseDelta` and what exactly it does
      // this updates the current mouseDelta so the next time through we have correct values

      this._mouseDelta = [nextXPan, nextYPan];

      _CanvasStageModel["default"].updatePan(nextXPan, nextYPan);
    }
    /**
     * @for InputController
     * @method _onMouseUp
     * @param event {jquery Event}
     */

  }, {
    key: "_onMouseUp",
    value: function _onMouseUp(event) {
      this.input.isMouseDown = false;
    }
    /**
     * @for InputController
     * @method _onMouseDown
     * @param event {jquery Event}
     */

  }, {
    key: "_onMouseDown",
    value: function _onMouseDown(event) {
      event.preventDefault();

      switch (event.which) {
        case _inputConstants.MOUSE_EVENT_CODE.LEFT_PRESS:
          this._onLeftMouseButtonPress(event);

          break;

        case _inputConstants.MOUSE_EVENT_CODE.MIDDLE_PRESS:
          _CanvasStageModel["default"].zoomReset();

          break;

        case _inputConstants.MOUSE_EVENT_CODE.RIGHT_PRESS:
          this._onRightMousePress(event);

          break;

        default:
          break;
      }
    }
    /**
     * @for InputController
     * @method _onCommandInputChange
     * @private
     */

  }, {
    key: "_onCommandInputChange",
    value: function _onCommandInputChange() {
      this.input.command = this.$commandInput.val();
    }
    /**
     * @for InputController
     * @method selectAircraft
     * @param aircraftModel {AircraftModel}
     */

  }, {
    key: "_onKeydown",

    /**
     * @for InputController
     * @method _onKeydown
     * @param event {jquery Event}
     * @private
     */
    value: function _onKeydown(event) {
      if (this._isDialog(event.target)) {
        // ignore input for dialogs
        return;
      }

      var currentCommandInputValue = this.$commandInput.val();
      var code = event.originalEvent.code;

      if (code == null) {
        // fallback for legacy browsers like IE/Edge
        code = event.originalEvent.keyCode;
      } // TODO: this swtich can be simplified, there is a lot of repetition here


      switch (code) {
        case _inputConstants.KEY_CODES.CONTROL_LEFT:
        case _inputConstants.KEY_CODES.CONTROL_RIGHT:
          this._startMeasuring();

          break;

        case _inputConstants.KEY_CODES.BAT_TICK:
        case _inputConstants.LEGACY_KEY_CODES.BAT_TICK:
          this.$commandInput.val("".concat(currentCommandInputValue, "` "));
          event.preventDefault();
          this.onCommandInputChangeHandler();
          break;

        case _inputConstants.KEY_CODES.ENTER:
        case _inputConstants.KEY_CODES.NUM_ENTER:
        case _inputConstants.LEGACY_KEY_CODES.ENTER:
          this.processCommand();
          break;

        case _inputConstants.KEY_CODES.PAGE_UP:
        case _inputConstants.LEGACY_KEY_CODES.PAGE_UP:
          this.selectPreviousAircraft();
          event.preventDefault();
          break;

        case _inputConstants.KEY_CODES.PAGE_DOWN:
        case _inputConstants.LEGACY_KEY_CODES.PAGE_DOWN:
          this.selectNextAircraft();
          event.preventDefault();
          break;
        // turning

        case _inputConstants.KEY_CODES.LEFT_ARROW:
        case _inputConstants.LEGACY_KEY_CODES.LEFT_ARROW:
          if (this._isArrowControlMethod()) {
            this.$commandInput.val("".concat(currentCommandInputValue, " t l "));
            event.preventDefault();
            this.onCommandInputChangeHandler();
          }

          break;

        case _inputConstants.KEY_CODES.RIGHT_ARROW:
        case _inputConstants.LEGACY_KEY_CODES.RIGHT_ARROW:
          if (this._isArrowControlMethod()) {
            this.$commandInput.val("".concat(currentCommandInputValue, " t r "));
            event.preventDefault();
            this.onCommandInputChangeHandler();
          }

          break;
        // climb / descend

        case _inputConstants.KEY_CODES.UP_ARROW:
        case _inputConstants.LEGACY_KEY_CODES.UP_ARROW:
          if (this._isArrowControlMethod()) {
            this.$commandInput.val("".concat(currentCommandInputValue, " c "));
            event.preventDefault();
            this.onCommandInputChangeHandler();
          } else {
            this.selectPreviousAircraft();
            event.preventDefault();
          }

          break;

        case _inputConstants.KEY_CODES.DOWN_ARROW:
        case _inputConstants.LEGACY_KEY_CODES.DOWN_ARROW:
          if (this._isArrowControlMethod()) {
            this.$commandInput.val("".concat(currentCommandInputValue, " d "));
            event.preventDefault();
            this.onCommandInputChangeHandler();
          } else {
            this.selectPreviousAircraft();
            event.preventDefault();
          }

          break;
        // takeoff / landing

        case _inputConstants.KEY_CODES.NUM_DIVIDE:
        case _inputConstants.LEGACY_KEY_CODES.NUM_DIVIDE:
          this.$commandInput.val("".concat(currentCommandInputValue, " takeoff "));
          event.preventDefault();
          this.onCommandInputChangeHandler();
          break;

        case _inputConstants.KEY_CODES.NUM_MULTIPLY:
        case _inputConstants.LEGACY_KEY_CODES.NUM_MULTIPLY:
          this.$commandInput.val("".concat(currentCommandInputValue, " * "));
          event.preventDefault();
          this.onCommandInputChangeHandler();
          break;
        // speed up / slow down

        case _inputConstants.KEY_CODES.NUM_ADD:
        case _inputConstants.LEGACY_KEY_CODES.NUM_ADD:
          this.$commandInput.val("".concat(currentCommandInputValue, " + "));
          event.preventDefault();
          this.onCommandInputChangeHandler();
          break;

        case _inputConstants.KEY_CODES.NUM_SUBTRACT:
        case _inputConstants.LEGACY_KEY_CODES.NUM_SUBTRACT:
          this.$commandInput.val("".concat(currentCommandInputValue, " - "));
          event.preventDefault();
          this.onCommandInputChangeHandler();
          break;

        case _inputConstants.KEY_CODES.F1:
        case _inputConstants.LEGACY_KEY_CODES.F1:
          event.preventDefault();

          this._scopeModel.decreasePtlLength();

          break;

        case _inputConstants.KEY_CODES.F2:
        case _inputConstants.LEGACY_KEY_CODES.F2:
          event.preventDefault();

          this._scopeModel.increasePtlLength();

          break;

        case _inputConstants.KEY_CODES.F7:
        case _inputConstants.LEGACY_KEY_CODES.F7:
          if (this.commandBarContext !== _inputConstants.COMMAND_CONTEXT.SCOPE) {
            return;
          }

          this.$commandInput.val('QP_J ');
          event.preventDefault();
          this.onCommandInputChangeHandler();
          break;

        case _inputConstants.KEY_CODES.TAB:
        case _inputConstants.LEGACY_KEY_CODES.TAB:
          this.$commandInput.val('');
          event.preventDefault();

          this._toggleCommandBarContext();

          break;

        case _inputConstants.KEY_CODES.ESCAPE:
        case _inputConstants.LEGACY_KEY_CODES.ESCAPE:
          // TODO: Probably should have its own cancel button
          this._resetMeasuring();

          _UiController["default"].closeAllDialogs();

          var hasCallsign = (0, _includes2["default"])(currentCommandInputValue, this.input.callsign);
          var hasOnlyCallsign = currentCommandInputValue.trim() === this.input.callsign;
          var hasSelectedCallsign = this.input.callsign !== '';

          if (!hasCallsign || hasOnlyCallsign || !hasSelectedCallsign) {
            this.deselectAircraft();
            return;
          }

          this.$commandInput.val("".concat(this.input.callsign, " "));
          break;

        default:
          this.$commandInput.focus();
      }
    }
    /**
     * @for InputController
     * @method _onKeydown
     * @param event {jquery Event}
     * @private
     */

  }, {
    key: "_onKeyup",
    value: function _onKeyup(event) {
      var code = event.originalEvent.code;

      if (code == null) {
        // fallback for legacy browsers like IE/Edge
        code = event.originalEvent.keyCode;
      }

      switch (code) {
        case _inputConstants.KEY_CODES.CONTROL_LEFT:
        case _inputConstants.KEY_CODES.CONTROL_RIGHT:
          this._stopMeasuring();

          this._eventBus.trigger(_eventNames.EVENT.MARK_SHALLOW_RENDER);

          break;

        default:
      }
    }
    /**
     * Returns true if $element is part of a dialog
     *
     * @for InputController
     * @method _isDialog
     * @param element {jquery element}
     * @return {boolean}
     * @private
     */

  }, {
    key: "_isDialog",
    value: function _isDialog($element) {
      if ($element.classList.contains(_selectors.CLASSNAMES.DIALOG)) {
        return true;
      }

      var parentElement = $element.parentElement;
      return parentElement && this._isDialog(parentElement);
    }
    /**
     * @for InputController
     * @method input_history_clamp
     */

  }, {
    key: "input_history_clamp",
    value: function input_history_clamp() {
      this.input.history_item = (0, _core.clamp)(0, this.input.history_item, this.input.history.length - 1);
    }
    /**
     * @for InputController
     * @method selectPreviousAircraft
     */

  }, {
    key: "selectPreviousAircraft",
    value: function selectPreviousAircraft() {
      if (this.input.history.length === 0) {
        return;
      }

      if (this.input.history_item == null) {
        this.input.history.unshift(this.input.command);
        this.input.history_item = 0;
      }

      this.input.history_item += 1;
      this.input_history_clamp();
      var callsign = this.input.history[this.input.history_item];

      var aircraftModel = this._aircraftController.findAircraftByCallsign(callsign);

      this.selectAircraft(aircraftModel);
      this.onCommandInputChangeHandler();
    }
    /**
     * @for InputController
     * @method selectNextAircraft
     */

  }, {
    key: "selectNextAircraft",
    value: function selectNextAircraft() {
      if (this.input.history.length === 0 || !this.input.history_item) {
        return;
      }

      this.input.history_item -= 1;

      if (this.input.history_item <= 0) {
        this.$commandInput.val(this.input.history[0]);
        this.onCommandInputChangeHandler();
        this.input.history.splice(0, 1);
        this.input.history_item = null;
        return;
      }

      this.input_history_clamp();
      var callsign = this.input.history[this.input.history_item];

      var aircraftModel = this._aircraftController.findAircraftByCallsign(callsign);

      this.selectAircraft(aircraftModel);
      this.onCommandInputChangeHandler();
    }
    /**
     * Encapsulation of repeated boolean logic
     *
     * @for InputController
     * @method _isArrowControlMethod
     * @return {boolean}
     */

  }, {
    key: "_isArrowControlMethod",
    value: function _isArrowControlMethod() {
      return _GameController["default"].game.option.getOptionByName(_gameOptionConstants.GAME_OPTION_NAMES.CONTROL_METHOD) === 'arrows';
    }
    /**
     * Toggle command bar between aircraft commands and scope commands
     *
     * @for InputController
     * @method _toggleCommandBarContext
     */

  }, {
    key: "_toggleCommandBarContext",
    value: function _toggleCommandBarContext() {
      switch (this.commandBarContext) {
        case _inputConstants.COMMAND_CONTEXT.AIRCRAFT:
          this.commandBarContext = _inputConstants.COMMAND_CONTEXT.SCOPE;
          this.$commandInput.attr('placeholder', 'enter scope command');
          this.$commandInput.css({
            color: 'red'
          });
          return;

        case _inputConstants.COMMAND_CONTEXT.SCOPE:
          this.commandBarContext = _inputConstants.COMMAND_CONTEXT.AIRCRAFT;
          this.$commandInput.attr('placeholder', 'enter aircraft command');
          this.$commandInput.css({
            color: 'white'
          });
          return;

        default:
          return;
      }
    }
    /**
     * Process user command to be applied to an aircraft
     *
     * @for InputController
     * @method processAircraftCommand
     */

  }, {
    key: "processAircraftCommand",
    value: function processAircraftCommand() {
      var aircraftCommandParser; // this could use $commandInput.val() as an alternative

      var userCommand = this.input.command.trim().toLowerCase(); // Using try/catch here very much on purpose. the `AircraftCommandParser` will throw when it encounters any kind
      // of error; invalid length, validation, parse, etc. Here we catch those errors, log them to the screen
      // and then throw them all at once

      try {
        aircraftCommandParser = new _AircraftCommandParser["default"](userCommand);
      } catch (error) {
        _UiController["default"].ui_log('Command not understood', true);

        throw error;
      }

      if (aircraftCommandParser.command !== _inputConstants.PARSED_COMMAND_NAME.TRANSMIT) {
        return this.processSystemCommand(aircraftCommandParser);
      }

      this.input.history.unshift(this.input.callsign);
      this.input.history_item = null;
      return this.processTransmitCommand(aircraftCommandParser);
    }
    /**
     * Process the command currently in the command bar
     *
     * @for InputController
     * @method processCommand
     * @return {array} [success of operation, response]
     */

  }, {
    key: "processCommand",
    value: function processCommand() {
      var response = [];

      if (this.commandBarContext === _inputConstants.COMMAND_CONTEXT.AIRCRAFT) {
        response = this.processAircraftCommand();
      } else if (this.commandBarContext === _inputConstants.COMMAND_CONTEXT.SCOPE) {
        response = this.processScopeCommand();
      }

      this.deselectAircraft();
      return response;
    }
    /**
     * Process user command to be applied to the user's scope
     *
     * @for InputController
     * @method processScopeCommand
     */

  }, {
    key: "processScopeCommand",
    value: function processScopeCommand() {
      var scopeCommandModel;
      var userCommand = this.input.command.trim().toLowerCase();

      try {
        scopeCommandModel = new _ScopeCommandModel["default"](userCommand);
      } catch (error) {
        _UiController["default"].ui_log('ERROR: BAD SYNTAX', true);

        throw error;
      }

      var _this$_scopeModel$run = this._scopeModel.runScopeCommand(scopeCommandModel),
          _this$_scopeModel$run2 = _slicedToArray(_this$_scopeModel$run, 2),
          successful = _this$_scopeModel$run2[0],
          response = _this$_scopeModel$run2[1];

      var isWarning = !successful;

      _UiController["default"].ui_log(response, isWarning);
    }
    /**
     * @for InputController
     * @method processSystemCommand
     * @param aircraftCommandParser {AircraftCommandParser}
     * @return {boolean}
     */

  }, {
    key: "processSystemCommand",
    value: function processSystemCommand(aircraftCommandParser) {
      switch (aircraftCommandParser.command) {
        case _inputConstants.PARSED_COMMAND_NAME.TUTORIAL:
          _UiController["default"].onToggleTutorial();

          return true;

        case _inputConstants.PARSED_COMMAND_NAME.AUTO:
          // TODO: does this function exist anywhere?
          // aircraft_toggle_auto();
          //
          // if (this._aircraftController.aircraft.auto.enabled) {
          //     UiController.ui_log('automatic controller ENGAGED');
          // } else {
          //     UiController.ui_log('automatic controller OFF');
          // }
          return true;

        case _inputConstants.PARSED_COMMAND_NAME.PAUSE:
          _GameController["default"].game_pause_toggle();

          return true;

        case _inputConstants.PARSED_COMMAND_NAME.TIMEWARP:
          var nextTimewarpValue = 0;

          if (aircraftCommandParser.args) {
            nextTimewarpValue = aircraftCommandParser.args[0];
          }

          _GameController["default"].updateTimescale(nextTimewarpValue);

          _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'timewarp-maunal-entry', "".concat(nextTimewarpValue));

          return true;

        case _inputConstants.PARSED_COMMAND_NAME.CLEAR:
          localStorage.clear();
          location.reload();
          break;

        case _inputConstants.PARSED_COMMAND_NAME.AIRPORT:
          {
            // TODO: it may be better to do this in the parser
            var airportIcao = aircraftCommandParser.args[0];

            if ((0, _has2["default"])(_AirportController["default"].airports, airportIcao)) {
              _AirportController["default"].airport_set(airportIcao);
            }

            return true;
          }

        case _inputConstants.PARSED_COMMAND_NAME.AIRAC:
          {
            var _airportIcao = _AirportController["default"].current.icao.toUpperCase();

            var airacCycle = _AirportController["default"].getAiracCycle();

            if (!airacCycle) {
              _UiController["default"].ui_log("".concat(_airportIcao, " AIRAC cycle: unknown"));

              return true;
            }

            _UiController["default"].ui_log("".concat(_airportIcao, " AIRAC cycle: ").concat(airacCycle));

            return true;
          }
        // TODO: this will be removed entirely, eventually.

        case _inputConstants.PARSED_COMMAND_NAME.RATE:
          _UiController["default"].ui_log('this command has been deprecated', true);

          return true;

        default:
          return true;
      }
    }
    /**
     * @for InputController
     * @method processTransmitCommand
     * @param aircraftCommandParser {AircraftCommandParser}
     * @return {boolean}
     */

  }, {
    key: "processTransmitCommand",
    value: function processTransmitCommand(aircraftCommandParser) {
      // TODO: abstract the aircraft callsign matching
      var matches = 0;
      var match = _globalConstants.INVALID_NUMBER;

      for (var i = 0; i < this._aircraftController.aircraft.list.length; i++) {
        var _aircraft = this._aircraftController.aircraft.list[i];

        if (_aircraft.matchCallsign(aircraftCommandParser.callsign)) {
          matches += 1;
          match = i;
        }
      }

      if (matches > 1) {
        _UiController["default"].ui_log('multiple aircraft match the callsign, say again', true);

        return true;
      }

      if (match === _globalConstants.INVALID_NUMBER) {
        _UiController["default"].ui_log('no such aircraft, say again', true);

        return true;
      }

      var aircraft = this._aircraftController.aircraft.list[match];
      return this._aircraftCommander.runCommands(aircraft, aircraftCommandParser.args);
    }
    /**
     * Facade for `_aircraftController.aircraft_get_nearest()`
     *
     * Accepts current mouse position in canvas coordinates x, y
     *
     * @for InputController
     * @method _findClosestAircraftAndDistanceToMousePosition
     * @param x {number}
     * @param y {number}
     * @returns [aircraftModel, number]
     * @private
     */

  }, {
    key: "_findClosestAircraftAndDistanceToMousePosition",
    value: function _findClosestAircraftAndDistanceToMousePosition(x, y) {
      return this._aircraftController.aircraft_get_nearest(this._translatePointToKilometers(x, y));
    }
    /**
     * Facade for `FixCollection.getNearest`
     *
     * Accepts current mouse position in canvas coordinates x, y
     *
     * @for InputController
     * @method _findClosestFixAndDistanceToMousePosition
     * @param x {number}
     * @param y {number}
     * @returns [FixModel, number]
     * @private
     */

  }, {
    key: "_findClosestFixAndDistanceToMousePosition",
    value: function _findClosestFixAndDistanceToMousePosition(x, y) {
      return _FixCollection["default"].getNearestFix(this._translatePointToKilometers(x, y));
    }
    /**
     * Triggered when a user clicks on the `right` mouse button and
     * records the position of the `right click` event.
     *
     * @param event {jquery Event}
     * @private
     */

  }, {
    key: "_onRightMousePress",
    value: function _onRightMousePress(event) {
      if (_MeasureTool["default"].isMeasuring) {
        this._removePreviousMeasurePoint();

        return;
      }

      this._markMousePressed(event, _inputConstants.MOUSE_BUTTON_NAMES.RIGHT);
    }
    /**
     * Logic that happens when a user clicks on the `left` mouse button
     *
     * TODO: this method is a first step at simplification. there is still
     * more work to do here, but this at least gets us moving in
     * the right direction
     *
     * @for InputController
     * @method _onLeftMouseButtonPress
     * @param event {jquery Event}
     * @private
     */

  }, {
    key: "_onLeftMouseButtonPress",
    value: function _onLeftMouseButtonPress(event) {
      if (_MeasureTool["default"].isMeasuring) {
        this._addMeasurePoint(event);

        return;
      }

      var currentMousePosition = _CanvasStageModel["default"].translateMousePositionToCanvasPosition(event.pageX, event.pageY);

      var _this$_findClosestAir3 = this._findClosestAircraftAndDistanceToMousePosition(currentMousePosition.x, currentMousePosition.y),
          _this$_findClosestAir4 = _slicedToArray(_this$_findClosestAir3, 2),
          aircraftModel = _this$_findClosestAir4[0],
          distanceFromPosition = _this$_findClosestAir4[1];

      if (distanceFromPosition > _CanvasStageModel["default"].translatePixelsToKilometers(50)) {
        this.deselectAircraft();

        this._markMousePressed(event, _inputConstants.MOUSE_BUTTON_NAMES.LEFT);
      } else if (this.commandBarContext === _inputConstants.COMMAND_CONTEXT.SCOPE) {
        var newCommandValue = "".concat(this.$commandInput.val(), " ").concat(aircraftModel.callsign);
        this.input.command = newCommandValue;
        this.$commandInput.val(newCommandValue);
        this.processCommand();
      } else if (aircraftModel) {
        this.selectAircraft(aircraftModel);
      }
    }
    /**
     * Method to initiate a mouse click and drag. Checks whether or not
     * the correct button is pressed, records the position, and marks the
     * mouse as down.
     *
     * @for InputController
     * @method _markMousePressed
     * @param {String} mouseButton
     */

  }, {
    key: "_markMousePressed",
    value: function _markMousePressed(event, mouseButton) {
      var canvasDragButton = _GameController["default"].getGameOption(_gameOptionConstants.GAME_OPTION_NAMES.MOUSE_CLICK_DRAG);

      var mousePositionX = event.pageX - _CanvasStageModel["default"]._panX;
      var mousePositionY = event.pageY - _CanvasStageModel["default"]._panY; // The mouse button that's been pressed isn't the one
      // that drags the canvas, so we return.

      if (mouseButton !== canvasDragButton) {
        return;
      } // Record mouse down position for panning


      this._mouseDownScreenPosition = [mousePositionX, mousePositionY];
      this.input.isMouseDown = true;
    }
    /**
     * Translate the specified x, y pixel coordinates to map kilometers
     *
     * @for InputController
     * @method _translatePointToKilometers
     * @param x {number}
     * @param y {number}
     * @returns {array<number>}
     * @private
     */

  }, {
    key: "_translatePointToKilometers",
    value: function _translatePointToKilometers(x, y) {
      return [_CanvasStageModel["default"].translatePixelsToKilometers(x - _CanvasStageModel["default"]._panX), _CanvasStageModel["default"].translatePixelsToKilometers(y + _CanvasStageModel["default"]._panY)];
    }
  }]);

  return InputController;
}();

exports["default"] = InputController;

},{"./EventTracker":259,"./airport/AirportController":284,"./canvas/CanvasStageModel":301,"./constants/eventNames":308,"./constants/gameOptionConstants":309,"./constants/globalConstants":310,"./constants/inputConstants":311,"./constants/selectors":316,"./constants/trackableEvents":334,"./game/GameController":339,"./lib/EventBus":346,"./math/core":349,"./measurement/MeasureTool":355,"./navigationLibrary/FixCollection":357,"./parsers/aircraftCommandParser/AircraftCommandParser":364,"./parsers/scopeCommandParser/ScopeCommandModel":370,"./ui/UiController":385,"jquery":1,"lodash/has":201,"lodash/includes":206}],261:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _selectors = require("./constants/selectors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Provides access to the full page takeover presented on app load
 *
 * @class LoadingView
 */
var LoadingView =
/*#__PURE__*/
function () {
  /**
   * @for LoadingView
   * @constructor
   */
  function LoadingView() {
    _classCallCheck(this, LoadingView);

    /**
     * Root DOM element
     *
     * @property $element
     * @type {jquery|null}
     */
    this.$element = null;
    return this._setupChildren();
  }
  /**
   * @for LoadingView
   * @method _setupChildren
   * @chainable
   * @private
   */


  _createClass(LoadingView, [{
    key: "_setupChildren",
    value: function _setupChildren() {
      this.$element = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.LOADING_VIEW);
      return this;
    }
    /**
     * @for LoadingView
     * @method destroy
     * @chainable
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.$element = null;
      return this;
    }
    /**
     * Initiates a timer that will fadeout the `#loadingView`
     *
     * Called from `AppController` once everything is loaded
     * and the app is ready to start.
     *
     * @for LoadingView
     * @method complete
     */

  }, {
    key: "complete",
    value: function complete() {
      var _this = this;

      global.setTimeout(function () {
        _this.$element.fadeOut(1000);

        _this.$element.css('pointerEvents', 'none');
      }, 1500);
    }
  }]);

  return LoadingView;
}();

exports["default"] = LoadingView;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./constants/selectors":316,"jquery":1}],262:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _has2 = _interopRequireDefault(require("lodash/has"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _round2 = _interopRequireDefault(require("lodash/round"));

var _AirportController = _interopRequireDefault(require("../airport/AirportController"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _GameController = _interopRequireDefault(require("../game/GameController"));

var _NavigationLibrary = _interopRequireDefault(require("../navigationLibrary/NavigationLibrary"));

var _UiController = _interopRequireDefault(require("../ui/UiController"));

var _modeControlConstants = require("./ModeControl/modeControlConstants");

var _aircraftConstants = require("../constants/aircraftConstants");

var _eventNames = require("../constants/eventNames");

var _circle = require("../math/circle");

var _core = require("../math/core");

var _aircraftCommandMap = require("../parsers/aircraftCommandParser/aircraftCommandMap");

var _speech = require("../speech");

var _radioUtilities = require("../utilities/radioUtilities");

var _unitConverters = require("../utilities/unitConverters");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 *
 *
 * @class AircraftCommander
 */
var AircraftCommander =
/*#__PURE__*/
function () {
  function AircraftCommander(aircraftController, onChangeTransponderCode) {
    _classCallCheck(this, AircraftCommander);

    this._eventBus = _EventBus["default"];
    this._aircraftController = aircraftController;
    this._onChangeTransponderCode = onChangeTransponderCode;
  }
  /**
   * @for AircraftCommander
   * @method runCommands
   * @param aircraft {AircraftModel}
   * @param commands {array<AircraftCommandParser>}
   */


  _createClass(AircraftCommander, [{
    key: "runCommands",
    value: function runCommands(aircraft, commands) {
      if (!aircraft.isControllable) {
        return true;
      }

      var response = [];
      var response_end = '';
      var redResponse = false;
      var deferred = [];

      for (var i = 0; i < commands.length; i++) {
        var command = commands[i][0];
        var args = commands[i].splice(1);

        if (command === _aircraftConstants.FLIGHT_PHASE.TAKEOFF) {
          deferred.push([command, args]);
          continue;
        }

        var retval = this.run(aircraft, command, args);

        if (retval) {
          if (!retval[0]) {
            redResponse = true;
          }

          if (!(0, _has2["default"])(retval[1], 'log') || !(0, _has2["default"])(retval[1], 'say')) {
            // TODO: reassigning a value using itself is dangerous. this should be re-wroked
            retval = [retval[0], {
              log: retval[1],
              say: retval[1]
            }];
          }

          response.push(retval[1]);

          if (retval[2]) {
            // eslint-disable-next-line prefer-destructuring
            response_end = retval[2];
          }
        }
      }

      for (var _i = 0; _i < deferred.length; _i += 1) {
        var _command = deferred[_i][0];
        var _args = deferred[_i][1];

        var _retval = this.run(aircraft, _command, _args);

        if (_retval) {
          if (!_retval[0]) {
            redResponse = true;
          } // TODO: fix the logic here this very purposly using `!=`. length is not an object and thus,
          // never null but by using coercion it evaluates to falsey if its not an array
          // true if array, and not log/say object


          if (_retval[1].length != null) {
            // make into log/say object
            _retval[1] = {
              say: _retval[1],
              log: _retval[1]
            };
          }

          response.push(_retval[1]);
        }
      }

      if (commands.length === 0) {
        response = [{
          say: 'say again',
          log: 'say again'
        }];
      }

      if (response.length >= 1) {
        if (response_end) {
          response_end = ", ".concat(response_end);
        }

        var r_log = (0, _map2["default"])(response, function (r) {
          return r.log;
        }).join(', ');
        var r_say = (0, _map2["default"])(response, function (r) {
          return r.say;
        }).join(', ');

        _UiController["default"].ui_log("".concat(aircraft.callsign, ", ").concat(r_log, " ").concat(response_end), redResponse);

        (0, _speech.speech_say)([{
          type: 'callsign',
          content: aircraft
        }, {
          type: 'text',
          content: "".concat(r_say, " ").concat(response_end)
        }], aircraft.pilotVoice);
      }

      return true;
    }
    /**
     * @for AircraftCommander
     * @method run
     * @param aircraft {AircraftModel}
     * @param command {string}
     * @param data {array}
     * @return {function}
     */

  }, {
    key: "run",
    value: function run(aircraft, command, data) {
      var functionName = _aircraftCommandMap.AIRCRAFT_COMMAND_MAP[command].functionName;

      if (typeof functionName === 'undefined') {
        return [false, 'say again?'];
      }

      return this[functionName](aircraft, data);
    }
    /**
     * Aborts an action. Deprecated.
     *
     * @for AircraftCommander
     * @method runAbort
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runAbort",
    value: function runAbort() {
      return [false, "the 'abort' command has been deprecated, please see documentation for help"];
    }
    /**
     * Set the aircraft to maintain an assigned altitude, and provide a readback
     *
     * @for AircraftCommander
     * @method runAltitude
     * @param aircraft {AircraftModel}
     * @param data {array}
     * @return {array}  [success of operation, readback]
     */

  }, {
    key: "runAltitude",
    value: function runAltitude(aircraft, data) {
      var altitudeRequested = data[0];
      var expediteRequested = data[1];
      var shouldUseSoftCeiling = _GameController["default"].game.option.getOptionByName('softCeiling') === 'yes';

      var airport = _AirportController["default"].airport_get();

      return aircraft.pilot.maintainAltitude(altitudeRequested, expediteRequested, shouldUseSoftCeiling, airport, aircraft);
    }
    /**
     * Direct an aircraft to fly and maintain a specific heading
     *
     * @for AircraftCommander
     * @method runHeading
     * @param aircraft {AircraftModel}
     * @param data {array}
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runHeading",
    value: function runHeading(aircraft, data) {
      var direction = data[0];
      var heading = data[1];
      var incremental = data[2];
      var readback = aircraft.pilot.maintainHeading(aircraft, heading, direction, incremental);

      if (!direction) {
        direction = '';
      }

      aircraft.target.turn = direction;

      if (aircraft.hasApproachClearance) {
        aircraft.pilot.cancelApproachClearance(aircraft);
      }

      return readback;
    }
    /**
     * Activate the flightplan stored in the FMS
     *
     * @for AircraftCommander
     * @method runClearedAsFiled
     * @param aircraft {AircraftModel}
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runClearedAsFiled",
    value: function runClearedAsFiled(aircraft) {
      return aircraft.pilot.clearedAsFiled();
    }
    /**
     * @for AircraftCommander
     * @method runClimbViaSID
     * @param aircraft {AircraftModel}
     * @param data {array}
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runClimbViaSID",
    value: function runClimbViaSID(aircraft, data) {
      var altitude = data[0];
      return aircraft.pilot.climbViaSid(aircraft, altitude);
    }
    /**
     * @for AircraftCommander
     * @method runCross
     * @param aircraft {AircraftModel}
     * @param data {array}
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runCross",
    value: function runCross(aircraft, data) {
      var fix = data[0].toUpperCase();
      var altitude = data[1];
      var speed = data[2];
      return aircraft.pilot.crossFix(aircraft, fix, altitude, speed);
    }
    /**
     * @for AircraftCommander
     * @method runDescendViaStar
     * @param aircraft {AircraftModel}
     * @param data {array}
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runDescendViaStar",
    value: function runDescendViaStar(aircraft) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var altitude = data[0];
      return aircraft.pilot.descendViaStar(aircraft, altitude);
    }
    /**
     * @for AircraftCommander
     * @method runSpeed
     * @param aircraft {AircraftModel}
     * @param data {array}
     */

  }, {
    key: "runSpeed",
    value: function runSpeed(aircraft, data) {
      var nextSpeed = data[0];
      return aircraft.pilot.maintainSpeed(nextSpeed, aircraft);
    }
    /**
     * Setup the Fms to enter a holding pattern,
     *
     * Can be used to hold at:
     * - A Waypoint in the current flight plan: which will be made the currentWaypoint via `fms.skipToWaypointName()`
     * - A Fix not in the flight plan: a new `LegModel` will be created and prepended thus making it the currentWaypoint
     * - The current position: a new `LegModel` will be created and prepended thus making it the currentWaypoint
     *
     * @for AircraftCommander
     * @method runHold
     * @param aircraft {AircraftModel}
     * @param data {array}
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runHold",
    value: function runHold(aircraft, data) {
      var _data = _slicedToArray(data, 4),
          turnDirection = _data[0],
          legLength = _data[1],
          fixName = _data[2],
          radial = _data[3];

      if (!fixName) {
        return [false, 'unable to hold over present position, we can only hold over fixes'];
      }

      var fixModel = _NavigationLibrary["default"].findFixByName(fixName);

      if (!fixModel) {
        return [false, "unable to hold at unknown fix ".concat(fixName)];
      }

      var holdParameters = {};
      var fallbackInboundHeading; // Instead of using DEFAULT_HOLD_PARAMETERS here, we only pass the values
      // provided by the player. These then are used to patch the _holdParameters as
      // specified in the `WaypointModel`

      if (turnDirection !== null) {
        holdParameters.turnDirection = turnDirection;
      }

      if (legLength !== null) {
        holdParameters.legLength = legLength;
      }

      if (radial !== null) {
        // Radial is given as the outbound course, so it needs to be inverted
        holdParameters.inboundHeading = (0, _circle.radians_normalize)((0, _unitConverters.degreesToRadians)(radial) + Math.PI);
      } else {
        // As radial has not been explicitly requested, we need to pass a "fallback"
        // inboundHeading, as it's possible that a default inboundHeading doesn't exist for
        // the `WaypointModel`s _holdParameters (eg. if the procedure JSON has no holds)
        fallbackInboundHeading = fixModel.positionModel.bearingFromPosition(aircraft.positionModel);
      }

      return aircraft.pilot.initiateHoldingPattern(fixName, holdParameters, fallbackInboundHeading);
    }
    /**
     * Exit holding pattern and resume navigation
     *
     * @for AircraftCommander
     * @method runCancelHoldingPattern
     * @param aircraft {AircraftModel}
     * @param args {array}
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runCancelHoldingPattern",
    value: function runCancelHoldingPattern(aircraft, args) {
      var fixName = args[0];
      return aircraft.pilot.cancelHoldingPattern(fixName);
    }
    /**
     * Skip forward to a particular fix that already exists further along the aircraft's route
     *
     * @for AircraftCommander
     * @method runDirect
     * @param data
     */

  }, {
    key: "runDirect",
    value: function runDirect(aircraft, data) {
      // TODO: maybe handle with parser?
      var fixName = data[0].toUpperCase();
      aircraft.target.turn = null;
      return aircraft.pilot.proceedDirect(fixName);
    }
    /**
     * Set the arrival runway to expect for approach and landing
     *
     * @for AircraftCommander
     * @method runExpectArrivalRunway
     * @param aircraft {AircraftModel}
     * @param data {array}
     * @return {array} [success of operation, response]
     */

  }, {
    key: "runExpectArrivalRunway",
    value: function runExpectArrivalRunway(aircraft, data) {
      var airportModel = _AirportController["default"].airport_get();

      var runwayName = data[0];
      var runwayModel = airportModel.getRunway(runwayName);

      if ((0, _isNil2["default"])(runwayModel)) {
        var previousRunwayModel = aircraft.fms.arrivalRunwayModel;
        var readback = {};
        readback.log = "unable to find Runway ".concat(runwayName, " on our charts, ") + "expecting Runway ".concat(previousRunwayModel.name, " instead");
        readback.say = "unable to find Runway ".concat((0, _radioUtilities.radio_runway)(runwayName), " on our ") + "charts, expecting Runway ".concat(previousRunwayModel.getRadioName(), " instead");
        return [false, readback];
      }

      return aircraft.pilot.updateStarLegForArrivalRunway(aircraft, runwayModel);
    }
    /**
     * @for AircraftCommander
     * @method runFlyPresentHeading
     * @param aircraft {AircraftModel}
     */

  }, {
    key: "runFlyPresentHeading",
    value: function runFlyPresentHeading(aircraft) {
      return aircraft.pilot.maintainPresentHeading(aircraft);
    }
    /**
     * @for AircraftCommander
     * @method runSayRoute
     * @param aircraft {AircraftModel}
     * @return {array}   [success of operation, readback]
     */

  }, {
    key: "runSayRoute",
    value: function runSayRoute(aircraft) {
      return aircraft.pilot.sayRoute();
    }
    /**
     * @for AircraftCommander
     * @method runSID
     * @param aircraft {AircraftModel}
     * @param data {array<string>} a string representation of the SID (may also include exit, eg sid.exit)
     * @return {array}   [success of operation, readback]
     */

  }, {
    key: "runSID",
    value: function runSID(aircraft, data) {
      var routeString = data[0];

      var airportModel = _AirportController["default"].airport_get();

      return aircraft.pilot.applyDepartureProcedure(routeString, airportModel.icao);
    }
    /**
     * @for AircraftCommander
     * @method runSTAR
     * @param data {array<string>} a string representation of the STAR, ex: `QUINN.BDEGA2.KSFO`
     * @return {array}   [success of operation, readback]
     */

  }, {
    key: "runSTAR",
    value: function runSTAR(aircraft, data) {
      var routeString = data[0];

      var airportModel = _AirportController["default"].airport_get();

      return aircraft.pilot.applyArrivalProcedure(routeString, airportModel.name);
    }
    /**
     * @for AircraftCommander
     * @method runMoveDataBlock
     * @deprecated
     */

  }, {
    key: "runMoveDataBlock",
    value: function runMoveDataBlock() {
      return [false, 'moving data blocks is now a scope command; see documentation for help'];
    }
    /**
     * Adds a new Leg to fms with a user specified route
     * Note: See notes on 'runReroute' for how to format input for this command
     *
     * @for AircraftCommander
     * @method runRoute
     * @param data
     * @return {array}   [success of operation, readback]
     */

  }, {
    key: "runRoute",
    value: function runRoute(aircraft, data) {
      // TODO: is this .toUpperCase() necessary??
      var routeString = data[0].toUpperCase();
      return aircraft.pilot.applyPartialRouteAmendment(routeString);
    }
    /**
      * Removes all legs, and replaces them with the specified route
      * Note: Input data needs to be provided with single dots connecting all
      * procedurally-linked points (eg KSFO.OFFSH9.SXC or SGD.V87.MOVER), and
      * all other points that will be simply a fix direct to another fix need
      * to be connected with double-dots (eg HLI..SQS..BERRA..JAN..KJAN)
      *
      * @for AircraftCommander
      * @method runReroute
      * @param data
      * @return {array}   [success of operation, readback]
      */

  }, {
    key: "runReroute",
    value: function runReroute(aircraft, data) {
      // TODO: is this .toUpperCase() necessary??
      var routeString = data[0].toUpperCase();
      var readback = aircraft.pilot.replaceFlightPlanWithNewRoute(routeString); // Only change to LNAV mode if the route was applied successfully, else
      // continue with the previous instructions (whether a heading, etc)

      if (readback[0]) {
        aircraft.mcp.setHeadingLnav();
      }

      return readback;
    }
    /**
     * @for AircraftCommander
     * @method runSayAltitude
     * @param aircraft
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runSayAltitude",
    value: function runSayAltitude(aircraft) {
      var altitude = (0, _round2["default"])(aircraft.altitude, -2);
      var isClimbingOrDescending = aircraft.trend !== 0;
      var readback = {};
      var altitudeChangeString = 'at ';

      if (isClimbingOrDescending) {
        altitudeChangeString = 'leaving ';
      }

      readback.log = "".concat(altitudeChangeString).concat(altitude);
      readback.say = "".concat(altitudeChangeString).concat((0, _radioUtilities.radio_altitude)(altitude));
      return [true, readback];
    }
    /**
     * @for AircraftCommander
     * @method runSayAssignedAltitude
     * @param aircraft
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runSayAssignedAltitude",
    value: function runSayAssignedAltitude(aircraft) {
      var altitude = (0, _round2["default"])(aircraft.mcp.altitude, -2);
      var readback = {};

      if (altitude === 0) {
        return [false, 'we haven\'t been assigned an altitude'];
      }

      readback.log = "assigned ".concat(altitude);
      readback.say = "assigned ".concat((0, _radioUtilities.radio_altitude)(altitude));
      return [true, readback];
    }
    /**
     * @for AircraftCommander
     * @method runSayHeading
     * @param aircraft
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runSayHeading",
    value: function runSayHeading(aircraft) {
      var heading = (0, _unitConverters.heading_to_string)(aircraft.heading);
      var readback = {};
      readback.log = "heading ".concat(heading);
      readback.say = "heading ".concat((0, _radioUtilities.radio_heading)(heading));
      return [true, readback];
    }
    /**
     * @for AircraftCommander
     * @method runSayAssignedHeading
     * @param aircraft
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runSayAssignedHeading",
    value: function runSayAssignedHeading(aircraft) {
      if (aircraft.mcp.headingMode !== _modeControlConstants.MCP_MODE.HEADING.HOLD) {
        return [false, 'we haven\'t been assigned a heading'];
      }

      var heading = (0, _unitConverters.heading_to_string)(aircraft.mcp.heading);
      var readback = {};
      readback.log = "assigned heading ".concat(heading);
      readback.say = "assigned heading ".concat((0, _radioUtilities.radio_heading)(heading));
      return [true, readback];
    }
    /**
     * @for AircraftCommander
     * @method runSaySpeed
     * @param aircraft
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runSayIndicatedAirspeed",
    value: function runSayIndicatedAirspeed(aircraft) {
      var speed = (0, _round2["default"])(aircraft.speed);
      var readback = {};
      readback.log = "indicating ".concat(speed, " knots");
      readback.say = "indicating ".concat((0, _radioUtilities.radio_spellOut)(speed), " knots");
      return [true, readback];
    }
    /**
     * @for AircraftCommander
     * @method runSayAssignedSpeed
     * @param aircraft
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runSayAssignedSpeed",
    value: function runSayAssignedSpeed(aircraft) {
      if (aircraft.mcp.speedMode !== _modeControlConstants.MCP_MODE.SPEED.HOLD) {
        return [false, 'we haven\'t been assigned a speed'];
      }

      var speed = (0, _round2["default"])(aircraft.mcp.speed);
      var readback = {};
      readback.log = "assigned ".concat(speed, " knots");
      readback.say = "assigned ".concat((0, _radioUtilities.radio_spellOut)(speed), " knots}");
      return [true, readback];
    }
    /**
     * Taxi to the specified destination. Currently only supports taxiing to runways.
     *
     * If a runway is requested but doesn't exist, an error is returned.
     *
     * @for AircraftCommander
     * @method runTaxi
     * @param {AircraftModel} aircraftModel
     * @param {array<string>} data
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "runTaxi",
    value: function runTaxi(aircraftModel, data) {
      var airportModel = _AirportController["default"].airport_get();

      var requestedRunwayName = data[0];

      if (!requestedRunwayName) {
        var readback = 'we don\'t know which runway to taxi to';
        return [false, readback];
      }

      var runwayModel = airportModel.getRunway(requestedRunwayName.toUpperCase());

      if (!runwayModel) {
        var _readback = {};
        _readback.log = "unable to find Runway ".concat(requestedRunwayName.toUpperCase(), " on our charts");
        _readback.say = "unable to find Runway ".concat((0, _radioUtilities.radio_runway)(requestedRunwayName), " on our charts");
        return [false, _readback];
      }

      return aircraftModel.taxiToRunway(runwayModel);
    }
    /**
     * @for AircraftCommander
     * @method runTakeoff
     * @param aircraft {AircraftModel}
     * @return {array}   [success of operation, readback]
     */

  }, {
    key: "runTakeoff",
    value: function runTakeoff(aircraft) {
      // TODO: update some of this queue logic to live in the RunwayModel
      var airport = _AirportController["default"].airport_get();

      var runway = aircraft.fms.departureRunwayModel;
      var spotInQueue = runway.getAircraftQueuePosition(aircraft.id);
      var isInQueue = spotInQueue > -1;

      var aircraftAhead = this._aircraftController.findAircraftById(runway.queue[spotInQueue - 1]);

      var wind = airport.getWindAtAltitude();
      var roundedWindAngleInDegrees = (0, _core.round)((0, _unitConverters.radiansToDegrees)(wind.angle) / 10) * 10;
      var roundedWindSpeed = (0, _core.round)(wind.speed);
      var readback = {};

      if (!isInQueue) {
        return [false, 'unable to take off, we\'re not at any runway'];
      }

      if (aircraft.isAirborne()) {
        return [false, 'unable to take off, we\'re already airborne'];
      }

      if (aircraft.flightPhase === _aircraftConstants.FLIGHT_PHASE.APRON) {
        return [false, 'unable to take off, we\'re still at the gate'];
      }

      if (aircraft.flightPhase === _aircraftConstants.FLIGHT_PHASE.TAXI) {
        readback.log = "unable to take off, we're still taxiing to Runway ".concat(runway.name);
        readback.say = "unable to take off, we're still taxiing to Runway ".concat((0, _radioUtilities.radio_runway)(runway.name));
        return [false, readback];
      }

      if (aircraft.flightPhase === _aircraftConstants.FLIGHT_PHASE.TAKEOFF) {
        return [false, 'already taking off'];
      }

      if (spotInQueue > 0) {
        readback.log = "number ".concat(spotInQueue, " behind ").concat(aircraftAhead.callsign);
        readback.say = "number ".concat(spotInQueue, " behind ").concat(aircraftAhead.getRadioCallsign());
        return [false, readback];
      }

      if (!aircraft.pilot.hasDepartureClearance) {
        return [false, 'unable to take off, we never received an IFR clearance'];
      } // see #1154, we may have been rerouted since we started taxiing.


      if (!aircraft.fms.isRunwayModelValidForSid(runway)) {
        readback.log = "according to our charts, Runway ".concat(runway.name, " ") + "is not valid for the ".concat(aircraft.fms.getSidIcao(), " departure");
        readback.say = "according to our charts, Runway ".concat(runway.getRadioName(), " ") + "is not valid for the ".concat(aircraft.fms.getSidName(), " departure");
        return [false, readback];
      }

      runway.removeAircraftFromQueue(aircraft.id);
      aircraft.takeoff(runway);
      readback.log = "wind ".concat(roundedWindAngleInDegrees, " at ").concat(roundedWindSpeed, ", ") + "Runway ".concat(runway.name, ", cleared for takeoff"); // We have to make it say winned to make it sound like "Wind" and not "Whined"

      readback.say = "winned ".concat((0, _radioUtilities.radio_spellOut)(roundedWindAngleInDegrees), " at ") + "".concat((0, _radioUtilities.radio_spellOut)(roundedWindSpeed), ", Runway ").concat((0, _radioUtilities.radio_runway)(runway.name), ", ") + 'cleared for takeoff';
      return [true, readback];
    }
    /**
     * @for AircraftCommander
     * @method runIls
     * @param aircraft {AircraftModel}
     * @param data {array}
     */

  }, {
    key: "runIls",
    value: function runIls(aircraft, data) {
      var approachType = 'ils';
      var runwayName = data[1].toUpperCase();

      var runwayModel = _AirportController["default"].airport_get().getRunway(runwayName);

      return aircraft.pilot.conductInstrumentApproach(aircraft, approachType, runwayModel);
    }
    /**
     * @for AircraftCommander
     * @method runLand
     * @param aircraft {AircraftModel}
     * @param data {array}
     */

  }, {
    key: "runLand",
    value: function runLand() {
      return [false, 'the "land" command has been deprecated, please use "i" / "ils" instead'];
    }
    /**
     * @for AircraftCommander
     * @method runSquawk
     * @param aircraft {AircraftModel}
     * @param data {array<string>}
     * @return {array}   [success of operation, readback]
     */

  }, {
    key: "runSquawk",
    value: function runSquawk(aircraft, data) {
      var squawk = data[0];

      var result = this._onChangeTransponderCode(squawk, aircraft);

      var message = "squawking ".concat(squawk);

      if (!result) {
        message = "unable to squawk ".concat(squawk);
      }

      return [result, message];
    }
    /**
     * @for AircraftCommander
     * @method runDelete
     * @param aircraft {AircraftModel}
     */

  }, {
    key: "runDelete",
    value: function runDelete(aircraft) {
      this._eventBus.trigger(_eventNames.EVENT.REMOVE_AIRCRAFT, aircraft);
    }
    /**
     * This command has been deprecated and this method is used only to display a warning to users
     *
     * @deprecated
     * @for AircraftCommander
     * @method runFix
     * @return {array}   [success of operation, readback]
     */

  }, {
    key: "runFix",
    value: function runFix() {
      var isWarning = true;

      _UiController["default"].ui_log('The fix command has been deprecated. Please use rr, pd or fh instead of fix', isWarning);
    }
  }]);

  return AircraftCommander;
}();

exports["default"] = AircraftCommander;

},{"../airport/AirportController":284,"../constants/aircraftConstants":303,"../constants/eventNames":308,"../game/GameController":339,"../lib/EventBus":346,"../math/circle":348,"../math/core":349,"../navigationLibrary/NavigationLibrary":361,"../parsers/aircraftCommandParser/aircraftCommandMap":366,"../speech":375,"../ui/UiController":385,"../utilities/radioUtilities":389,"../utilities/unitConverters":391,"./ModeControl/modeControlConstants":273,"lodash/has":201,"lodash/isNil":219,"lodash/map":231,"lodash/round":239}],263:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _filter2 = _interopRequireDefault(require("lodash/filter"));

var _AirportController = _interopRequireDefault(require("../airport/AirportController"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _GameController = _interopRequireWildcard(require("../game/GameController"));

var _TimeKeeper = _interopRequireDefault(require("../engine/TimeKeeper"));

var _UiController = _interopRequireDefault(require("../ui/UiController"));

var _core = require("../math/core");

var _circle = require("../math/circle");

var _vector = require("../math/vector");

var _unitConverters = require("../utilities/unitConverters");

var _aircraftConstants = require("../constants/aircraftConstants");

var _eventNames = require("../constants/eventNames");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Details about aircraft in close proximity in relation to 'the rules'
 *
 * @class AircraftConflict
 */
var AircraftConflict =
/*#__PURE__*/
function () {
  function AircraftConflict(first, second) {
    _classCallCheck(this, AircraftConflict);

    this._eventBus = _EventBus["default"];
    this.aircraft = [first, second];
    this.distance = (0, _vector.vlen)((0, _vector.vsub)(first.relativePosition, second.relativePosition));
    this.distance_delta = 0;
    this.altitude = (0, _core.abs)(first.altitude - second.altitude);
    this.collided = false;
    this.conflicts = {};
    this.violations = {};

    if (this.isAlreadyKnown()) {
      console.warn("Duplicate conflict between ".concat(this.aircraft[0].callsign, " ") + "and ".concat(this.aircraft[1].callsign, "! Scoring may be inaccurate!"));
      return;
    }

    this.update();
  }
  /**
   * Remove this conflict instance
   *
   * @for AircraftConflict
   * @method destroy
   */


  _createClass(AircraftConflict, [{
    key: "destroy",
    value: function destroy() {
      this._eventBus.trigger(_eventNames.EVENT.REMOVE_AIRCRAFT_CONFLICT, this);
    }
    /**
     * Is there anything which should be brought to the controllers attention
     *
     * @for AircraftConflict
     * @method hasAlerts
     * @returns {boolean} whether ANY conflicts OR violations exist
     */

  }, {
    key: "hasAlerts",
    value: function hasAlerts() {
      return this.hasConflict() || this.hasViolation();
    }
    /**
     *  Whether any conflicts are currently active
     */

  }, {
    key: "hasConflict",
    value: function hasConflict() {
      for (var i in this.conflicts) {
        if (this.conflicts[i]) {
          return true;
        }
      }

      return false;
    }
    /**
     *  Whether any violations are currently active
     */

  }, {
    key: "hasViolation",
    value: function hasViolation() {
      for (var i in this.violations) {
        if (this.violations[i]) {
          return true;
        }
      }

      return false;
    }
    /**
     * Recalculates and updates values for `this.distance`, `this.distance_delta`, and `this.altitude`
     *
     * @for AircraftConflict
     * @method _recalculateLateralAndVerticalDistances
     */

  }, {
    key: "_recalculateLateralAndVerticalDistances",
    value: function _recalculateLateralAndVerticalDistances() {
      var distanceAtLastUpdate = this.distance;
      this.distance = (0, _vector.vlen)((0, _vector.vsub)(this.aircraft[0].relativePosition, this.aircraft[1].relativePosition));
      this.distance_delta = this.distance - distanceAtLastUpdate;
      this.altitude = (0, _core.abs)(this.aircraft[0].altitude - this.aircraft[1].altitude);
    }
    /**
     * Update conflict and violation checks, potentially removing this conflict.
     */

  }, {
    key: "update",
    value: function update() {
      if (this.shouldBeRemoved()) {
        this.destroy();
        return;
      } // Avoid triggering any more conflicts if the two aircraft have collided


      if (this.collided) {
        return;
      }

      this._recalculateLateralAndVerticalDistances();

      this.checkCollision(); // Ignore aircraft below about 1000 feet

      var airportElevation = _AirportController["default"].airport_get().elevation;

      var gameTime = _TimeKeeper["default"].accumulatedDeltaTime;

      if (this.aircraft[0].altitude - airportElevation < 990 || this.aircraft[1].altitude - airportElevation < 990) {
        return;
      } // TODO: replace magic numbers with enum
      // Ignore aircraft in the first minute of their flight


      if (gameTime - this.aircraft[0].takeoffTime < 60 || gameTime - this.aircraft[1].takeoffTime < 60) {
        return;
      }

      this.checkProximity();
    }
    /**
     * Check for collision
     */

  }, {
    key: "checkCollision",
    value: function checkCollision() {
      if (this.aircraft[0].isOnGround() || this.aircraft[1].isOnGround()) {
        return; // TEMPORARY FIX FOR CRASHES BTWN ARRIVALS AND TAXIED A/C
      } // TODO: enumerate the magic numbers.
      // Collide within 160 feet


      var airport = _AirportController["default"].airport_get();

      if (this.distance < 0.05 && this.altitude < 160 && this.aircraft[0].isInsideAirspace(airport) && this.aircraft[1].isInsideAirspace(airport)) {
        this.collided = true;
        var isWarning = true;

        _UiController["default"].ui_log("".concat(this.aircraft[0].callsign, " collided with ").concat(this.aircraft[1].callsign), isWarning);

        _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.COLLISION);

        this.aircraft[0].hit = true;
        this.aircraft[1].hit = true;
      }
    } // TODO: this method is ripe for refactor. lots of logic that can be pulled out to
    // helper functions or other class methods.

    /**
     * Check for physical proximity and trigger crashes if necessary
     */

  }, {
    key: "checkProximity",
    value: function checkProximity() {
      // No conflict or warning if vertical separation is present
      if (this.altitude >= _aircraftConstants.SEPARATION.VERTICAL_FT) {
        this.conflicts.proximityConflict = false;
        this.conflicts.proximityViolation = false;
        return;
      }

      var conflict = false;
      var violation = false;
      var disableNotices = false;
      var a1 = this.aircraft[0];
      var a2 = this.aircraft[1];
      var applicableLatSepMin = _aircraftConstants.SEPARATION.STANDARD_LATERAL_KM; // Established on precision guided approaches && both are following different instrument approaches

      if (a1.isEstablishedOnCourse() && a2.isEstablishedOnCourse() && a1.fms.arrivalRunwayModel.name !== a2.fms.arrivalRunwayModel.name) {
        var runwayRelationship = _AirportController["default"].airport_get().getRunwayRelationshipForRunwayNames(a1.fms.arrivalRunwayModel.name, a2.fms.arrivalRunwayModel.name);

        if (runwayRelationship.parallel) {
          // hide notices for aircraft on adjacent final approach courses
          disableNotices = true;
          applicableLatSepMin = runwayRelationship.separationMinimum;
        }
      } // TODO: this should be another class method: hasSeparationViolation(applicableLatSepMin)
      // Considering all of the above cases,...


      violation = this.distance < applicableLatSepMin; // TODO: enumerate the magic number.
      // TODO: this should be another class method

      conflict = this.distance < applicableLatSepMin + 1.852 && !disableNotices || violation; // +1.0nm
      // "Passing & Diverging" Rules (the "exception" to all of the above rules)
      // test the below only if separation is currently considered insufficient

      if (conflict) {
        var hdg_difference = (0, _core.abs)((0, _circle.angle_offset)(a1.heading, a2.heading)); // TODO: couldnt these two ifs be combined to something like:
        // if (hdg_difference >= degreesToRadians(15) && hdg_difference > degreesToRadians(165)) {}

        if (hdg_difference >= (0, _unitConverters.degreesToRadians)(15)) {
          if (hdg_difference > (0, _unitConverters.degreesToRadians)(165)) {
            // 'opposite' courses
            if (this.distance_delta > 0) {
              // OKAY IF the distance is increasing
              conflict = false;
              violation = false;
            }
          } else {
            // TODO: this should definitely be a helper function that lives in one of the math/ files
            // 'same' or 'crossing' courses
            // Ray intersection from http://stackoverflow.com/a/2932601
            var ad = (0, _vector.vturn)(a1.groundTrack);
            var bd = (0, _vector.vturn)(a2.groundTrack);
            var dx = a2.relativePosition[0] - a1.relativePosition[0];
            var dy = a2.relativePosition[1] - a1.relativePosition[1];
            var det = bd[0] * ad[1] - bd[1] * ad[0];
            var u = (dy * bd[0] - dx * bd[1]) / det; // a1's distance from point of convergence

            var v = (dy * ad[0] - dx * ad[1]) / det; // a2's distance from point of convergence
            // TODO: this should be a helper function that live in one of the math/ files

            if (u < 0 || v < 0) {
              // check if either a/c has passed the point of convergence
              conflict = false; // targets are diverging

              violation = false; // targets are diverging
            } // Reference: FAA JO 7110.65, section 5-5-7-a-1:
            // (a) Aircraft are on opposite/reciprocal courses and you have observed
            // that they have passed each other; or aircraft are on same or crossing
            // courses/assigned radar vectors and one aircraft has crossed the
            // projected course of the other, and the angular difference between
            // their courses/assigned radar vectors is at least 15 degrees.

          }
        }
      } // TODO: if conflict and violation both return booleans, remove the if/else blocks below and
      // set with those values
      // Update Conflicts


      if (conflict) {
        this.conflicts.proximityConflict = true;
      } else {
        this.conflicts.proximityConflict = false;
      }

      if (violation) {
        this.violations.proximityViolation = true; // TODO: Add score penalty for 'SEPARATION_LOSS', but only ONCE
      } else {
        this.violations.proximityViolation = false;
      }
    }
    /**
     * Checks if multiple `AircraftConflict` instances have been recorded for the same conflict
     * between the aircraft involved in `this`.
     *
     * @for AircraftConflict
     * @method isDuplicate
     * @return {Boolean}
     */

  }, {
    key: "isDuplicate",
    value: function isDuplicate() {
      return this._findInstancesOfThisConflictInAircraftController().length > 1;
    }
    /**
     * Checks if an `AircraftConflict` instance already exists in `AircraftController.conflicts`
     * for the aircraft involved in `this`.
     *
     * @for AircraftConflict
     * @method isAlreadyKnown
     * @return {Boolean}
     */

  }, {
    key: "isAlreadyKnown",
    value: function isAlreadyKnown() {
      return this._findInstancesOfThisConflictInAircraftController().length > 0;
    }
    /**
     * Checks various conditions to determine whether the conflict should be removed
     *
     * @for AircraftConflict
     * @method shouldBeRemoved
     * @return {Boolean}
     */

  }, {
    key: "shouldBeRemoved",
    value: function shouldBeRemoved() {
      return this._isOutsideBoundingBox() || this.isDuplicate();
    }
    /**
     * Checks whether the distance between the aircraft is greater than the size of the bounding
     * box within which we will examine the conflict closer
     *
     * @for AircraftConflict
     * @method _isOutsideBoundingBox
     * @private
     * @return {Boolean}
     */

  }, {
    key: "_isOutsideBoundingBox",
    value: function _isOutsideBoundingBox() {
      this._recalculateLateralAndVerticalDistances();

      return this.distance > _aircraftConstants.SEPARATION.MAX_KM;
    }
    /**
     * Finds all instances (whether none, one, or multiple) of `AircraftConflict`s involving
     * the same aircraft included in `this.aircraft`.
     *
     * @for AircraftConflict
     * @method _findInstancesOfThisConflictInAircraftController
     * @return {Boolean}
     */

  }, {
    key: "_findInstancesOfThisConflictInAircraftController",
    value: function _findInstancesOfThisConflictInAircraftController() {
      var _this = this;

      return (0, _filter2["default"])(window.aircraftController.conflicts, function (conflict) {
        return (0, _includes2["default"])(conflict.aircraft, _this.aircraft[0]) && (0, _includes2["default"])(conflict.aircraft, _this.aircraft[1]);
      });
    }
  }]);

  return AircraftConflict;
}();

exports["default"] = AircraftConflict;

},{"../airport/AirportController":284,"../constants/aircraftConstants":303,"../constants/eventNames":308,"../engine/TimeKeeper":338,"../game/GameController":339,"../lib/EventBus":346,"../math/circle":348,"../math/core":349,"../math/vector":352,"../ui/UiController":385,"../utilities/unitConverters":391,"lodash/filter":190,"lodash/includes":206}],264:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _find2 = _interopRequireDefault(require("lodash/find"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _without2 = _interopRequireDefault(require("lodash/without"));

var _AirportController = _interopRequireDefault(require("../airport/AirportController"));

var _UiController = _interopRequireDefault(require("../ui/UiController"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _AircraftTypeDefinitionCollection = _interopRequireDefault(require("./AircraftTypeDefinitionCollection"));

var _AircraftModel = _interopRequireDefault(require("./AircraftModel"));

var _AircraftConflict = _interopRequireDefault(require("./AircraftConflict"));

var _StripViewController = _interopRequireDefault(require("./StripView/StripViewController"));

var _GameController = _interopRequireWildcard(require("../game/GameController"));

var _airlineHelpers = require("../airline/airlineHelpers");

var _staticPositionToDynamicPositionHelper = require("../base/staticPositionToDynamicPositionHelper");

var _core = require("../math/core");

var _distance = require("../math/distance");

var _speech = require("../speech");

var _transponderUtilities = require("../utilities/transponderUtilities");

var _unitConverters = require("../utilities/unitConverters");

var _validatorUtilities = require("../utilities/validatorUtilities");

var _aircraftConstants = require("../constants/aircraftConstants");

var _eventNames = require("../constants/eventNames");

var _globalConstants = require("../constants/globalConstants");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Temporary const declaration here to attach to the window AND use as internal property
var aircraft = {};
/**
 *
 *
 * @class AircraftController
 */

var AircraftController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @for AircraftController
   * @param aircraftTypeDefinitionList {array<object>}
   * @param airlineController {AirlineController}
   * @param scopeModel {ScopeModel}
   */
  function AircraftController(aircraftTypeDefinitionList, airlineController, scopeModel) {
    var _this = this;

    _classCallCheck(this, AircraftController);

    _defineProperty(this, "addItem", function (item) {
      return _this.aircraft.list.push(item);
    });

    _defineProperty(this, "createAircraftWithSpawnPatternModel", function (spawnPatternModel) {
      var initializationProps = _this._buildAircraftProps(spawnPatternModel);

      _this._createAircraftWithInitializationProps(initializationProps);
    });

    _defineProperty(this, "createPreSpawnAircraftWithSpawnPatternModel", function (spawnPatternModel) {
      var isPreSpawn = true;

      for (var i = 0; i < spawnPatternModel.preSpawnAircraftList.length; i++) {
        var preSpawnHeadingAndPosition = spawnPatternModel.preSpawnAircraftList[i];

        var baseAircraftProps = _this._buildAircraftProps(spawnPatternModel, isPreSpawn);

        var initializationProps = Object.assign({}, baseAircraftProps, preSpawnHeadingAndPosition);

        _this._createAircraftWithInitializationProps(initializationProps);
      }
    });

    _defineProperty(this, "onSelectAircraft", function (aircraftModel) {
      _this._onSelectAircraft(aircraftModel);
    });

    _defineProperty(this, "removeConflict", function (conflict) {
      conflict.aircraft[0].removeConflict(conflict.aircraft[1]);
      conflict.aircraft[1].removeConflict(conflict.aircraft[0]);
      _this.conflicts = (0, _without2["default"])(_this.conflicts, conflict);
    });

    _defineProperty(this, "onRequestToChangeTransponderCode", function (transponderCode, aircraftModel) {
      if (!(0, _transponderUtilities.isValidTransponderCode)(transponderCode) || _this._isTransponderCodeInUse(transponderCode)) {
        return false;
      }

      _this._removeTransponderCodeFromUse(aircraftModel.transponderCode);

      _this._addTransponderCodeToInUse(transponderCode);

      aircraftModel.transponderCode = transponderCode;
      return true;
    });

    _defineProperty(this, "_onSelectAircraft", function (aircraftModel) {
      if (!aircraftModel.isControllable) {
        return;
      }

      _this._stripViewController.selectStripView(aircraftModel);
    });

    _defineProperty(this, "_onDeselectAircraft", function () {
      _this._stripViewController.findAndDeselectActiveStripView();
    });

    _defineProperty(this, "_onStripDoubleClickHandler", function (callsign) {
      var _this$findAircraftByC = _this.findAircraftByCallsign(callsign),
          relativePosition = _this$findAircraftByC.relativePosition;

      var _relativePosition = _slicedToArray(relativePosition, 2),
          x = _relativePosition[0],
          y = _relativePosition[1];

      _this._eventBus.trigger(_eventNames.EVENT.REQUEST_TO_CENTER_POINT_IN_VIEW, {
        x: x,
        y: y
      });
    });

    if ((0, _validatorUtilities.isEmptyOrNotArray)(aircraftTypeDefinitionList)) {
      // eslint-disable-next-line max-len
      throw new TypeError('Invalid aircraftTypeDefinitionList passed to AircraftTypeDefinitionCollection. ' + "Expected and array but received ".concat(_typeof(aircraftTypeDefinitionList)));
    } // TODO: this may need to use instanceof instead, but that may be overly defensive


    if (!(0, _isObject2["default"])(airlineController)) {
      throw new TypeError('Invalid parameters. Expected airlineCollection to be defined');
    }
    /**
     * Reference to an `AirlineController` instance
     *
     * @property _airlineController
     * @type {AirlineController}
     * @default airlineController
     * @private
     */


    this._airlineController = airlineController;
    /**
     * Local reference to static `EventBus` class
     *
     * @property _eventBus
     * @type {EventBus}
     * @default EventBus
     * @private
     */

    this._eventBus = _EventBus["default"];
    /**
     * Reference to an `AircraftTypeDefinitionCollection` instance
     *
     * Provides definitions for all available aircraft types
     *
     * @property AircraftTypeDefinitionCollection
     * @type {AircraftTypeDefinitionCollection}
     */

    this.aircraftTypeDefinitionCollection = new _AircraftTypeDefinitionCollection["default"](aircraftTypeDefinitionList);
    /**
     * Local reference to the scope model
     *
     * @for AircraftController
     * @property _scopeModel
     * @type {ScopeModel}
     * @private
     */

    this._scopeModel = scopeModel;
    /**
     * List of `transponderCode` values in use
     *
     * Each `transponderCode` should be unique, thus we maintain this list
     * so we can know which codes are active.
     *
     * @property _transponderCodesInUse
     * @type {array<string>}
     * @private
     */

    this._transponderCodesInUse = [];
    prop.aircraft = aircraft;
    this.aircraft = aircraft; // TODO: this should its own collection class

    this.aircraft.list = [];
    this.aircraft.auto = {
      enabled: false
    };
    this.conflicts = [];
    /**
     * Instance of the `StripViewController`
     *
     * @property _stripViewController
     * @type {StripViewController}
     * @private
     */

    this._stripViewController = new _StripViewController["default"]();
    return this.init()._setupHandlers().enable();
  }
  /**
   * @for AircraftController
   * @method init
   * @chainable
   */


  _createClass(AircraftController, [{
    key: "init",
    value: function init() {
      return this;
    }
    /**
     * Set up event handlers
     *
     * @for AircraftController
     * @method _setupHandlers
     * @private
     * @chainable
     */

  }, {
    key: "_setupHandlers",
    value: function _setupHandlers() {
      this._onRemoveAircraftHandler = this.aircraft_remove.bind(this);
      return this;
    }
    /**
     * @for AircraftController
     * @method enable
     * @chainable
     */

  }, {
    key: "enable",
    value: function enable() {
      this._eventBus.on(_eventNames.EVENT.ADD_AIRCRAFT, this.addItem);

      this._eventBus.on(_eventNames.EVENT.STRIP_DOUBLE_CLICK, this._onStripDoubleClickHandler);

      this._eventBus.on(_eventNames.EVENT.SELECT_AIRCRAFT, this.onSelectAircraft);

      this._eventBus.on(_eventNames.EVENT.DESELECT_AIRCRAFT, this._onDeselectAircraft);

      this._eventBus.on(_eventNames.EVENT.REMOVE_AIRCRAFT, this._onRemoveAircraftHandler);

      this._eventBus.on(_eventNames.EVENT.REMOVE_AIRCRAFT_CONFLICT, this.removeConflict);

      return this;
    }
    /**
     * @for AircraftController
     * @method disable
     * @chainable
     */

  }, {
    key: "disable",
    value: function disable() {
      this._eventBus.off(_eventNames.EVENT.ADD_AIRCRAFT, this.addItem);

      this._eventBus.off(_eventNames.EVENT.STRIP_DOUBLE_CLICK, this._onStripDoubleClickHandler);

      this._eventBus.off(_eventNames.EVENT.SELECT_AIRCRAFT, this._onSelectAircraft);

      this._eventBus.off(_eventNames.EVENT.DESELECT_AIRCRAFT, this._onDeselectAircraft);

      this._eventBus.off(_eventNames.EVENT.REMOVE_AIRCRAFT, this._onRemoveAircraftHandler);

      this._eventBus.off(_eventNames.EVENT.REMOVE_AIRCRAFT_CONFLICT, this.removeConflict);

      return this;
    }
    /**
     * Adds an `AircraftModel` to the collection
     *
     * @for AircraftController
     * @method addItem
     * @param item {AircraftModel}
     */

  }, {
    key: "aircraft_auto_toggle",

    /**
     * @for AircraftController
     * @method aircraft_auto_toggle
     */
    value: function aircraft_auto_toggle() {
      this.aircraft.auto.enabled = !this.aircraft.auto.enabled;
    }
    /**
     * @for AircraftController
     * @method aircraft_get_nearest
     * @param position {array<number>} These are x, y canvas units (km)
     */

  }, {
    key: "aircraft_get_nearest",
    value: function aircraft_get_nearest(position) {
      var nearest = null;
      var distance = Infinity;

      for (var i = 0; i < this.aircraft.list.length; i++) {
        var _aircraft = this.aircraft.list[i];
        var d = (0, _distance.distance2d)(_aircraft.relativePosition, position);

        if (d < distance && _aircraft.isVisible() && !_aircraft.hit) {
          distance = d;
          nearest = i;
        }
      }

      return [this.aircraft.list[nearest], distance];
    }
    /**
     * Returns whether the specified aircraft model is in an area where they are controllable
     *
     * @for AircraftController
     * @method isAircraftVisible
     * @param aircraft {AircraftModel}
     * @param factor {number}
     * @returns {boolean}
     */

  }, {
    key: "isAircraftVisible",
    value: function isAircraftVisible(aircraft) {
      var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var visibleDistance = _AirportController["default"].airport_get().ctr_radius * factor;
      return aircraft.distance < visibleDistance;
    }
    /**
     * @for AircraftController
     * @method aircraft_remove_all
     */

  }, {
    key: "aircraft_remove_all",
    value: function aircraft_remove_all() {
      // iterating backwards because each iteration removes a list item
      // iterating forward would cause skipping as the array shifts
      for (var i = this.aircraft.list.length - 1; i >= 0; i--) {
        this.aircraft_remove(this.aircraft.list[i]);
      }
    }
    /**
     * @for AircraftController
     * @method aircraft_remove
     * @param aircraftModel {AircraftModel}
     */

  }, {
    key: "aircraft_remove",
    value: function aircraft_remove(aircraftModel) {
      _AirportController["default"].removeAircraftFromAllRunwayQueues(aircraftModel);

      this.removeFlightNumberFromList(aircraftModel);
      this.removeAircraftModelFromList(aircraftModel);

      this._removeTransponderCodeFromUse(aircraftModel);

      this.removeAllAircraftConflictsForAircraft(aircraftModel);

      if (aircraftModel.isControllable) {
        this.removeStripView(aircraftModel);
      }

      this._scopeModel.radarTargetCollection.removeRadarTargetModelForAircraftModel(aircraftModel);
    }
    /**
     * This method is part of the game loop.
     *
     * Every effort should be made to optimize this method and
     * any other methods called from within
     *
     * @for AircraftController
     * @method update
     */

  }, {
    key: "update",
    value: function update() {
      if (this.aircraft.list.length === 0) {
        return;
      } // TODO: this is getting better, but still needs more simplification


      for (var i = 0; i < this.aircraft.list.length; i++) {
        var aircraftModel = this.aircraft.list[i];
        aircraftModel.update();
        aircraftModel.updateWarning(); // TODO: conflict checking eats up a lot of resources when there are more than
        //       30 aircraft, exit early if we're still taxiing

        if (aircraftModel.isTaxiing()) {
          continue;
        }

        this._updateAircraftConflicts(aircraftModel, i);

        this._updateAircraftVisibility(aircraftModel); // `#isFlightStripRemovable` will be true even when there is no corresponding
        // `StripView` for and `aircraftModel`


        if (aircraftModel.isFlightStripRemovable && this._stripViewController.hasStripViewModel(aircraftModel)) {
          this._stripViewController.removeStripView(aircraftModel);
        }
      }
    }
    /**
     * Finds an aircraft by its callsign
     *
     * @method findAircraftByCallsign
     * @param  {string} callsign
     * @return {AircraftModel}
     */

  }, {
    key: "findAircraftByCallsign",
    value: function findAircraftByCallsign(callsign) {
      if (!callsign) {
        return;
      }

      var normalizedCallsign = callsign.toUpperCase();
      return (0, _find2["default"])(this.aircraft.list, function (aircraft) {
        return aircraft.callsign === normalizedCallsign;
      });
    }
    /**
     * Finds an aircraft by its internal id
     *
     * @method findAircraftById
     * @param  {string} id
     * @return {AircraftModel}
     */

  }, {
    key: "findAircraftById",
    value: function findAircraftById(id) {
      if (!id) {
        return;
      }

      return (0, _find2["default"])(this.aircraft.list, function (aircraft) {
        return aircraft.id === id;
      });
    }
    /**
     * Update all the `StripViewModel` objects with up-to-date aircraft data
     *
     * This is a **HOT** method and will run within the game loop
     *
     * @for AircraftController
     * @method updateAircraftStrips
     */

  }, {
    key: "updateAircraftStrips",
    value: function updateAircraftStrips() {
      this._stripViewController.update(this.aircraft.list);
    }
    /**
     * Public facade for `._onSelectAircraft`
     *
     * @for AircraftController
     * @method onSelectAircraft
     * @param aircaftModel {AircraftModel}
     */

  }, {
    key: "debug",

    /**
     * @method debug
     * @param  {string} [callsign='']
     * @return {AircraftModel}
     */
    value: function debug() {
      var callsign = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return this.findAircraftByCallsign(callsign);
    }
    /**
     * Add a new `AircraftConflict` instance to the list of existing conflicts
     *
     * @for AircraftController
     * @method addConflict
     * @param aircraft {AircraftModel}       aircraft 1
     * @param otherAircraft {AircraftModel}  aircraft 2
     */

  }, {
    key: "addConflict",
    value: function addConflict(aircraft, otherAircraft) {
      var conflict = new _AircraftConflict["default"](aircraft, otherAircraft);

      if (conflict.shouldBeRemoved()) {
        conflict.destroy();
        return;
      }

      this.conflicts.push(conflict);
      aircraft.addConflict(conflict, otherAircraft);
      otherAircraft.addConflict(conflict, aircraft);
    }
    /**
     * Pass the call onto the `airlineController` to remove flightNumber
     * from the list of active flightNumbers
     *
     * @for AircraftController
     * @method removeFlightNumberFromList
     * @param airlineId {string}
     * @param callsign {string}
     */

  }, {
    key: "removeFlightNumberFromList",
    value: function removeFlightNumberFromList(_ref) {
      var airlineId = _ref.airlineId,
          callsign = _ref.callsign;

      this._airlineController.removeFlightNumberFromList(airlineId, callsign);
    }
    /**
     * Remove the specified aircraft from `AircraftController.aircraft.list`
     *
     * @for AircraftController
     * @method removeAircraftModelFromList
     * @param  {AircraftModel} aircraft the aircraft to remove
     */

  }, {
    key: "removeAircraftModelFromList",
    value: function removeAircraftModelFromList(aircraft) {
      this.aircraft.list = (0, _without2["default"])(this.aircraft.list, aircraft);
    }
    /**
     * Remove an `AircraftConflict` instance from the list of existing conflicts
     *
     * May be called via an `EventBus.trigger()`
     *
     * @for AircraftController
     * @method removeConflict
     * @param  conflict {AircraftConflict} the conflict instance to remove
     */

  }, {
    key: "removeAllAircraftConflictsForAircraft",

    /**
     * Remove any conflicts that involve the specified aircraft
     *
     * @for AircraftController
     * @method removeAllAircraftConflictsForAircraft
     * @param aircraft {AircraftModel}  the aircraft to remove
     */
    value: function removeAllAircraftConflictsForAircraft(aircraft) {
      for (var otherAircraftCallsign in aircraft.conflicts) {
        aircraft.conflicts[otherAircraftCallsign].destroy();
      }
    }
    /**
     * Remove a `StripViewModel` associated with the `aircraftModel`
     *
     * This will remove it from the DOM and properly destroy the model.
     *
     * @for AircraftController
     * @method removeStripView
     * @param aircraftModel {AircraftModel}
     */

  }, {
    key: "removeStripView",
    value: function removeStripView(aircraftModel) {
      this._stripViewController.removeStripView(aircraftModel);
    }
    /**
     * Called from within the `AircraftCommander` this method is used:
     * - to verify that the `nextTransponderCode` is valid
     * - remove the previous `transponderCode` from `#_transponderCodesInUse`
     * - add `nextTransponderCode` to `#_transponderCodesInUse`
     *
     * @for AircraftController
     * @method onRequestToChangeTransponderCode
     * @param transponderCode {string}
     * @param aircraftModel {aircraftModel}
     * @return {boolean}
     */

  }, {
    key: "_createAircraftWithInitializationProps",

    /**
     * Accept a pre-built object that can be used to create an `AircraftModel`
     * and then add it to the collection.
     *
     * This could be a spawning aircraft or one that already exists along a route.
     *
     * This method is the *_single place_* to create a new `AircraftModel`.
     * Any method that needs to create a new aircraft should be routed through here.
     *
     * @for AircraftController
     * @method _createAircraftWithInitializationProps
     * @param initializationProps {object}
     * @private
     */
    value: function _createAircraftWithInitializationProps(initializationProps) {
      var aircraftModel = new _AircraftModel["default"](initializationProps); // triggering event bus rather than calling locally because multiple classes
      // are listening for the event and aircraft model

      this._eventBus.trigger(_eventNames.EVENT.ADD_AIRCRAFT, aircraftModel);
    }
    /**
     * Used to build up the appropriate data needed to instantiate an `AircraftModel`
     *
     * @for AircraftController
     * @method _buildAircraftProps
     * @param spawnPatternModel {SpawnPatternModel}
     * @param isPreSpawn {boolean} [default = false]
     * @return {object}
     * @private
     */

  }, {
    key: "_buildAircraftProps",
    value: function _buildAircraftProps(spawnPatternModel) {
      var isPreSpawn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var airlineId = spawnPatternModel.getRandomAirlineForSpawn(); // TODO: update `airlineNameAndFleetHelper` to accept a string

      var _airlineNameAndFleetH = (0, _airlineHelpers.airlineNameAndFleetHelper)([airlineId]),
          name = _airlineNameAndFleetH.name,
          fleet = _airlineNameAndFleetH.fleet;

      var airlineModel = this._airlineController.findAirlineById(name);

      if (typeof airlineModel === 'undefined') {
        console.warn("Expected airline \"".concat(name, "\" to be defined, but it is not! Using AAL instead."));
        airlineModel = this._airlineController.findAirlineById('aal');
      } // TODO: impove the `airlineModel` logic here
      // this seems inefficient to find the model here and then pass it back to the controller but
      // since we already have it, it makes little sense to look for it again in the controller


      var flightNumber = this._airlineController.generateFlightNumberWithAirlineModel(airlineModel);

      var aircraftTypeDefinition = this._getRandomAircraftTypeDefinitionForAirlineId(airlineId, airlineModel); // TODO: this may need to be reworked.
      // if we are building a preSpawn aircraft, cap the altitude at 18000 so aircraft that spawn closer to
      // airspace can safely enter controlled airspace properly


      var altitude = spawnPatternModel.altitude;

      if (isPreSpawn && spawnPatternModel.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL) {
        altitude = Math.min(18000, altitude);
      }

      var dynamicPositionModel = (0, _staticPositionToDynamicPositionHelper.convertStaticPositionToDynamic)(spawnPatternModel.positionModel);

      var transponderCode = this._generateUniqueTransponderCode(_AirportController["default"].airport_get().icao);

      return {
        fleet: fleet,
        altitude: altitude,
        transponderCode: transponderCode,
        origin: spawnPatternModel.origin,
        destination: spawnPatternModel.destination,
        callsign: flightNumber,
        category: spawnPatternModel.category,
        airline: airlineModel.icao,
        airlineCallsign: airlineModel.radioName,
        speed: spawnPatternModel.speed,
        heading: spawnPatternModel.heading,
        positionModel: dynamicPositionModel,
        icao: aircraftTypeDefinition.icao,
        model: aircraftTypeDefinition,
        routeString: spawnPatternModel.routeString,
        // TODO: this may not be needed anymore
        waypoints: (0, _get2["default"])(spawnPatternModel, 'waypoints', [])
      };
    }
    /**
     * Given an `airlineId`, find a random aircraft type from the airline.
     *
     * This is useful for when we need to create an aircraft to spawn and
     * only know the airline that it belongs to.
     *
     * @for AircraftController
     * @method _getRandomAircraftTypeDefinitionForAirlineId
     * @param airlineId {string}
     * @param airlineModel {AirlineModel}
     * @return aircraftDefinition {AircraftTypeDefinitionModel}
     * @private
     */

  }, {
    key: "_getRandomAircraftTypeDefinitionForAirlineId",
    value: function _getRandomAircraftTypeDefinitionForAirlineId(airlineId, airlineModel) {
      return this.aircraftTypeDefinitionCollection.getAircraftDefinitionForAirlineId(airlineId, airlineModel);
    }
    /**
     * Generate a unique `transponderCode`
     *
     * This method should only be run while building props for a
     * soon-to-be-instantiated `AircraftModel` at the specified
     * `icao` airport code
     *
     * @for AircraftController
     * @method _generateUniqueTransponderCode
     * @param icao {sting}
     * @return {string}
     * @private
     */

  }, {
    key: "_generateUniqueTransponderCode",
    value: function _generateUniqueTransponderCode(icao) {
      var transponderCode = (0, _transponderUtilities.generateTransponderCode)();

      if (!(0, _transponderUtilities.isDiscreteTransponderCode)(icao, transponderCode) || this._isTransponderCodeInUse(transponderCode)) {
        // the value generated isn't valid or is already in use, recurse back through this method and try again
        return this._generateUniqueTransponderCode(icao);
      }

      this._addTransponderCodeToInUse(transponderCode);

      return transponderCode;
    }
    /**
     * Add a given `transponderCode` to the `#_transponderCodesInUse` list
     *
     * @for AircraftController
     * @method _addTransponderCodeToInUse
     * @param transponderCode {string}
     */

  }, {
    key: "_addTransponderCodeToInUse",
    value: function _addTransponderCodeToInUse(transponderCode) {
      this._transponderCodesInUse.push(transponderCode);
    }
    /**
     * Remove the `transponderCode` from the list of `#_transponderCodesInUse`
     *
     * @for AircraftController
     * @method _removeTransponderCodeFromUse
     * @param transponderCode {string}
     */

  }, {
    key: "_removeTransponderCodeFromUse",
    value: function _removeTransponderCodeFromUse(_ref2) {
      var transponderCode = _ref2.transponderCode;
      this._transponderCodesInUse = (0, _without2["default"])(this._transponderCodesInUse, transponderCode);
    }
    /**
     * Boolean helper used to determine if a given `transponderCode` is already
     * present within the `#_transponderCodesInUse` list.
     *
     * @for AircraftController
     * @method _isTransponderCodeInUse
     * @param transponderCode {string}
     * @return {booelean}
     */

  }, {
    key: "_isTransponderCodeInUse",
    value: function _isTransponderCodeInUse(transponderCode) {
      return this._transponderCodesInUse.indexOf(transponderCode) !== _globalConstants.INVALID_INDEX;
    }
    /**
     * Show a `StripViewModel` as selected
     *
     * @for AircraftController
     * @method _onSelectAircraft
     * @param  aircraftModel {AircraftModel}
     * @private
     */

  }, {
    key: "_shouldAddNewConflict",

    /**
     * Encapsulates math and logic used to detrmine if a new `AircraftConflict` should
     * be created for two specific aircraft
     *
     * Fast 2D bounding box check, there are no conflicts over 8nm apart (14.816km)
     * no violation can occur in this case
     * Variation of:
     * http://gamedev.stackexchange.com/questions/586/what-is-the-fastest-way-to-work-out-2d-bounding-box-intersection
     *
     * @for AircraftController
     * @method _shouldAddNewConflict
     * @param {AircraftModel} aircraftModel
     * @param {AircraftModel} comparisonAircraftModel
     * @return {boolean}
     * @private
     */
    value: function _shouldAddNewConflict(aircraftModel, comparisonAircraftModel) {
      var boundingBoxLength = (0, _unitConverters.km)(8);
      var dx = (0, _core.abs)(aircraftModel.relativePosition[0] - comparisonAircraftModel.relativePosition[0]);
      var dy = (0, _core.abs)(aircraftModel.relativePosition[1] - comparisonAircraftModel.relativePosition[1]);
      return dx < boundingBoxLength && dy < boundingBoxLength;
    }
    /**
     * Given an `aircraftModel` check against each other aircraft for conflicts
     * after physics (current position) have been updated
     *
     * @for AircraftController
     * @param {AircraftModel} aircraftModel
     * @param {number} currentUpdateIndex
     * @private
     */

  }, {
    key: "_updateAircraftConflicts",
    value: function _updateAircraftConflicts(aircraftModel, currentUpdateIndex) {
      for (var j = currentUpdateIndex + 1; j < this.aircraft.list.length; j++) {
        var otherAircraftModel = this.aircraft.list[j]; // TODO: though looking better, this logic still needs some work

        if (otherAircraftModel.isTaxiing()) {
          continue;
        }

        if (aircraftModel.hasConflictWithAircraftModel(otherAircraftModel)) {
          aircraftModel.conflicts[otherAircraftModel.callsign].update();
          continue;
        }

        if (this._shouldAddNewConflict(aircraftModel, otherAircraftModel)) {
          this.addConflict(aircraftModel, otherAircraftModel);
        }
      }
    }
    /**
     * Determine if an `aircraftModel` has exited controlled airspace then notify
     * user and score event
     *
     * TODO: This method needs to include some logic currently happeing in `AircraftModel`
     *       used to remove a departing aricraft
     *
     * @for AircraftController
     * @param {AircraftModel} aircraftModel
     * @private
     */

  }, {
    key: "_updateAircraftVisibility",
    value: function _updateAircraftVisibility(aircraftModel) {
      // TODO: these next 3 logic blocks could use some cleaning/abstraction
      if (aircraftModel.isArrival() && aircraftModel.isStopped() && !aircraftModel.hit) {
        _EventBus["default"].trigger(_eventNames.AIRCRAFT_EVENT.FULLSTOP, aircraftModel, aircraftModel.fms.arrivalRunwayModel);

        _UiController["default"].ui_log("".concat(aircraftModel.callsign, " switching to ground, good day"));

        (0, _speech.speech_say)([{
          type: 'callsign',
          content: aircraftModel
        }, {
          type: 'text',
          content: ', switching to ground, good day'
        }], aircraftModel.pilotVoice);

        _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.ARRIVAL);

        aircraftModel.setIsFlightStripRemovable();
        aircraftModel.setIsRemovable();
        this.aircraft_remove(aircraftModel);
        return;
      }

      if (aircraftModel.hit && aircraftModel.isOnGround()) {
        _UiController["default"].ui_log("Lost radar contact with ".concat(aircraftModel.callsign), true);

        aircraftModel.setIsFlightStripRemovable();
        aircraftModel.setIsRemovable();
        this.aircraft_remove(aircraftModel);
        (0, _speech.speech_say)([{
          type: 'callsign',
          content: aircraftModel
        }, {
          type: 'text',
          content: ', radar contact lost'
        }], aircraftModel.pilotVoice);
      } // Clean up the screen from aircraft that are too far


      if (!this.isAircraftVisible(aircraftModel, 2) && !aircraftModel.isControllable && aircraftModel.isRemovable) {
        this.aircraft_remove(aircraftModel);
      }
    }
  }]);

  return AircraftController;
}();

exports["default"] = AircraftController;

},{"../airline/airlineHelpers":282,"../airport/AirportController":284,"../base/staticPositionToDynamicPositionHelper":299,"../constants/aircraftConstants":303,"../constants/eventNames":308,"../constants/globalConstants":310,"../game/GameController":339,"../lib/EventBus":346,"../math/core":349,"../math/distance":350,"../speech":375,"../ui/UiController":385,"../utilities/transponderUtilities":390,"../utilities/unitConverters":391,"../utilities/validatorUtilities":392,"./AircraftConflict":263,"./AircraftModel":265,"./AircraftTypeDefinitionCollection":266,"./StripView/StripViewController":276,"lodash/find":191,"lodash/get":200,"lodash/isObject":221,"lodash/without":252}],265:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _ceil2 = _interopRequireDefault(require("lodash/ceil"));

var _defaultTo2 = _interopRequireDefault(require("lodash/defaultTo"));

var _findIndex2 = _interopRequireDefault(require("lodash/findIndex"));

var _floor2 = _interopRequireDefault(require("lodash/floor"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _uniqueId2 = _interopRequireDefault(require("lodash/uniqueId"));

var _AircraftTypeDefinitionModel = _interopRequireDefault(require("./AircraftTypeDefinitionModel"));

var _AirportController = _interopRequireDefault(require("../airport/AirportController"));

var _Fms = _interopRequireDefault(require("./FlightManagementSystem/Fms"));

var _GameController = _interopRequireWildcard(require("../game/GameController"));

var _ModeController = _interopRequireDefault(require("./ModeControl/ModeController"));

var _Pilot = _interopRequireDefault(require("./Pilot/Pilot"));

var _TimeKeeper = _interopRequireDefault(require("../engine/TimeKeeper"));

var _UiController = _interopRequireDefault(require("../ui/UiController"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _eventNames = require("../constants/eventNames");

var _circle = require("../math/circle");

var _core = require("../math/core");

var _flightMath = require("../math/flightMath");

var _vector = require("../math/vector");

var _speech = require("../speech");

var _radioUtilities = require("../utilities/radioUtilities");

var _unitConverters = require("../utilities/unitConverters");

var _modeControlConstants = require("./ModeControl/modeControlConstants");

var _aircraftConstants = require("../constants/aircraftConstants");

var _airportConstants = require("../constants/airportConstants");

var _globalConstants = require("../constants/globalConstants");

var _environmentConstants = require("../constants/environmentConstants");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @property FLIGHT_RULES
 * @type {Object}
 * @final
 */
var FLIGHT_RULES = {
  VFR: 'vfr',
  IFR: 'ifr'
};
/**
 * Each simulated aircraft in the game. Contains a model, fms, and conflicts.
 *
 * @class AircraftModel
 */

var AircraftModel =
/*#__PURE__*/
function () {
  /**
   * @for AircraftModel
   * @constructor
   * @param options {object}
   */
  function AircraftModel() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AircraftModel);

    /**
     * Unique id
     *
     * Useful for debugging
     *
     * @for AircraftModel
     * @property id
     * @type {string}
     */
    this.id = (0, _uniqueId2["default"])('aircraft-');
    /**
     * Aircraft's DynamicPositionModel
     *
     * @for AircraftModel
     * @property positionModel
     * @type {DynamicPositionModel|null}
     */

    this.positionModel = null;
    /**
     * AircraftTypeDefinitionModel for the type of aircraft being flown
     *
     * @for AircraftModel
     * @property model
     * @type {AircraftTypeDefinitionModel|null}
     * @default null
     */

    this.model = null;
    /**
     * Airline Identifier (eg. 'AAL')
     *
     * @property airlineId
     * @type {string}
     * @default ''
     */

    this.airlineId = '';
    /**
     * Airline's radio callsign (eg. 'American')
     *
     * @for AircraftModel
     * @property airlineCallsign
     * @type {string}
     * @default ''
     */

    this.airlineCallsign = '';
    /**
     * Flight Number ONLY (eg. '551')
     *
     * @for AircraftModel
     * @property flightNumber
     * @type {string}
     * @default ''
     */

    this.flightNumber = '';
    /**
     * Trasponder code
     *
     * Initially generated and assined on instantiation by the `AircraftController`
     *
     * @for AircraftModel
     * @property transponderCode
     * @type {number}
     * @default 1200
     */

    this.transponderCode = 1200;
    /**
     * Pilot's voice
     *
     * Initially generated and assined on instantiation by the `AircraftController`
     *
     * @for AircraftModel
     * @property pilotVoice
     * @type {string}
     */

    this.pilotVoice = (0, _speech.randomizePilotVoice)();
    /**
     * Magnetic heading the aircraft is facing
     *
     * @for AircraftModel
     * @property heading
     * @type {number}
     * @default 0
     */

    this.heading = 0;
    /**
     * Altitude, ft MSL
     *
     * @for AircraftModel
     * @property altitude
     * @type {number}
     * @default 0
     */

    this.altitude = 0;
    /**
     * Indicated Airspeed (IAS), knots
     * Not to be confused with #trueAirspeed
     *
     * @property speed
     * @type {number}
     * @default 0
     */

    this.speed = 0;
    /**
     * Groundspeed (GS), knots
     *
     * @for AircraftModel
     * @property groundSpeed
     * @type {number}
     * @default 0
     */

    this.groundSpeed = 0;
    /**
     * Azimuth of movement across the ground, in radians
     *
     * @for AircraftModel
     * @property groundTrack
     * @type {number}
     * @default 0
     */

    this.groundTrack = 0;
    /**
     * Game time takeoff occurred
     *
     * @for AircraftModel
     * @property takeoffTime
     * @type {number}
     * @default 0
     */

    this.takeoffTime = 0;
    /**
     * True Airspeed, not to be confused with indicated airspeed (#speed)
     *
     * @for AircraftModel
     * @property trueAirspeed
     * @type {number}
     * @default 0
     */

    this.trueAirspeed = 0;
    /**
     * Azimuth from airport center to aircraft, in radians
     *
     * @for AircraftModel
     * @property radial
     * @type {number}
     * @default 0
     */

    this.radial = 0;
    /**
     * Distance from the airport, in km
     *
     * @for AircraftModel
     * @property distance
     * @type {number}
     * @default 0
     */

    this.distance = 0;
    /**
     * The origin ariport for an aircraft
     *
     * This will only be populated for dpearture aircraft
     *
     * @for AircraftModel
     * @property origin
     * @type {string}
     * @default ''
     */

    this.origin = '';
    /**
     * The destination airpot of an aircraft
     *
     * This will only be populated for arrivals
     *
     * @for AircraftModel
     * @property destination
     * @type {string}
     * @default ''
     */

    this.destination = '';
    /**
     * Indicator of descent/level/climb (-1, 0, or 1)
     *
     * @for AircraftModel
     * @property trend
     * @type {number}
     * @default 0
     */

    this.trend = 0;
    /**
     * Array of previous positions
     *
     * @for AircraftModel
     * @property history
     * @type <array<array<number>>>
     * @default []
     */

    this.history = [];
    /**
     * @for AircraftModel
     * @property restricted
     * @type {object}
     * @default { list: [] }
     */

    this.restricted = {
      list: []
    };
    /**
     * @for AircraftModel
     * @property warning
     * @type {boolean}
     * @default false
     */

    this.warning = false;
    /**
     * Whether aircraft has crashed
     *
     * @for AircraftModel
     * @property hit
     * @type {boolean}
     * @default false
     */

    this.hit = false;
    /**
     * Game time an aircraft starts the taxi
     *
     * @for AircraftModel
     * @property taxi_start
     * @type {number}
     * @default 0
     */

    this.taxi_start = 0;
    /**
     * Time spent taxiing to the runway. *NOTE* this should be INCREASED
     * to around 60 once the taxi vs LUAW issue is resolved (#406)
     *
     * @for AircraftModel
     * @property taxi_time
     * @type {number}
     * @default 3
     */

    this.taxi_time = 3;
    /**
     * Either IFR or VFR (Instrument/Visual Flight Rules)
     *
     * @for AircraftModel
     * @property rules
     * @type {FLIGHT_RULES}
     * @default FLIGHT_RULES.IFR
     */

    this.rules = FLIGHT_RULES.IFR;
    /**
     * Flag for if an aircraft is within controlled airspace, thus
     * making an aircraft _controllable_
     *
     * @for AircraftModel
     * @property isControllable
     * @type {boolean}
     * @default false
     */

    this.isControllable = false;
    /**
     * List of aircraft that MAY be in conflict (bounding box)
     *
     * @for AircraftModel
     * @property conflicts
     * @type {object}
     * @default {}
     */

    this.conflicts = {};
    /**
     * @for AircraftModel
     * @property terrain_ranges
     * @type {boolean}
     * @default false
     */

    this.terrain_ranges = false;
    /**
     * Flag used to determine if an aircraft is established on a holding pattern
     *
     * This is switched to true after the first turn of a holding pattern is made.
     * This allows for offset calculations to be performed on the legLength to
     * account for the time it takes to make a turn from one leg to the next
     * in a holding pattern.
     *
     * @for AircraftModel
     * @property _isEstablishedOnHoldingPattern
     * @type {boolean}
     * @default false
     * @private
     */

    this._isEstablishedOnHoldingPattern = false;
    /**
     * Flag used to determine if an aircraft can be removed from the sim.
     *
     * This tells the `AircraftController` that `AircraftStripView` associated with this
     * instance is safe to remove. This property should only be changed via the
     * `.setIsFlightStripRemovable()` method
     *
     * The `AircraftModel` will know when conditions are correct for the `StripView`
     * to be removed, however, only the `AircraftController` has access to an aircraft's
     * `StripView`.
     *
     * @for AircraftModel
     * @property isRemovable
     * @type {boolean}
     * @default false
     */

    this.isFlightStripRemovable = false;
    /**
     * Flag used to determine if an aircraft can be removed from the sim.
     *
     * This tells the `AircraftController` that this instance is safe to remove.
     * This property should only be changed via the `.setIsRemovable()` method.
     *
     * @for AircraftModel
     * @property isRemovable
     * @type {boolean}
     * @default false
     */

    this.isRemovable = false; // Set to true when simulating future movements of the aircraft
    // Should be checked before updating global state such as score
    // or HTML.

    this.projected = false;
    this.relativePositionHistory = [];
    this.category = options.category; // 'arrival' or 'departure'

    /**
     * the following diagram illustrates all allowed mode transitions:
     *
     * apron -> taxi -> waiting -> takeoff -> cruise <-> landing
     *   ^                                       ^
     *   |                                       |
     * new planes with                      new planes with
     * category 'departure'                 category 'arrival'
     */
    // target represents what the pilot makes of the tower's commands. It is
    // most important when the plane is in a 'guided' situation, that is it is
    // not given a heading directly, but has a fix or is following an ILS path

    this.target = {
      altitude: 0,
      heading: null,
      turn: null,
      speed: 0
    }; // TODO: Move all target properties here in order to utilize getters/setters
    // this._targetAltitude = 0;
    // this._targetAltitudeExpedite = false;

    this._targetHeading = null;
    this._targetGroundTrack = null; // this._targetTurnDirection = null;
    // this._targetIndicatedAirspeed = 0;

    /**
     * @for AircraftModel
     * @property model
     * @type {AircraftTypeDefinitionModel}
     */

    this.model = new _AircraftTypeDefinitionModel["default"](options.model);
    /**
     * @for AircraftModel
     * @property mcp
     * @type {ModeController}
     */

    this.mcp = new _ModeController["default"]();
    /**
     * @for AircraftModel
     * @property fms
     * @type {Fms}
     */

    this.fms = new _Fms["default"](options);
    /**
     * @for AircraftModel
     * @property pilot
     * @type {Pilot}
     */

    this.pilot = new _Pilot["default"](this.fms, this.mcp);
    this.takeoffTime = options.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL ? _TimeKeeper["default"].accumulatedDeltaTime : null;
    this.buildCurrentTerrainRanges();
    this.buildRestrictedAreaLinks();
    this.parse(options);

    var airport = _AirportController["default"].airport_get(); // const initialRunway = airport.getActiveRunwayForCategory(this.category);


    if (this.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
      this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.APRON);
      this.altitude = airport.positionModel.elevation;
      this.speed = 0;
    } else if (this.category !== _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL && this.category !== _aircraftConstants.FLIGHT_CATEGORY.OVERFLIGHT) {
      throw new Error('Invalid #category found in AircraftModel');
    }

    if (this.category !== _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
      var bottomAltitude = this.fms.getBottomAltitude();

      var airportModel = _AirportController["default"].airport_get();

      var airspaceCeiling = airportModel.maxAssignableAltitude;
      this.mcp.initializeForAirborneFlight(bottomAltitude, airspaceCeiling, this.altitude, this.heading, this.speed);
    }
  }
  /**
   * The magnetic heading to target while applying NO correction for the wind, in radians
   * NOTE: This will not be the heading the aircraft moves along-- the wind will blow it off
   *       course. For that heading, use #targetGroundTrack instead.
   *
   * @for AircraftModel
   * @property targetHeading
   * @type {number} heading, in radians magnetic
   */


  _createClass(AircraftModel, [{
    key: "buildCurrentTerrainRanges",
    // TODO: this feels like it belongs in either the AirportModel or the AirspaceModel which then exposes a
    // method that will check collisions

    /**
     * @for AircraftModel
     * @method buildCurrentTerrainRanges
     */
    value: function buildCurrentTerrainRanges() {
      var _this = this;

      var terrain = (0, _get2["default"])(prop, 'airport.current.terrain', null);

      if (!terrain) {
        return;
      }

      this.terrain_ranges = {};
      this.terrain_level = 0;
      (0, _forEach2["default"])(terrain, function (terrainRange, k) {
        _this.terrain_ranges[k] = {};
        (0, _forEach2["default"])(terrainRange, function (range, j) {
          _this.terrain_ranges[k][j] = Infinity;
        });
      });
    }
    /**
     * Set up links to restricted areas
     *
     * @for AircraftModel
     * @method buildRestrictedAreaLinks
     */

  }, {
    key: "buildRestrictedAreaLinks",
    value: function buildRestrictedAreaLinks() {
      var _this2 = this;

      var restrictedAreas = _AirportController["default"].current.restricted_areas;
      (0, _forEach2["default"])(restrictedAreas, function (area) {
        _this2.restricted.list.push({
          data: area,
          range: null,
          inside: false
        });
      });
    }
  }, {
    key: "parse",
    value: function parse(data) {
      this.positionModel = data.positionModel;
      this.transponderCode = data.transponderCode;
      this.airlineId = data.airline;
      this.airlineCallsign = data.airlineCallsign;
      this.flightNumber = data.callsign;
      this.category = data.category;
      this.heading = data.heading;
      this.altitude = data.altitude;
      this.speed = data.speed;
      this.origin = (0, _get2["default"])(data, 'origin', this.origin);
      this.destination = (0, _get2["default"])(data, 'destination', this.destination);
      this.target.altitude = this.altitude;
      this.targetHeading = this.heading;
      this.target.speed = this.speed; // This assumes and arrival spawns outside the airspace

      this.isControllable = data.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE;
    }
    /**
     * Build an object that contains all the correct data, in the correct shape,
     * so it can be injected into the view.
     *
     * This method should only be used by the `StripView` classes when instantiating
     * or updating the aircraft progress strips.
     *
     * The data here should be considered read-only.
     *
     * @for AircraftModel
     * @method getViewModel
     * @return {object<string, string>}
     */

  }, {
    key: "getViewModel",
    value: function getViewModel() {
      var assignedAltitude = '-';
      var flightPlanAltitude = '-';

      if (this.mcp.altitude !== _globalConstants.INVALID_NUMBER) {
        assignedAltitude = Math.round(this.mcp.altitude) * _unitConverters.UNIT_CONVERSION_CONSTANTS.FT_FL;
      }

      if (this.fms.flightPlanAltitude !== _globalConstants.INVALID_NUMBER) {
        flightPlanAltitude = this.fms.flightPlanAltitude * _unitConverters.UNIT_CONVERSION_CONSTANTS.FT_FL;
      }

      return {
        id: this.id,
        insideCenter: this.isControllable,
        callsign: this.callsign,
        transponderCode: this.transponderCode,
        icaoWithWeightClass: this.model.icaoWithWeightClass,
        assignedAltitude: assignedAltitude,
        flightPlanAltitude: flightPlanAltitude,
        arrivalAirportId: this.destination.toUpperCase(),
        departureAirportId: this.origin.toUpperCase(),
        flightPlan: this.fms.getFullRouteStringWithoutAirportsWithSpaces()
      };
    }
    /**
     * Returns a true value if there is a match from the callsignToMatch
     *
     * @for AircraftModel
    * @method matchCallsign
    * @param callsign {string}
     */

  }, {
    key: "matchCallsign",
    value: function matchCallsign(callsignToMatch) {
      var shouldMatchAnyCallsign = callsignToMatch === '*'; // checks to see if the given call sign matches the airline Id + callsign format

      if (shouldMatchAnyCallsign || this.airlineId.toUpperCase() + callsignToMatch.toUpperCase() === this.callsign) {
        return true;
      } // Checks to see if the given callsign matches only the callsign since callsign numbers should be unique


      return (0, _isEqual2["default"])(callsignToMatch.toUpperCase(), this.callsign);
    }
    /**
     * verifies if there is a matched callsign and if the  aircraft is visable.
     * @for AircraftModel
     * @method getCallsign
     * @return {string}
     */

  }, {
    key: "getCallsign",
    value: function getCallsign() {
      return this.callsign.toUpperCase();
    }
    /**
     * @for AircraftModel
     * @method getRadioCallsign
     * @return cs {string}
     */

  }, {
    key: "getRadioCallsign",
    value: function getRadioCallsign() {
      var weight = this.model.getRadioWeightClass();

      if (!(0, _isEmpty2["default"])(weight)) {
        weight = " ".concat(weight);
      }

      if (this.airlineCallsign === 'November') {
        return "".concat(this.airlineCallsign, " ").concat((0, _radioUtilities.radio_spellOut)(this.flightNumber)).concat(weight);
      }

      return "".concat(this.airlineCallsign, " ").concat((0, _radioUtilities.groupNumbers)(this.flightNumber)).concat(weight);
    } // TODO: this method should move to the `AircraftTypeDefinitionModel`

    /**
     * @for AircraftModel
     * @method getClimbRate
     * @return {number}
     */

  }, {
    key: "getClimbRate",
    value: function getClimbRate() {
      var serviceCeilingClimbRate;
      var cr_uncorr;
      var cr_current;
      var altitude = this.altitude;
      var rate = this.model.rate.climb;
      var ceiling = this.model.ceiling;

      if (this.model.engines.type === 'J') {
        serviceCeilingClimbRate = 500;
      } else {
        serviceCeilingClimbRate = 100;
      } // TODO: enumerate the magic number
      // in troposphere


      if (this.altitude < 36152) {
        // TODO: break this assignemnt up into smaller parts and holy magic numbers! enumerate the magic numbers
        cr_uncorr = rate * 420.7 * (1.232 * Math.pow((518.6 - 0.00356 * altitude) / 518.6, 5.256) / (518.6 - 0.00356 * altitude));
        cr_current = cr_uncorr - altitude / ceiling * cr_uncorr + altitude / ceiling * serviceCeilingClimbRate;
      } else {
        // in lower stratosphere
        // re-do for lower stratosphere
        // Reference: https://www.grc.nasa.gov/www/k-12/rocket/atmos.html
        // also recommend using graphing calc from desmos.com
        return this.model.rate.climb; // <-- NOT VALID! Just a placeholder!
      }

      return cr_current;
    }
    /**
     * @for AircraftModel
     * @method cancelFix
     */

  }, {
    key: "cancelFix",
    value: function cancelFix() {
      this.fms.cancelFix();
    }
    /**
     * Abort the landing attempt, and fly present heading, climbing to the minimum safe altitude
     *
     * @for AircraftModel
     * @method cancelLanding
     */

  }, {
    key: "cancelLanding",
    value: function cancelLanding() {
      if (this.projected) {
        return;
      }

      var missedApproachAltitude = (0, _ceil2["default"])(this.fms.arrivalRunwayModel.elevation + 2000, -3);
      var nextIfrAltitudeBelow = (0, _floor2["default"])(this.altitude, -3);
      var nextAltitudeToMaintain = missedApproachAltitude;
      var radioMessage = "going missed approach, present heading, climbing to ".concat(missedApproachAltitude);

      if (nextIfrAltitudeBelow >= missedApproachAltitude) {
        nextAltitudeToMaintain = nextIfrAltitudeBelow;
        radioMessage = "going missed approach, present heading, leveling at ".concat(nextIfrAltitudeBelow);
      }

      this.pilot.hasApproachClearance = false;
      this.mcp.setAltitudeFieldValue(nextAltitudeToMaintain);
      this.mcp.setAltitudeHold();
      this.mcp.setHeadingFieldValue(this.heading);
      this.mcp.setHeadingHold();
      this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.DESCENT);
      this.radioCall(radioMessage, _airportConstants.AIRPORT_CONTROL_POSITION_NAME.APPROACH, true);
    }
    /**
     * Return whether the aircraft is off the ground
     *
     * @for AircraftModel
     * @method isAirborne
     * @return {boolean}
     */

  }, {
    key: "isAirborne",
    value: function isAirborne() {
      return !this.isOnGround();
    }
    /**
     * Returns whether it is time to begin deceleration in order to comply with the posted speed restrictions
     *
     * @for AircraftModel
     * @method isBeyondDecelerationPointForWaypointModel
     * @param waypointModel {WaypointModel} the waypoint with a speed restriction
     * @return {boolean}
     */

  }, {
    key: "isBeyondDecelerationPointForWaypointModel",
    value: function isBeyondDecelerationPointForWaypointModel(waypointModel) {
      if ((0, _isNil2["default"])(waypointModel)) {
        return false;
      }

      var waypointSpeed = waypointModel.speedMaximum;
      var waypointDistance = this.positionModel.distanceToPosition(waypointModel.positionModel);
      var speedChange = waypointSpeed - this.speed;
      var decelerationRate = -this.model.rate.decelerate / 2; // units of rate.decel are 'knots per 2 seconds'

      var decelerationTime = speedChange / decelerationRate;
      var timeUntilWaypoint = waypointDistance / this.groundSpeed * _globalConstants.TIME.ONE_HOUR_IN_SECONDS;
      return decelerationTime > timeUntilWaypoint;
    }
    /**
     * Returns whether it is time to begin descent in order to comply with the posted altitude restrictions
     *
     * @for AircraftModel
     * @method isBeyondTopOfDescentForWaypointModel
     * @param waypointModel {WaypointModel} the waypoint at which to comply with the restriction
     * @param targetAltitude {number} the altitude to comnply with
     * @return {boolean}
     */

  }, {
    key: "isBeyondTopOfDescentForWaypointModel",
    value: function isBeyondTopOfDescentForWaypointModel(waypointModel, targetAltitude) {
      var targetPosition = waypointModel.positionModel;
      var waypointDistance = this.positionModel.distanceToPosition(targetPosition);
      var altitudeChange = targetAltitude - this.altitude;
      var descentRate = -this.model.rate.descent * _aircraftConstants.PERFORMANCE.TYPICAL_DESCENT_FACTOR;
      var descentTime = altitudeChange / descentRate;
      var timeUntilWaypoint = waypointDistance / this.groundSpeed * _globalConstants.TIME.ONE_HOUR_IN_MINUTES;
      return descentTime > timeUntilWaypoint;
    }
    /**
     * Returns whether the aircraft is an arrival
     *
     * @for AircraftModel
     * @method isArrival
     * @returns {boolean}
     */

  }, {
    key: "isArrival",
    value: function isArrival() {
      return this.fms.isArrival();
    }
    /**
     * Returns whether the aircraft is a departure
     *
     * @for AircraftModel
     * @method isDeparture
     * @returns {booelan}
     */

  }, {
    key: "isDeparture",
    value: function isDeparture() {
      return this.fms.isDeparture();
    }
    /**
     * Returns whether or not this aircraft is an overflight (neither departing or arriving within our airspace)
     *
     * @for AircraftModel
     * @method isArrival
     * @returns booelan
     */

  }, {
    key: "isOverflight",
    value: function isOverflight() {
      return this.origin === '' && this.destination === '';
    }
    /**
     * Returns whether aircraft is above the glidepath at (or abeam) their current position
     *
     * Note that a small allowance is applied here to still be considered "on or below"
     *
     * @for AircraftModel
     * @method isAboveGlidepath
     * @return {boolean}
     */

  }, {
    key: "isAboveGlidepath",
    value: function isAboveGlidepath() {
      var glideslopeAltitude = this._calculateArrivalRunwayModelGlideslopeAltitude();

      var altitudeDifference = glideslopeAltitude - this.altitude;
      return altitudeDifference < -_aircraftConstants.PERFORMANCE.MAXIMUM_ALTITUDE_DIFFERENCE_CONSIDERED_ESTABLISHED_ON_GLIDEPATH;
    }
    /**
     * Aircraft is established on the course tuned into the nav radio and course
     *
     * @for AircraftModel
     * @method isEstablishedOnCourse
     * @return {boolean}
     */

  }, {
    key: "isEstablishedOnCourse",
    value: function isEstablishedOnCourse() {
      var runwayModel = this.fms.arrivalRunwayModel;

      if (!runwayModel) {
        return false;
      } // TODO: the `this` here is ugly, but will be needed until `getOffset`
      // is refactored (#291 - https://github.com/openscope/openscope/issues/291)
      // TODO: The methods called here should be moved to the AircraftModel,
      // so that it can also be used for non-runway course interception


      return runwayModel.isOnApproachCourse(this) && runwayModel.isOnCorrectApproachGroundTrack(this.groundTrack); // TODO: Use this instead
      // const courseDatum = this.mcp.nav1Datum;
      // const course = this.mcp.course;
      // const courseOffset = getOffset(this, courseDatum.relativePosition, course);
      // const lateralDistanceFromCourse_nm = abs(nm(courseOffset[0]));
      // const allowableLateralDistanceFromCourse = PERFORMANCE.MAXIMUM_DISTANCE_CONSIDERED_ESTABLISHED_ON_APPROACH_COURSE_NM;
      // const isAlignedWithCourse = lateralDistanceFromCourse_nm <= allowableLateralDistanceFromCourse;
      // const heading_diff = abs(angle_offset(this.heading, course));
      // const isOnCourseHeading = heading_diff < PERFORMANCE.MAXIMUM_ANGLE_CONSIDERED_ESTABLISHED_ON_APPROACH_COURSE;
      //
      // return isAlignedWithCourse && isOnCourseHeading;
    }
    /**
     * Aircraft is established on the glidepath
     *
     * Note that this is currently only usable for runway glideslopes, but should eventually
     * be elaborated upon to support other types of glidepaths (such as those from FMS VNAV)
     *
     * @for AircraftModel
     * @method isEstablishedOnCourse
     * @return {boolean}
     */

  }, {
    key: "isEstablishedOnGlidepath",
    value: function isEstablishedOnGlidepath() {
      var glideslopeAltitude = this._calculateArrivalRunwayModelGlideslopeAltitude();

      var glideslopeAltitudeDifference = (0, _core.abs)(glideslopeAltitude - this.altitude);
      return glideslopeAltitudeDifference <= _aircraftConstants.PERFORMANCE.MAXIMUM_ALTITUDE_DIFFERENCE_CONSIDERED_ESTABLISHED_ON_GLIDEPATH;
    }
    /**
     * Checks if the aircraft is inside the airspace of a specified airport
     *
     * @for AircraftModel
     * @method isInsideAirspace
     * @param  {AirportModel} airport the airport whose airspace we are checking
     * @return {boolean}
     */

  }, {
    key: "isInsideAirspace",
    value: function isInsideAirspace(airport) {
      return airport.isPointWithinAirspace(this.relativePosition, this.altitude);
    }
    /**
     * Returns whether the aircraft is on the approach course and within the final approach fix
     *
     * @for AircraftModel
     * @method isOnFinal
     * @return {boolean}
     */

  }, {
    key: "isOnFinal",
    value: function isOnFinal() {
      if (!this.isEstablishedOnCourse()) {
        return false;
      }

      var approachDistanceNm = this.positionModel.distanceToPosition(this.mcp.nav1Datum);
      var maxDistanceConsideredOnFinalNm = _airportConstants.AIRPORT_CONSTANTS.FINAL_APPROACH_FIX_DISTANCE_NM;
      return approachDistanceNm <= maxDistanceConsideredOnFinalNm;
    }
    /**
     * Aircraft has "weight-on-wheels" (on the ground)
     *
     * @for AircraftModel
     * @method isOnGround
     * @return {boolean}
     */

  }, {
    key: "isOnGround",
    value: function isOnGround() {
      var airportModel = this.fms.departureAirportModel;
      var runwayModel = this.fms.departureRunwayModel;

      if (this.isOverflight()) {
        return false;
      }

      if (this.isArrival()) {
        airportModel = this.fms.arrivalAirportModel;
        runwayModel = this.fms.arrivalRunwayModel;
      }

      var errorAllowanceInFeet = 5;
      var isAtOrBelowRunwayAltitude = this.altitude - runwayModel.elevation < errorAllowanceInFeet;
      var isAtOrBelowAirportAltitude = this.altitude - airportModel.elevation < errorAllowanceInFeet;
      return isAtOrBelowRunwayAltitude || isAtOrBelowAirportAltitude;
    }
    /**
     * Aircraft is on the apron
     *
     * @for AircraftModel
     * @method isApron
     * @return {boolean}
     */

  }, {
    key: "isApron",
    value: function isApron() {
      return this.flightPhase === _aircraftConstants.FLIGHT_PHASE.APRON;
    }
    /**
     * @for AircraftModel
     * @method isStopped
     */

  }, {
    key: "isStopped",
    value: function isStopped() {
      // TODO: enumerate the magic number.
      return this.isOnGround() && this.speed < 5;
    }
    /**
     * Return whether the aircraft is in flight AND below its stall speed
     *
     * @for AircraftModel
     * @method isStalling
     * @return {boolean}
     */

  }, {
    key: "isStalling",
    value: function isStalling() {
      var isStalling = this.speed < this.model.speed.min && this.isAirborne();
      return isStalling;
    }
    /**
     * @for AircraftModel
     * @method isTaxiing
     */

  }, {
    key: "isTaxiing",
    value: function isTaxiing() {
      return this.flightPhase === _aircraftConstants.FLIGHT_PHASE.APRON || this.flightPhase === _aircraftConstants.FLIGHT_PHASE.TAXI || this.flightPhase === _aircraftConstants.FLIGHT_PHASE.WAITING;
    } // TODO: The function description and what it actually does do not match

    /**
     * Returns whether the aircraft is currently taking off
     *
     * @for AircraftModel
     * @method isTakeoff
     */

  }, {
    key: "isTakeoff",
    value: function isTakeoff() {
      return this.isTaxiing() || this.flightPhase === _aircraftConstants.FLIGHT_PHASE.TAKEOFF;
    }
    /**
     * @for AircraftModel
     * @method isVisible
     * @return {boolean}
     */

  }, {
    key: "isVisible",
    value: function isVisible() {
      // hide aircraft on taxiways
      if (this.flightPhase === _aircraftConstants.FLIGHT_PHASE.APRON || this.flightPhase === _aircraftConstants.FLIGHT_PHASE.TAXI) {
        return false;
      }

      if (this.flightPhase === _aircraftConstants.FLIGHT_PHASE.WAITING) {
        // show only the first aircraft in the takeoff queue
        return this.fms.departureRunwayModel.isAircraftNextInQueue(this.id);
      }

      return true;
    }
    /**
     * Sets `#isFlightStripRemovable` to true
     *
     * Provides a single source of change for the value of `#isFlightStripRemovable`
     *
     * @for AircraftModel
     * @method isFlightStripRemovable
     */

  }, {
    key: "setIsFlightStripRemovable",
    value: function setIsFlightStripRemovable() {
      this.isFlightStripRemovable = true;
    }
    /**
     * Sets `#isRemovable` to true
     *
     * Provides a single source of change for the value of `#isRemovable`
     * This is evaluated by the `AircraftController` when determining
     * if an aircraft should be removed or not
     *
     * @for AircraftModel
     * @method setIsRemovable
     */

  }, {
    key: "setIsRemovable",
    value: function setIsRemovable() {
      this.isRemovable = true;
    }
    /**
      * @for AircraftModel
      * @method getWindComponents
      * @return {object} headwind and crosswind
      */

  }, {
    key: "getWindComponents",
    value: function getWindComponents() {
      var _AirportController$ai = _AirportController["default"].airport_get(),
          wind = _AirportController$ai.wind;

      var crosswindAngle = (0, _flightMath.calculateCrosswindAngle)(this.heading, wind.angle);
      return {
        cross: (0, _core.sin)(crosswindAngle) * wind.speed,
        head: (0, _core.cos)(crosswindAngle) * wind.speed
      };
    }
    /**
     * Reposition the aircraft to the location of the specified runway
     *
     * @for AircraftModel
     * @method moveToRunway
     * @param runwayModel {RunwayModel}
     */

  }, {
    key: "moveToRunway",
    value: function moveToRunway(runwayModel) {
      this.positionModel.setCoordinates(runwayModel.gps);
      this.heading = runwayModel.angle;
      this.altitude = runwayModel.elevation;
    }
    /**
     * @for AircraftModel
     * @method radioCall
     * @param msg {string}
     * @param sectorType {string}
     * @param alert {string}
     */

  }, {
    key: "radioCall",
    value: function radioCall(msg, sectorType, alert) {
      if (this.projected) {
        return;
      }

      var writtenCallsign = this.callsign;
      var spokenCallsign = this.getRadioCallsign(); // let call = '';
      //
      // if (sectorType) {
      //     call += AirportController.airport_get().radio[sectorType];
      // }
      //
      // call += ", " + this.callsign + " " + msg;
      // TODO: quick abstraction, this doesn't belong here.

      var logMessage = function logMessage(callsign) {
        return "".concat(_AirportController["default"].airport_get().radio[sectorType], ", ").concat(callsign, " ").concat(msg);
      };

      if (alert) {
        var isWarning = true;

        _UiController["default"].ui_log(logMessage(writtenCallsign), isWarning);
      } else {
        _UiController["default"].ui_log(logMessage(writtenCallsign));
      }

      (0, _speech.speech_say)([{
        type: 'text',
        content: logMessage(spokenCallsign)
      }], this.pilotVoice);
    }
    /**
     * @for AircraftModel
     * @method callUp
     */

  }, {
    key: "callUp",
    value: function callUp() {
      var alt_log;
      var alt_say;

      if (this.isArrival()) {
        var altdiff = this.altitude - this.mcp.altitude;
        var alt = (0, _radioUtilities.digits_decimal)(this.altitude, -2);

        if (Math.abs(altdiff) > 200) {
          if (altdiff > 0) {
            alt_log = "descending through ".concat(alt, " for ").concat(this.mcp.altitude);
            alt_say = "descending through ".concat((0, _radioUtilities.radio_altitude)(alt), " for ").concat((0, _radioUtilities.radio_altitude)(this.mcp.altitude));
          } else if (altdiff < 0) {
            alt_log = "climbing through ".concat(alt, " for ").concat(this.mcp.altitude);
            alt_say = "climbing through ".concat((0, _radioUtilities.radio_altitude)(alt), " for ").concat((0, _radioUtilities.radio_altitude)(this.mcp.altitude));
          }
        } else {
          alt_log = "at ".concat(alt);
          alt_say = "at ".concat((0, _radioUtilities.radio_altitude)(alt));
        }

        _UiController["default"].ui_log("".concat(_AirportController["default"].airport_get().radio.app, ", ").concat(this.callsign, " with you ").concat(alt_log));

        (0, _speech.speech_say)([{
          type: 'text',
          content: "".concat(_AirportController["default"].airport_get().radio.app, ", ")
        }, {
          type: 'callsign',
          content: this
        }, {
          type: 'text',
          content: "with you ".concat(alt_say)
        }], this.pilotVoice);
      }

      if (this.isDeparture()) {
        _UiController["default"].ui_log("".concat(_AirportController["default"].airport_get().radio.twr, ", ").concat(this.callsign, ", ready to taxi"));

        (0, _speech.speech_say)([{
          type: 'text',
          content: _AirportController["default"].airport_get().radio.twr
        }, {
          type: 'callsign',
          content: this
        }, {
          type: 'text',
          content: ', ready to taxi'
        }], this.pilotVoice);
      }
    }
    /**
     * @for AircraftModel
     * @method taxiToRunway
     * @param runwayModel {RunwayModel}
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "taxiToRunway",
    value: function taxiToRunway(runwayModel) {
      if (this.isAirborne()) {
        return [false, 'unable to taxi, we\'re already airborne'];
      }

      if (this.flightPhase === _aircraftConstants.FLIGHT_PHASE.TAKEOFF) {
        return [false, 'unable to taxi, we\'re already taking off'];
      }

      if (this.isArrival()) {
        return [false, 'unable to taxi to runway, we have just landed'];
      }

      this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.TAXI); // remove aircraft from previous runway's queue

      this.fms.departureRunwayModel.removeAircraftFromQueue(this.id);
      this.fms.setDepartureRunway(runwayModel);
      this.fms.departureRunwayModel.addAircraftToQueue(this.id);
      this.taxi_start = _TimeKeeper["default"].accumulatedDeltaTime;

      _GameController["default"].game_timeout(this._changeFromTaxiToWaiting, this.taxi_time, this, null);

      var readback = {};
      readback.log = "taxi to and hold short of Runway ".concat(runwayModel.name);
      readback.say = "taxi to and hold short of Runway ".concat((0, _radioUtilities.radio_runway)(runwayModel.name));
      return [true, readback];
    }
    /**
     * @for AircraftModel
     * @method _changeFromTaxiToWaiting
     */

  }, {
    key: "_changeFromTaxiToWaiting",
    value: function _changeFromTaxiToWaiting() {
      this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.WAITING);
    }
    /**
     * Initialize all autopilot systems after being given an IFR clearance to destination and execute takeoff.
     *
     * @for AircraftModel
     * @method takeoff
     * @param runway {RunwayModel} the runway taking off on
     */

  }, {
    key: "takeoff",
    value: function takeoff(runway) {
      var cruiseSpeed = this.model.speed.cruise;
      var initialAltitude = this.fms.getInitialClimbClearance();

      this._prepareMcpForTakeoff(initialAltitude, runway.angle, cruiseSpeed);

      this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.TAKEOFF);

      _EventBus["default"].trigger(_eventNames.AIRCRAFT_EVENT.TAKEOFF, this, runway);

      this.takeoffTime = _TimeKeeper["default"].accumulatedDeltaTime;
      runway.lastDepartedAircraftCallsign = this.callsign;
    }
    /**
     * Initialize all autopilot systems for takeoff.
     *
     * @for AircraftModel
     * @method _prepareMcpForTakeoff
     * @param altitude {number}
     * @param heading {number}
     * @param speed {number}
     */

  }, {
    key: "_prepareMcpForTakeoff",
    value: function _prepareMcpForTakeoff(altitude, heading, speed) {
      if (this.mcp.altitude === _globalConstants.INVALID_NUMBER) {
        this.mcp.setAltitudeFieldValue(altitude);
      }

      if (this.mcp.altitudeMode === _modeControlConstants.MCP_MODE.ALTITUDE.OFF) {
        this.mcp.setAltitudeHold();
      }

      if (this.mcp.heading === _globalConstants.INVALID_NUMBER) {
        this.mcp.setHeadingFieldValue(heading);
      }

      if (this.mcp.headingMode === _modeControlConstants.MCP_MODE.HEADING.OFF) {
        this.mcp.setHeadingLnav();
      }

      if (this.mcp.speed === _globalConstants.INVALID_NUMBER) {
        this.mcp.setSpeedFieldValue(speed);
      }

      if (this.mcp.speedMode === _modeControlConstants.MCP_MODE.SPEED.OFF) {
        this.mcp.setSpeedN1();
      }
    }
    /**
     * Update the aircraft's targeted telemetry (altitude, heading, and speed)
     *
     * @for AircraftModel
     * @method updateTarget
     */

  }, {
    key: "updateTarget",
    value: function updateTarget() {
      this.target.altitude = (0, _defaultTo2["default"])(this._calculateTargetedAltitude(), this.target.altitude);

      this._updateTargetedDirectionality();

      this.target.speed = (0, _defaultTo2["default"])(this._calculateTargetedSpeed(), this.target.speed); // TODO: this method may not be needed but could be leveraged for housekeeping if deemed appropriate

      this.overrideTarget();
    }
    /**
     * @for AircraftModel
     * @method overrideTarget
     */

  }, {
    key: "overrideTarget",
    value: function overrideTarget() {
      switch (this.flightPhase) {
        case _aircraftConstants.FLIGHT_PHASE.APRON:
          // TODO: Is this needed?
          // this.target.altitude = this.altitude;
          // this.targetHeading = this.heading;
          // this.target.speed = 0;
          break;

        case _aircraftConstants.FLIGHT_PHASE.TAXI:
          // TODO: Is this needed?
          // this.target.altitude = this.altitude;
          // this.targetHeading = this.heading;
          // this.target.speed = 0;
          break;

        case _aircraftConstants.FLIGHT_PHASE.WAITING:
          // TODO: Is this needed?
          // this.target.altitude = this.altitude;
          // this.targetHeading = this.heading;
          // this.target.speed = 0;
          break;

        case _aircraftConstants.FLIGHT_PHASE.TAKEOFF:
          {
            this.target.altitude = this.altitude;

            if (this.speed >= this.model.speed.min) {
              this.target.altitude = this.model.ceiling;
            }

            this.targetHeading = this.heading;
            this.target.speed = this.model.speed.min;

            if (this.mcp.heading === _globalConstants.INVALID_NUMBER) {
              console.warn("".concat(this.callsign, " took off with no directional instructions!"));
            }

            break;
          }

        case _aircraftConstants.FLIGHT_PHASE.CLIMB:
          break;

        case _aircraftConstants.FLIGHT_PHASE.CRUISE:
          break;

        case _aircraftConstants.FLIGHT_PHASE.DESCENT:
          break;

        case _aircraftConstants.FLIGHT_PHASE.APPROACH:
          break;

        case _aircraftConstants.FLIGHT_PHASE.LANDING:
          {
            if (this.altitude <= this.mcp.nav1Datum.elevation) {
              this.altitude = this.mcp.nav1Datum.elevation;
              this.target.speed = 0;
            }

            break;
          }

        default:
          break;
      } // If stalling, make like a meteorite and fall to the earth!


      if (this.isStalling()) {
        this.target.altitude = Math.min(0, this.target.altitude);
      } // Limit speed to 250 knots while under 10,000 feet MSL (it's the law!)
      // TODO: Isn't this covered by `this._calculateLegalSpeed()`?


      if (this.altitude < 10000) {
        this.target.speed = Math.min(this.target.speed, _airportConstants.AIRPORT_CONSTANTS.MAX_SPEED_BELOW_10K_FEET);
      }

      if (this.target.altitude > this.model.ceiling) {
        this.target.altitude = this.model.ceiling;
      }

      if (this.target.speed > this.model.speed.max) {
        this.target.speed = this.model.speed.max;
      }

      if (this.target.speed < this.model.speed.min && this.isAirborne()) {
        this.target.speed = this.model.speed.min;
      }
    }
    /**
     * Fascade to set the fms's flight phase
     *
     * @for AircraftModel
     * @method setFlightPhase
     * @param phase {string}
     */

  }, {
    key: "setFlightPhase",
    value: function setFlightPhase(phase) {
      this.fms.setFlightPhase(phase);
    }
    /**
     * Update the FMS's flight phase
     *
     * @for AircraftModel
     * @method updateFlightPhase
     */

  }, {
    key: "updateFlightPhase",
    value: function updateFlightPhase() {
      var runwayModel = this.fms.departureRunwayModel;

      switch (this.flightPhase) {
        case _aircraftConstants.FLIGHT_PHASE.TAXI:
          {
            var elapsed = _TimeKeeper["default"].accumulatedDeltaTime - this.taxi_start;

            if (elapsed > this.taxi_time) {
              this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.WAITING);
              this.moveToRunway(runwayModel);
            }

            break;
          }

        case _aircraftConstants.FLIGHT_PHASE.WAITING:
          break;

        case _aircraftConstants.FLIGHT_PHASE.TAKEOFF:
          if (this.altitude - runwayModel.elevation > _aircraftConstants.PERFORMANCE.TAKEOFF_TURN_ALTITUDE) {
            this.pilot.raiseLandingGearAndActivateAutopilot();
            this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.CLIMB);
          }

          break;

        case _aircraftConstants.FLIGHT_PHASE.CLIMB:
          if (this.altitude === this.fms.flightPlanAltitude) {
            this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.CRUISE);
          }

          break;

        case _aircraftConstants.FLIGHT_PHASE.CRUISE:
          if (this.altitude < this.fms.flightPlanAltitude) {
            this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.DESCENT);
          }

          break;

        case _aircraftConstants.FLIGHT_PHASE.DESCENT:
          if (this.pilot.hasApproachClearance && this.isEstablishedOnCourse()) {
            this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.APPROACH);

            if (!this.projected) {
              _EventBus["default"].trigger(_eventNames.AIRCRAFT_EVENT.APPROACH, this);
            }
          }

          break;

        case _aircraftConstants.FLIGHT_PHASE.APPROACH:
          {
            if (!this.isOnFinal()) {
              break;
            }

            if (!this.isEstablishedOnGlidepath()) {
              this.cancelLanding();
              break;
            }

            this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.LANDING);

            if (!this.projected) {
              _EventBus["default"].trigger(_eventNames.AIRCRAFT_EVENT.FINAL_APPROACH, this, this.fms.arrivalRunwayModel);
            }

            break;
          }

        case _aircraftConstants.FLIGHT_PHASE.LANDING:
          break;

        default:
          break;
      }
    }
    /**
     * Calculate the glideslope altitude abeam the current position for the expected landing runway
     *
     * @for AircraftModel
     * @method _calculateArrivalRunwayModelGlideslopeAltitude
     * @private
     */

  }, {
    key: "_calculateArrivalRunwayModelGlideslopeAltitude",
    value: function _calculateArrivalRunwayModelGlideslopeAltitude() {
      var runwayModel = this.fms.arrivalRunwayModel;
      var offset = (0, _flightMath.getOffset)(this, runwayModel.relativePosition, runwayModel.angle);
      var distanceOnFinalKm = offset[1];
      var glideslopeAltitude = runwayModel.getGlideslopeAltitude(distanceOnFinalKm);
      return glideslopeAltitude;
    }
    /**
     * Calculate the heading needed in order for the aircraft to move along a specified angle across the ground
     * https://www.cliffsnotes.com/study-guides/trigonometry/vectors/vector-operations (see example 2)
     *
     * @for AircraftModel
     * @method _calculateCrabHeadingForGroundTrack
     * @param {number} groundTrackHeading
     * @returns {number} magnetic heading, in radians
     * @private
     */

  }, {
    key: "_calculateCrabHeadingForGroundTrack",
    value: function _calculateCrabHeadingForGroundTrack(groundTrackHeading) {
      var windVector = _AirportController["default"].airport_get().getWindVectorAtAltitude(this.altitude);

      var windAngle = (0, _vector.vradial)(windVector);
      var angleDifference = groundTrackHeading - windAngle;
      var crabAngle = Math.asin((0, _vector.vlen)(windVector) * (0, _core.sin)(angleDifference) / this.trueAirspeed);
      return groundTrackHeading + crabAngle;
    }
    /**
     * Calculate the angle across the ground which results from the aircraft's heading and the wind
     *
     * @for AircraftModel
     * @method _calculateGroundTrackForHeading
     * @param {number} heading
     * @returns {number} magnetic heading, in radians
     * @priate
     */

  }, {
    key: "_calculateGroundTrackForHeading",
    value: function _calculateGroundTrackForHeading(heading) {
      var headingVector = (0, _vector.vscale)((0, _vector.vectorize2dFromRadians)(heading), this.trueAirspeed);

      var windVector = _AirportController["default"].airport_get().getWindVectorAtAltitude(this.altitude);

      var groundTrackHeading = (0, _vector.vradial)((0, _vector.vadd)(headingVector, windVector));
      return (0, _circle.radians_normalize)(groundTrackHeading);
    }
    /**
     * Determine the appropriate heading, or ground track, that the aircraft should be attempting to follow
     * Then, you can use #targetHeading and/or #targetGroundTrack to retrieve the desired information
     *
     * @for AircraftModel
     * @method _updateTargetedDirectionality
     * @private
     */

  }, {
    key: "_updateTargetedDirectionality",
    value: function _updateTargetedDirectionality() {
      if (this.mcp.autopilotMode !== _modeControlConstants.MCP_MODE.AUTOPILOT.ON) {
        return;
      }

      if (this.flightPhase === _aircraftConstants.FLIGHT_PHASE.LANDING) {
        this.targetGroundTrack = this._calculateTargetedGroundTrackDuringLanding();
        return;
      }

      switch (this.mcp.headingMode) {
        case _modeControlConstants.MCP_MODE.HEADING.OFF:
          {
            this.targetHeading = this.heading;
            break;
          }

        case _modeControlConstants.MCP_MODE.HEADING.HOLD:
          {
            this.targetHeading = this.mcp.heading;
            break;
          }

        case _modeControlConstants.MCP_MODE.HEADING.LNAV:
          {
            this.targetGroundTrack = this._calculateTargetedGroundTrackLnav();
            break;
          }

        case _modeControlConstants.MCP_MODE.HEADING.VOR_LOC:
          {
            this.targetGroundTrack = this._calculateTargetedHeadingToInterceptCourse();
            break;
          }

        default:
          console.warn('Expected MCP heading mode of "OFF", "HOLD", "LNAV", or "VOR", ' + "but received \"".concat(this.mcp.headingMode, "\""));
      }
    }
    /**
     * Calculate the aircraft's targeted speed
     *
     * @for AircraftModel
     * @method _calculateTargetedSpeed
     * @private
     */

  }, {
    key: "_calculateTargetedSpeed",
    value: function _calculateTargetedSpeed() {
      if (this.mcp.autopilotMode !== _modeControlConstants.MCP_MODE.AUTOPILOT.ON) {
        return;
      }

      if (this.flightPhase === _aircraftConstants.FLIGHT_PHASE.LANDING) {
        return this._calculateTargetedSpeedDuringLanding();
      }

      switch (this.mcp.speedMode) {
        case _modeControlConstants.MCP_MODE.SPEED.OFF:
          return this._calculateLegalSpeed(this.speed);

        case _modeControlConstants.MCP_MODE.SPEED.HOLD:
          return this._calculateLegalSpeed(this.mcp.speed);
        // future functionality
        // case MCP_MODE.SPEED.LEVEL_CHANGE:
        //     return;

        case _modeControlConstants.MCP_MODE.SPEED.N1:
          return this._calculateLegalSpeed(this.model.speed.max);

        case _modeControlConstants.MCP_MODE.SPEED.VNAV:
          {
            var vnavSpeed = this._calculateTargetedSpeedVnav();

            return this._calculateLegalSpeed(vnavSpeed);
          }

        default:
          console.warn('Expected MCP speed mode of "OFF", "HOLD", "LEVEL_CHANGE", "N1", or "VNAV", but ' + "received \"".concat(this.mcp[_modeControlConstants.MCP_MODE_NAME.SPEED], "\""));
          return this._calculateLegalSpeed(this.speed);
      }
    }
    /**
     * This method limits the aircraft's speed to a maximum of a specific speed
     * while below 10,000 feet MSL, to comply with regulations.
     *
     * @for AircraftModel
     * @method _calculateLegalSpeed
     * @param speed {number} desired speed
     * @return {number}      permitted speed
     */

  }, {
    key: "_calculateLegalSpeed",
    value: function _calculateLegalSpeed(speed) {
      if (this.altitude < 10000) {
        return Math.min(speed, _airportConstants.AIRPORT_CONSTANTS.MAX_SPEED_BELOW_10K_FEET);
      }

      return speed;
    }
    /**
     * Calculate the aircraft's targeted altitude
     *
     * @for AircraftModel
     * @method _calculateTargetedAltitude
     * @private
     */

  }, {
    key: "_calculateTargetedAltitude",
    value: function _calculateTargetedAltitude() {
      if (this.mcp.autopilotMode !== _modeControlConstants.MCP_MODE.AUTOPILOT.ON) {
        return;
      }

      if (this.flightPhase === _aircraftConstants.FLIGHT_PHASE.LANDING) {
        return this._calculateTargetedAltitudeDuringLanding();
      }

      switch (this.mcp.altitudeMode) {
        case _modeControlConstants.MCP_MODE.ALTITUDE.OFF:
          return this.altitude;

        case _modeControlConstants.MCP_MODE.ALTITUDE.HOLD:
          return this.mcp.altitude;

        case _modeControlConstants.MCP_MODE.ALTITUDE.APPROACH:
          return this._calculateTargetedAltitudeToInterceptGlidepath();
        // future functionality
        // case MCP_MODE.ALTITUDE.LEVEL_CHANGE:
        //     return;
        // future functionality
        // case MCP_MODE.ALTITUDE.VERTICAL_SPEED:
        //     return;

        case _modeControlConstants.MCP_MODE.ALTITUDE.VNAV:
          {
            return this._calculateTargetedAltitudeVnav();
          }

        default:
          console.warn('Expected MCP altitude mode of "OFF", "HOLD", "APPROACH", "LEVEL_CHANGE", ' + "\"VERTICAL_SPEED\", or \"VNAV\", but received \"".concat(this.mcp[_modeControlConstants.MCP_MODE_NAME.ALTITUDE], "\""));
          break;
      }
    }
    /**
     * Calculate the altitude to target while intercepting a vertically aligned course
     *
     * @for AircraftModel
     * @method _calculateTargetedAltitudeToInterceptGlidepath
     * @private
     */

  }, {
    key: "_calculateTargetedAltitudeToInterceptGlidepath",
    value: function _calculateTargetedAltitudeToInterceptGlidepath() {
      // GENERALIZED CODE
      // const glideDatum = this.mcp.nav1Datum;
      // const distanceFromDatum_nm = this.positionModel.distanceToPosition(glideDatum);
      // const slope = Math.tan(degreesToRadians(3));
      // const distanceFromDatum_ft = distanceFromDatum_nm * UNIT_CONVERSION_CONSTANTS.NM_FT;
      // const glideslopeAltitude = glideDatum.elevation + (slope * (distanceFromDatum_ft));
      // const altitudeToTarget = _clamp(glideslopeAltitude, glideDatum.elevation, this.altitude);
      if (!this.isEstablishedOnCourse()) {
        return this.mcp.altitude;
      } // ILS SPECIFIC CODE


      var glideslopeAltitude = this._calculateArrivalRunwayModelGlideslopeAltitude();

      var altitudeToTarget = Math.min(this.mcp.altitude, glideslopeAltitude);
      return altitudeToTarget;
    }
    /**
     * Calculate the heading to target while intercepting a horizontally aligned course
     *
     * @for AircraftModel
     * @method _calculateTargetedHeadingToInterceptCourse
     * @private
     */

  }, {
    key: "_calculateTargetedHeadingToInterceptCourse",
    value: function _calculateTargetedHeadingToInterceptCourse() {
      // Guide aircraft onto the localizer
      var _this$mcp = this.mcp,
          course = _this$mcp.course,
          nav1Datum = _this$mcp.nav1Datum;
      var courseOffset = (0, _flightMath.getOffset)(this, nav1Datum.relativePosition, course);
      var lateralDistanceFromCourseNm = (0, _unitConverters.nm)(courseOffset[0]);
      var headingDifference = (0, _circle.angle_offset)(course, this.heading);
      var bearingFromAircaftToRunway = this.positionModel.bearingToPosition(nav1Datum);
      var angleAwayFromLocalizer = course - bearingFromAircaftToRunway;

      var turnTimeInSeconds = (0, _core.abs)(headingDifference) / _aircraftConstants.PERFORMANCE.TURN_RATE; // time to turn headingDifference degrees
      // TODO: this should be moved to a class method `.getTurningRadius()`


      var turningRadius = this.speed * (turnTimeInSeconds * _globalConstants.TIME.ONE_SECOND_IN_HOURS); // dist covered in the turn, nm

      var distanceCoveredDuringTurn = turningRadius * (0, _core.abs)(headingDifference);
      var distanceToLocalizer = lateralDistanceFromCourseNm / (0, _core.sin)(headingDifference); // dist from localizer intercept, nm

      var distanceEarly = 0.5; // start turn early, to avoid overshoots from tailwind

      var shouldAttemptIntercept = distanceToLocalizer > 0 && distanceToLocalizer <= distanceCoveredDuringTurn + distanceEarly;
      var inTheWindow = (0, _core.abs)(angleAwayFromLocalizer) < (0, _unitConverters.degreesToRadians)(1.5); // move to loc regardless of assigned heading

      if (!shouldAttemptIntercept && !inTheWindow) {
        return this.mcp.heading;
      } // continue if shouldAttemptIntercept OR inTheWindow


      var severity_of_correction = 20; // controls steepness of heading adjustments during localizer tracking

      var interceptAngle = angleAwayFromLocalizer * -severity_of_correction;
      var minimumInterceptAngle = (0, _unitConverters.degreesToRadians)(10);

      var isAlignedWithCourse = (0, _core.abs)(lateralDistanceFromCourseNm) <= _aircraftConstants.PERFORMANCE.MAXIMUM_DISTANCE_CONSIDERED_ESTABLISHED_ON_APPROACH_COURSE_NM; // TODO: This is a patch fix, and it stinks. This whole method needs to be improved greatly.


      if (inTheWindow || isAlignedWithCourse) {
        this.target.turn = null;
        return course + interceptAngle;
      }

      interceptAngle = (0, _core.spread)(interceptAngle, -minimumInterceptAngle, minimumInterceptAngle);
      var interceptHeading = course + interceptAngle; // TODO: This should be abstracted

      if (this.mcp.heading < this.mcp.course) {
        var headingToFly = Math.max(interceptHeading, this.mcp.heading);
        return headingToFly;
      }

      if (this.mcp.heading > this.mcp.course) {
        var _headingToFly = Math.min(interceptHeading, this.mcp.heading);

        return _headingToFly;
      }
    }
    /**
     * This will update the FIX for the aircraft and will change the aircraft's heading
     *
     * @for AircraftModel
     * @method _calculateTargetedGroundTrackLnav
     */

  }, {
    key: "_calculateTargetedGroundTrackLnav",
    value: function _calculateTargetedGroundTrackLnav() {
      if (!this.fms.currentWaypoint) {
        return new Error('Unable to utilize LNAV, because there are no waypoints in the FMS');
      }

      if (this.fms.currentWaypoint.isVectorWaypoint) {
        return this.fms.currentWaypoint.getVector();
      }

      if (this.fms.currentWaypoint.isHoldWaypoint) {
        return this._calculateTargetedHeadingHold();
      }

      var waypointPosition = this.fms.currentWaypoint.positionModel;
      var distanceToWaypoint = this.positionModel.distanceToPosition(waypointPosition);
      var groundTrackToWaypoint = this.positionModel.bearingToPosition(waypointPosition);
      var turnInitiationDistance = (0, _flightMath.calculateTurnInitiationDistance)(this, waypointPosition);
      var isTimeToStartTurning = distanceToWaypoint < turnInitiationDistance;
      var closeToBeingOverFix = distanceToWaypoint < _aircraftConstants.PERFORMANCE.MAXIMUM_DISTANCE_TO_PASS_WAYPOINT_NM;
      var closeEnoughToFlyByFix = distanceToWaypoint < _aircraftConstants.PERFORMANCE.MAXIMUM_DISTANCE_TO_FLY_BY_WAYPOINT_NM;
      var shouldFlyByFix = closeEnoughToFlyByFix && isTimeToStartTurning;
      var shouldMoveToNextFix = closeToBeingOverFix;

      if (!this.fms.currentWaypoint.isFlyOverWaypoint) {
        shouldMoveToNextFix = closeToBeingOverFix || shouldFlyByFix;
      }

      if (shouldMoveToNextFix) {
        if (!this.fms.hasNextWaypoint()) {
          // we've hit this block because and aircraft is about to fly over the last waypoint in its flightPlan
          this.pilot.maintainPresentHeading(this);
          return this.groundTrack;
        }

        this.fms.moveToNextWaypoint();
        var currentWaypoint = this.fms.currentWaypoint;

        if (currentWaypoint.isVectorWaypoint) {
          return currentWaypoint.getVector();
        }

        var nextWaypointPosition = currentWaypoint.positionModel;

        if ((0, _isNil2["default"])(nextWaypointPosition)) {
          console.warn('Expected a valid PositionModel object for waypoint ' + "\"".concat(currentWaypoint.name, "\", but received ").concat(nextWaypointPosition));
        }

        return this.positionModel.bearingToPosition(nextWaypointPosition);
      }

      return groundTrackToWaypoint;
    }
    /**
     * This will sets up and prepares the aircraft to hold
     *
     * @for AircraftModel
     * @method _calculateTargetedHeadingHold
     */

  }, {
    key: "_calculateTargetedHeadingHold",
    value: function _calculateTargetedHeadingHold() {
      var currentWaypoint = this.fms.currentWaypoint;
      var holdParameters = currentWaypoint.holdParameters;
      var waypointRelativePosition = currentWaypoint.relativePosition;
      var bearingToHoldFix = (0, _vector.vradial)((0, _vector.vsub)(waypointRelativePosition, this.relativePosition));

      if (typeof holdParameters.inboundHeading === 'undefined') {
        // store the current heading as inbound heading, see #836
        holdParameters.inboundHeading = bearingToHoldFix;
      }

      var inboundHeading = holdParameters.inboundHeading,
          legLength = holdParameters.legLength;
      var outboundHeading = (0, _circle.radians_normalize)(inboundHeading + Math.PI);
      var groundTrack = (0, _circle.radians_normalize)(this.groundTrack);
      var offset = (0, _flightMath.getOffset)(this, waypointRelativePosition, inboundHeading);
      var gameTime = _TimeKeeper["default"].accumulatedDeltaTime;
      var isPastFix = offset[1] < 1 && offset[2] < 2;
      var isTimerSet = holdParameters.timer !== _globalConstants.INVALID_NUMBER;
      var isTimerExpired = isTimerSet && gameTime > holdParameters.timer;

      if (isPastFix && !this._isEstablishedOnHoldingPattern) {
        this._isEstablishedOnHoldingPattern = true;
      }

      if (!this._isEstablishedOnHoldingPattern) {
        return bearingToHoldFix;
      }

      var nextTargetHeading = outboundHeading;

      if ((0, _core.abs)(groundTrack - outboundHeading) < _aircraftConstants.PERFORMANCE.MAXIMUM_ANGLE_CONSIDERED_ESTABLISHED_ON_HOLD_COURSE && !isTimerSet) {
        var holdLegDurationInSeconds;

        if (legLength.indexOf('min') !== -1) {
          var holdLegDurationInMinutes = legLength.replace('min', '');
          holdLegDurationInSeconds = holdLegDurationInMinutes * _globalConstants.TIME.ONE_MINUTE_IN_SECONDS;
        } else {
          // Leg is a distance, use the ground speed to determine the duration
          var holdLegDistance = legLength.replace('nm', '');
          holdLegDurationInSeconds = holdLegDistance / this.groundSpeed * _globalConstants.TIME.ONE_HOUR_IN_SECONDS;
        }

        currentWaypoint.setHoldTimer(gameTime + holdLegDurationInSeconds);
      }

      if (isTimerExpired) {
        nextTargetHeading = bearingToHoldFix;

        if (isPastFix) {
          currentWaypoint.resetHoldTimer();
          nextTargetHeading = outboundHeading;
        }
      }

      this.target.turn = holdParameters.turnDirection;
      return nextTargetHeading;
    }
    /**
     * Calculates the altitude for a landing aircraft
     *
     * @for AircraftModel
     * @method _calculateTargetedAltitudeDuringLanding
     * @return {number}
     */

  }, {
    key: "_calculateTargetedAltitudeDuringLanding",
    value: function _calculateTargetedAltitudeDuringLanding() {
      var runwayModel = this.fms.arrivalRunwayModel;
      var offset = (0, _flightMath.getOffset)(this, runwayModel.relativePosition, runwayModel.angle);
      var distanceOnFinal_km = offset[1];

      if (distanceOnFinal_km > 0) {
        return this._calculateTargetedAltitudeToInterceptGlidepath();
      }

      return runwayModel.elevation;
    }
    /**
     * Calculates the altitude for an aircraft in a VNAV-guided altitude change
     *
     * @for AircraftModel
     * @method _calculateTargetedAltitudeVnav
     * @return {number}
     */

  }, {
    key: "_calculateTargetedAltitudeVnav",
    value: function _calculateTargetedAltitudeVnav() {
      var altitudeMaximumWaypoint = this.fms.findNextWaypointWithMaximumAltitudeRestriction();
      var altitudeMinimumWaypoint = this.fms.findNextWaypointWithMinimumAltitudeRestriction();
      var maximumAltitudeExists = !(0, _isNil2["default"])(altitudeMaximumWaypoint);
      var minimumAltitudeExists = !(0, _isNil2["default"])(altitudeMinimumWaypoint);

      if (this.mcp.altitude < this.altitude) {
        // we want to descend...
        if (!minimumAltitudeExists || altitudeMinimumWaypoint.altitudeMinimum < this.mcp.altitude) {
          // ... and there is nothing that can stop us.
          return this.mcp.altitude;
        }

        var altitudeMinimum = altitudeMinimumWaypoint.altitudeMinimum;

        if (this.altitude < altitudeMinimum) {
          // ... but we are too low and we have to comply with VNAV restriction
          return this._calculateTargetedAltitudeVnavClimb(altitudeMinimumWaypoint);
        }

        if (maximumAltitudeExists) {
          var altitudeMaximum = altitudeMaximumWaypoint.altitudeMaximum;

          if (this.mcp.altitude > altitudeMaximum) {
            // we are too high but we are prioritizing clearance over VNAV restriction
            return this.mcp.altitude;
          }

          if (this.altitude > altitudeMaximum) {
            // we are too high...
            if (altitudeMinimum > altitudeMaximum) {
              // the minimum altitude is above the maximum altiude, check if we can descend all the way down
              // without violating VNAV restrictions.
              var firstWaypoint = this._findFirstWaypoint(this.fms.waypoints, altitudeMinimumWaypoint, altitudeMaximumWaypoint);

              if (firstWaypoint.name === altitudeMinimumWaypoint.name) {
                // ... but we can not descend all the way down yet
                return this._calculateTargetedAltitudeVnavDescent(altitudeMinimumWaypoint, altitudeMinimum);
              }
            } // ...so descend to comply with VNAV restriction


            return this._calculateTargetedAltitudeVnavDescent(altitudeMaximumWaypoint, altitudeMaximum);
          }
        }
      } else {
        // we want to climb...
        if (!maximumAltitudeExists || this.mcp.altitude < altitudeMaximumWaypoint.altitudeMaximum) {
          // ... and there is nothing that can stop us.
          return this.mcp.altitude;
        }

        var _altitudeMaximum = altitudeMaximumWaypoint.altitudeMaximum;

        if (this.altitude > _altitudeMaximum) {
          // .. but we are too high and have to comply with NAV restriction
          return this._calculateTargetedAltitudeVnavDescent(altitudeMaximumWaypoint, _altitudeMaximum);
        }

        if (minimumAltitudeExists) {
          var _altitudeMinimum = altitudeMinimumWaypoint.altitudeMinimum;

          if (this.mcp.altitude < _altitudeMinimum) {
            // we are too low but we are prioritizing clearance over VNAV restriction
            return this.mcp.altitude;
          }

          if (this.altitude < _altitudeMinimum) {
            // we are too low ...
            if (_altitudeMaximum < _altitudeMinimum) {
              // the maximum altitude is below the minimal altiude, check if we can climb all the way up
              // without violating VNAV restrictions.
              var _firstWaypoint = this._findFirstWaypoint(this.fms.waypoints, altitudeMinimumWaypoint, altitudeMaximumWaypoint);

              if (_firstWaypoint.name === altitudeMaximumWaypoint.name) {
                // ... but we can not climb all the way up yet
                return _altitudeMaximum;
              }
            } // ... climb to comply with VNAV restriction


            return this._calculateTargetedAltitudeVnavClimb(altitudeMinimumWaypoint);
          }
        }

        return _altitudeMaximum;
      }
    }
    /**
     * Takes two waypoints and returns the waypoint that comes first in the list of waypoints
     *
     * @for AircraftModel
     * @method _findFirstWaypoint
     * @param waypoints
     * @param waypointA {WaypointModel}
     * @param waypointB {WaypointModel}
     * @return waypointA or waypointB {WaypointModel}
     */

  }, {
    key: "_findFirstWaypoint",
    value: function _findFirstWaypoint(waypoints, waypointA, waypointB) {
      var indexOfA = (0, _findIndex2["default"])(waypoints, function (waypoint) {
        return waypoint.name === waypointA.name;
      });
      var indexOfB = (0, _findIndex2["default"])(waypoints, function (waypoint) {
        return waypoint.name === waypointB.name;
      });
      return indexOfA < indexOfB ? waypointA : waypointB;
    }
    /**
     * Calculates the altitude for an aircraft in a VNAV-guided climb
     *
     * @for AircraftModel
     * @method _calculateTargetedAltitudeVnavClimb
     * @param waypointWithMinimumAltitudeRestriction {WaypointModel}
     * @return {number}
     */

  }, {
    key: "_calculateTargetedAltitudeVnavClimb",
    value: function _calculateTargetedAltitudeVnavClimb(waypointWithMinimumAltitudeRestriction) {
      var waypointMinimumAltitude = waypointWithMinimumAltitudeRestriction.altitudeMinimum;
      return waypointMinimumAltitude;
    }
    /**
     * Calculates the altitude for an aircraft in a VNAV-guided descent
     *
     * @for AircraftModel
     * @method _calculateTargetedAltitudeVnavDescent
     * @param waypointModel {WaypointModel} the waypoint at which to comply with the restriction
     * @param targetAltitude {number} the altitude to comply with
     * @return {number}
     */

  }, {
    key: "_calculateTargetedAltitudeVnavDescent",
    value: function _calculateTargetedAltitudeVnavDescent(waypointModel, targetAltitude) {
      if (!this.isBeyondTopOfDescentForWaypointModel(waypointModel, targetAltitude)) {
        return;
      }

      return targetAltitude;
    }
    /**
     * Calculates the heading for a landing aircraft
     *
     * @for AircraftModel
     * @method _calculateTargetedGroundTrackDuringLanding
     * @return {number}
     */

  }, {
    key: "_calculateTargetedGroundTrackDuringLanding",
    value: function _calculateTargetedGroundTrackDuringLanding() {
      var runwayModel = this.fms.arrivalRunwayModel;
      var offset = (0, _flightMath.getOffset)(this, runwayModel.relativePosition, runwayModel.angle);
      var distanceOnFinal_nm = (0, _unitConverters.nm)(offset[1]);

      if (distanceOnFinal_nm > 0) {
        var bearingFromAircaftToRunway = this.positionModel.bearingToPosition(runwayModel.positionModel);
        return bearingFromAircaftToRunway;
      }

      return runwayModel.angle;
    }
    /**
     * Calculates the speed for a landing aircraft
     *
     * @for AircraftModel
     * @method _calculateTargetedSpeedDuringLanding
     * @return {number}
     */

  }, {
    key: "_calculateTargetedSpeedDuringLanding",
    value: function _calculateTargetedSpeedDuringLanding() {
      var startSpeed = this.speed;
      var runwayModel = this.fms.arrivalRunwayModel;
      var offset = (0, _flightMath.getOffset)(this, runwayModel.relativePosition, runwayModel.angle);
      var distanceOnFinal_nm = (0, _unitConverters.nm)(offset[1]);
      var stableApproachTimeHours = _aircraftConstants.PERFORMANCE.STABLE_APPROACH_TIME_SECONDS * _globalConstants.TIME.ONE_SECOND_IN_HOURS;
      var stableApproachDistance = this.model.speed.landing * stableApproachTimeHours;

      if (distanceOnFinal_nm <= 0 && this.isOnGround()) {
        return 0;
      }

      if (this.mcp.speedMode === _modeControlConstants.MCP_MODE.SPEED.HOLD) {
        startSpeed = this.mcp.speed;
      }

      var nextSpeed = (0, _core.extrapolate_range_clamp)(stableApproachDistance, distanceOnFinal_nm, _airportConstants.AIRPORT_CONSTANTS.FINAL_APPROACH_FIX_DISTANCE_NM, this.model.speed.landing, startSpeed);
      return nextSpeed;
    }
    /**
     * Calculates the speed for an aircraft in a VNAV-guided speed change
     *
     * @for AircraftModel
     * @method _calculateTargetedSpeedVnav
     * @return {number} speed, in knots
     */

  }, {
    key: "_calculateTargetedSpeedVnav",
    value: function _calculateTargetedSpeedVnav() {
      var nextSpeedMaximumWaypoint = this.fms.findNextWaypointWithMaximumSpeedAtOrBelow(this.speed);
      var nextSpeedMinimumWaypoint = this.fms.findNextWaypointWithMinimumSpeedAtOrAbove(this.speed);
      var hasMaximumSpeed = !(0, _isNil2["default"])(nextSpeedMaximumWaypoint);
      var hasMinimumSpeed = !(0, _isNil2["default"])(nextSpeedMinimumWaypoint);

      if (!hasMaximumSpeed && !hasMinimumSpeed) {
        return this.mcp.speed;
      }

      if (hasMaximumSpeed && hasMinimumSpeed) {
        var waypoints = this.fms.waypoints;
        var indexOfMax = (0, _findIndex2["default"])(waypoints, function (waypoint) {
          return waypoint.name === nextSpeedMaximumWaypoint.name;
        });
        var indexOfMin = (0, _findIndex2["default"])(waypoints, function (waypoint) {
          return waypoint.name === nextSpeedMinimumWaypoint.name;
        });

        if (indexOfMax < indexOfMin) {
          return this._calculateTargetedSpeedVnavDeceleration(nextSpeedMaximumWaypoint);
        }

        return this._calculateTargetedSpeedVnavAcceleration(nextSpeedMinimumWaypoint);
      }

      if (hasMaximumSpeed) {
        return this._calculateTargetedSpeedVnavDeceleration(nextSpeedMaximumWaypoint);
      }

      if (hasMinimumSpeed) {
        return this._calculateTargetedSpeedVnavAcceleration(nextSpeedMinimumWaypoint);
      }
    }
    /**
     * Calculates the speed for an aircraft in a VNAV-guided acceleration
     *
     * @for AircraftModel
     * @method _calculateTargetedSpeedVnavAcceleration
     * @param waypointWithMinimumSpeedRestriction {WaypointModel}
     * @return {number}
     */

  }, {
    key: "_calculateTargetedSpeedVnavAcceleration",
    value: function _calculateTargetedSpeedVnavAcceleration(waypointWithMinimumSpeedRestriction) {
      var waypointMinimumSpeed = waypointWithMinimumSpeedRestriction.speedMinimum;
      return Math.min(waypointMinimumSpeed, this.mcp.speed);
    }
    /**
     * Calculates the speed for an aircraft in a VNAV-guided deceleration
     *
     * @for AircraftModel
     * @method _calculateTargetedSpeedVnavDeceleration
     * @param hardRestrictedWaypointModel {WaypointModel}
     * @return {number}
     */

  }, {
    key: "_calculateTargetedSpeedVnavDeceleration",
    value: function _calculateTargetedSpeedVnavDeceleration(waypointWithMaximumSpeedRestriction) {
      var waypointMaximumSpeed = waypointWithMaximumSpeedRestriction.speedMaximum;

      if (!this.isBeyondDecelerationPointForWaypointModel(waypointWithMaximumSpeedRestriction)) {
        return;
      }

      return Math.min(waypointMaximumSpeed, this.mcp.speed);
    } // TODO: this method needs a lot of love. its much too long with waaay too many nested if/else ifs.

    /**
     * @for AircraftModel
     * @method updatePhysics
     */

  }, {
    key: "updatePhysics",
    value: function updatePhysics() {
      if (this.isTaxiing()) {
        return;
      }

      if (this.hit) {
        // 90fps fall rate?...
        this.altitude -= 90 * _TimeKeeper["default"].getDeltaTimeForGameStateAndTimewarp();
        this.speed *= 0.99;
        return;
      }

      this.updateAircraftTurnPhysics();
      this.updateAltitudePhysics();

      if (this.isOnGround()) {
        this.trend = 0;
      } // SPEED


      this.updateSpeedPhysics();

      var offsetGameTime = _TimeKeeper["default"].accumulatedDeltaTime / _GameController["default"].game_speedup(); // const nextHistoricalPosition = [
      //     this.positionModel.relativePosition[0],
      //     this.positionModel.relativePosition[1],
      //     offsetGameTime
      // ];
      // TODO: whats the difference here between the if and else blocks? why are we looking for a 0 length?
      // TODO: abstract to AircraftPositionHistory class
      // Trailling


      if (this.relativePositionHistory.length === 0) {
        this.relativePositionHistory.push([this.positionModel.relativePosition[0], this.positionModel.relativePosition[1], offsetGameTime]); // TODO: this can be abstracted
      } else if ((0, _core.abs)(offsetGameTime - this.relativePositionHistory[this.relativePositionHistory.length - 1][2]) > 4 / _GameController["default"].game_speedup()) {
        this.relativePositionHistory.push([this.positionModel.relativePosition[0], this.positionModel.relativePosition[1], offsetGameTime]);
      }

      this.updateGroundSpeedPhysics();
      this.distance = (0, _vector.vlen)(this.positionModel.relativePosition);
      this.radial = (0, _circle.radians_normalize)((0, _vector.vradial)(this.positionModel.relativePosition));
    }
    /**
     * This turns the aircraft if it is not on the ground and has not arived at its destenation
     *
     * @for AircraftModel
     * @method updateAircraftTurnPhysics
     */

  }, {
    key: "updateAircraftTurnPhysics",
    value: function updateAircraftTurnPhysics() {
      if (this.isOnGround() || this.heading === this.targetHeading) {
        this.target.turn = null;
        return;
      }

      var secondsElapsed = _TimeKeeper["default"].getDeltaTimeForGameStateAndTimewarp();

      var angle_diff = (0, _circle.angle_offset)(this.targetHeading, this.heading);
      var angle_change = _aircraftConstants.PERFORMANCE.TURN_RATE * secondsElapsed; // TODO: clean this up if possible, there is a lot of branching logic here

      if ((0, _core.abs)(angle_diff) <= angle_change) {
        this.heading = this.targetHeading;
      } else if (this.target.turn) {
        if (this.target.turn === 'left') {
          this.heading = (0, _circle.radians_normalize)(this.heading - angle_change);
        } else if (this.target.turn === 'right') {
          this.heading = (0, _circle.radians_normalize)(this.heading + angle_change);
        }
      } else if (angle_diff <= 0) {
        this.heading = (0, _circle.radians_normalize)(this.heading - angle_change);
      } else if (angle_diff > 0) {
        this.heading = (0, _circle.radians_normalize)(this.heading + angle_change);
      }
    }
    /**
     * This updates the Altitude for the instance of the aircraft by checking the difference
     * between current Altitude and requested Altitude
     *
     * @for AircraftModel
     * @method updateAltitudePhysics
     */

  }, {
    key: "updateAltitudePhysics",
    value: function updateAltitudePhysics() {
      this.trend = 0;

      if (this.target.altitude < this.altitude) {
        this.decreaseAircraftAltitude();
      } else if (this.target.altitude > this.altitude) {
        this.increaseAircraftAltitude();
      }
    }
    /**
    * Decreases the aircrafts altitude
    *
    * @for AircraftModel
    * @method decreaseAircraftAltitude
    */

  }, {
    key: "decreaseAircraftAltitude",
    value: function decreaseAircraftAltitude() {
      var altitude_diff = this.altitude - this.target.altitude;
      var descentRate = this.model.rate.descent * _aircraftConstants.PERFORMANCE.TYPICAL_DESCENT_FACTOR;

      if (this.mcp.shouldExpediteAltitudeChange || this.isEstablishedOnCourse()) {
        descentRate = this.model.rate.descent;
      }

      var feetPerSecond = descentRate * _globalConstants.TIME.ONE_SECOND_IN_MINUTES;

      var feetDescended = feetPerSecond * _TimeKeeper["default"].getDeltaTimeForGameStateAndTimewarp();

      if ((0, _core.abs)(altitude_diff) < feetDescended) {
        this.altitude = this.target.altitude;
        this.mcp.shouldExpediteAltitudeChange = false;
      } else {
        this.altitude -= feetDescended;
      }

      this.trend -= 1;
    }
    /**
    * Increases the aircrafts altitude
    *
    * @for AircraftModel
    * @method increaseAircraftAltitude
    */

  }, {
    key: "increaseAircraftAltitude",
    value: function increaseAircraftAltitude() {
      var altitude_diff = this.altitude - this.target.altitude;

      var climbRate = this.getClimbRate() * _aircraftConstants.PERFORMANCE.TYPICAL_CLIMB_FACTOR; // TODO: Ensure expediting is STOPPED when the altitude is reached


      if (this.mcp.shouldExpediteAltitudeChange || this.isTakeoff()) {
        climbRate = this.model.rate.climb;
      }

      var feetPerSecond = climbRate * _globalConstants.TIME.ONE_SECOND_IN_MINUTES;

      var feetClimbed = feetPerSecond * _TimeKeeper["default"].getDeltaTimeForGameStateAndTimewarp();

      if ((0, _core.abs)(altitude_diff) < (0, _core.abs)(feetClimbed)) {
        this.altitude = this.target.altitude;
        this.mcp.shouldExpediteAltitudeChange = false;
      } else {
        this.altitude += feetClimbed;
      }

      this.trend = 1;
    }
    /**
     * This updates the speed for the instance of the aircraft by checking the
     * difference between current speed and requested speed
     *
     * @for AircraftModel
     * @method updateWarning
     */

  }, {
    key: "updateSpeedPhysics",
    value: function updateSpeedPhysics() {
      var speedChange = 0;
      var differenceBetweenPresentAndTargetSpeeds = this.speed - this.target.speed;

      if (differenceBetweenPresentAndTargetSpeeds === 0) {
        return;
      }

      if (this.speed > this.target.speed) {
        speedChange = -this.model.rate.decelerate * _TimeKeeper["default"].getDeltaTimeForGameStateAndTimewarp() / 2;

        if (this.isOnGround()) {
          speedChange *= _aircraftConstants.PERFORMANCE.DECELERATION_FACTOR_DUE_TO_GROUND_BRAKING;
        }
      } else if (this.speed < this.target.speed) {
        speedChange = this.model.rate.accelerate * _TimeKeeper["default"].getDeltaTimeForGameStateAndTimewarp() / 2;
        speedChange *= (0, _core.extrapolate_range_clamp)(0, this.speed, this.model.speed.min, 2, 1);
      }

      this.speed += speedChange;

      if ((0, _core.abs)(speedChange) > (0, _core.abs)(differenceBetweenPresentAndTargetSpeeds)) {
        this.speed = this.target.speed;
      }
    }
    /**
     * This calculates the ground speed
     *
     * @for AircraftModel
     * @method updateVectorPhysics
     * @param scaleSpeed
     */

  }, {
    key: "updateGroundSpeedPhysics",
    value: function updateGroundSpeedPhysics() {
      // TODO: Much of this should be abstracted to helper functions
      // Calculate true air speed vector
      var indicatedAirspeed = this.speed;
      var trueAirspeedIncreaseFactor = this.altitude * _environmentConstants.ENVIRONMENT.DENSITY_ALT_INCREASE_FACTOR_PER_FT;
      var trueAirspeed = indicatedAirspeed * (1 + trueAirspeedIncreaseFactor);
      var flightThroughAirVector = (0, _vector.vscale)((0, _vector.vectorize2dFromRadians)(this.heading), trueAirspeed); // Calculate ground speed and direction

      var windVector = _AirportController["default"].airport_get().getWindVectorAtAltitude(this.altitude);

      var flightPathVector = (0, _vector.vadd)(flightThroughAirVector, windVector);
      var groundSpeed = (0, _vector.vlen)(flightPathVector);
      var groundTrack = (0, _vector.vradial)(flightPathVector); // Prevent aircraft on the ground from being blown off runway centerline when too slow to crab sufficiently

      if (this.isOnGround()) {
        // TODO: Aircraft crabbing into the wind will show an increase in groundspeed after they reduce to slower than
        // the wind speed. This should be corrected so their groundspeed gradually reduces from touchdown spd to 0.
        groundTrack = this.targetGroundTrack;
      } // Calculate new position


      var hoursElapsed = _TimeKeeper["default"].getDeltaTimeForGameStateAndTimewarp() * _globalConstants.TIME.ONE_SECOND_IN_HOURS;

      var distanceTraveled_nm = groundSpeed * hoursElapsed;
      this.positionModel.setCoordinatesByBearingAndDistance(groundTrack, distanceTraveled_nm);
      this.groundTrack = groundTrack;
      this.groundSpeed = groundSpeed;
      this.trueAirspeed = trueAirspeed;
    } // TODO: this method needs a lot of love. its much too long with waaay too many nested if/else ifs.

    /**
     * @for AircraftModel
     * @method updateWarning
     */

  }, {
    key: "updateWarning",
    value: function updateWarning() {
      var area;
      var warning;
      var status;
      var new_inside; // Ignore other aircraft while taxiing

      if (this.isTaxiing()) {
        return;
      }

      warning = false; // restricted areas
      // players are penalized for each area entry

      if (this.positionModel) {
        for (var i = 0; i < this.restricted.list.length; i++) {
          // TODO: this should be abstracted to a helper function
          //   Polygon matching procedure:
          //
          //   1. Filter polygons by aircraft altitude
          //   2. For other polygons, measure distance to it (distance_to_poly), then
          //      substract travelled distance every turn
          //      If distance is about less than 10 seconds of flight,
          //      assign distance equal to 10 seconds of flight,
          //      otherwise planes flying along the border of entering at shallow angle
          //      will cause too many checks.
          //   3. if distance has reached 0, check if the aircraft is within the poly.
          //      If not, redo #2.
          area = this.restricted.list[i]; // filter only those relevant by height

          if (area.data.height < this.altitude) {
            area.range = null;
            area.inside = false;
            continue;
          } // count distance untill the next check


          if (area.range) {
            area.range -= this.groundSpeed;
          } // recalculate for new areas or those that should be checked


          if (!area.range || area.range <= 0) {
            new_inside = (0, _vector.point_in_poly)(this.positionModel.relativePosition, area.data.coordinates); // ac has just entered the area: .inside is still false, but st is true

            if (new_inside && !area.inside) {
              _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.AIRSPACE_BUST);

              area.range = this.speed * 1.85 / 3.6 * 50 / 1000; // check in 50 seconds
              // speed is kts, range is km.
              // if a plane got into restricted area, don't check it too often
            } else {
              // don't calculate more often than every 10 seconds
              area.range = Math.max(this.speed * 1.85 / 36 / 1000 * 10, (0, _vector.distance_to_poly)(this.positionModel.relativePosition, area.data.coordinates));
            }

            area.inside = new_inside;
          }
        } // this was a $.each() and may need to verified that its working with _forEach()
        // raise warning if in at least one restricted area


        (0, _forEach2["default"])(this.restricted.list, function (k, v) {
          warning = warning || v.inside;
        });
      }

      if (this.terrain_ranges && !this.isOnGround()) {
        var terrain = _AirportController["default"].current.terrain;
        var prev_level = this.terrain_ranges[this.terrain_level];
        var ele = Math.ceil(this.altitude, 1000);
        var curr_ranges = this.terrain_ranges[ele];

        if (ele !== this.terrain_level) {
          for (var lev in prev_level) {
            prev_level[lev] = Infinity;
          }

          this.terrain_level = ele;
        }

        for (var id in curr_ranges) {
          curr_ranges[id] -= this.groundSpeed;

          if (curr_ranges[id] < 0 || curr_ranges[id] === Infinity) {
            area = terrain[ele][id];
            status = (0, _vector.point_to_mpoly)(this.positionModel.relativePosition, area, id);

            if (status.inside) {
              this.altitude = 0;

              if (!this.hit) {
                this.hit = true;
                var isWarning = true;

                _UiController["default"].ui_log("".concat(this.callsign, " collided with terrain in controlled flight"), isWarning);

                (0, _speech.speech_say)([{
                  type: 'callsign',
                  content: this
                }, {
                  type: 'text',
                  content: ', we\'re going down!'
                }], this.pilotVoice);

                _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.COLLISION);
              }
            } else {
              curr_ranges[id] = Math.max(0.2, status.distance);
            }
          }
        }
      }

      this.warning = warning;
    }
    /**
     * @for AircraftModel
     * @method update
     */

  }, {
    key: "update",
    value: function update() {
      this.updateFlightPhase();
      this.updateTarget();
      this.updatePhysics();

      this._updateAircraftVisibility();
    }
    /**
     * @for AircraftModel
     * @method addConflict
     * @param {AircraftConflict} conflict
     * @param {AircraftModel} conflictingAircraft
     */

  }, {
    key: "addConflict",
    value: function addConflict(conflict, conflictingAircraft) {
      this.conflicts[conflictingAircraft.callsign] = conflict;
    }
    /**
     * Used to determine if a `conflictingAircraft.callsign` already exists within
     * the list of known conflicts for an aircaft
     *
     * @for AircraftModel
     * @method hasConflictWithAircraftModel
     * @param {AircraftModel} conflictingAircraft
     * @returns {boolean}
     */

  }, {
    key: "hasConflictWithAircraftModel",
    value: function hasConflictWithAircraftModel(conflictingAircraftModel) {
      return conflictingAircraftModel.callsign in this.conflicts;
    }
    /**
     * Return the presence/absence of (any existing) conflict or violation in terms
     * of separation with another aircraft
     *
     * @for AircraftModel
     * @method getAlerts
     * @return {array} [hasConflict, hasViolation]
     */

  }, {
    key: "getAlerts",
    value: function getAlerts() {
      var alert = [false, false];

      for (var i in this.conflicts) {
        var hasConflict = this.conflicts[i].hasConflict();
        var hasViolation = this.conflicts[i].hasViolation();
        alert[0] = alert[0] || hasConflict;
        alert[1] = alert[1] || hasViolation;

        if (alert[0] && alert[1]) {
          return alert;
        }
      }

      return alert;
    }
    /**
     * @for AircraftModel
     * @method removeConflict
     * @param {AircraftModel} conflictingAircraft
     */

  }, {
    key: "removeConflict",
    value: function removeConflict(conflictingAircraft) {
      delete this.conflicts[conflictingAircraft.callsign];
    } // TODO: needs better name

    /**
     * @for AircraftModel
     * @method _contactAircraftAfterControllabilityChange
     * @private
     */

  }, {
    key: "_contactAircraftAfterControllabilityChange",
    value: function _contactAircraftAfterControllabilityChange() {
      // Crossing into the center
      if (this.isControllable) {
        this.callUp(); // for reentry, see #993

        this.isFlightStripRemovable = false;
        return;
      }

      this.setIsRemovable();

      _EventBus["default"].trigger(_eventNames.AIRCRAFT_EVENT.AIRSPACE_EXIT, this);
    }
    /**
     * @for AircraftModel
     * @method _updateAircraftVisibility
     * @private
     */

  }, {
    key: "_updateAircraftVisibility",
    value: function _updateAircraftVisibility() {
      var isInsideAirspace = this.isInsideAirspace(_AirportController["default"].airport_get());

      if (isInsideAirspace === this.isControllable || this.projected) {
        return;
      }

      this._updateControllableStatus(isInsideAirspace);

      this._contactAircraftAfterControllabilityChange();
    }
    /**
     * Updates the `#isControllable` property when an aircraft either
     * enters or exits controlled airspace
     *
     * @for AircraftModel
     * @method _updateControllableStatus
     * @param {booelan} nextControllableStatus
     */

  }, {
    key: "_updateControllableStatus",
    value: function _updateControllableStatus(nextControllableStatus) {
      this.isControllable = nextControllableStatus;

      if (!nextControllableStatus) {
        this.setIsFlightStripRemovable();
      }
    }
    /**
     * Returns the distance to another aircraft in nm
     *
     * @for AircraftModel
     * @method distanceToAircraft
     * @param aircraftModel {AircraftModel}
     * @return {number} distance in nm
     */

  }, {
    key: "distanceToAircraft",
    value: function distanceToAircraft(anotherAircraftModel) {
      return this.positionModel.distanceToPosition(anotherAircraftModel.positionModel);
    }
    /**
     * Ensure that the provided altitude is valid
     *
     * @for AircraftModel
     * @method validateNextAltitude
     * @param nextAltitude {number} altitude the aircraft should maintain
     * @return {array}           [success of operation, readback]
     */

  }, {
    key: "validateNextAltitude",
    value: function validateNextAltitude(nextAltitude, airportModel) {
      if (nextAltitude === _globalConstants.INVALID_NUMBER) {
        return [false, 'unable, no altitude assigned'];
      }

      if (typeof nextAltitude !== 'number') {
        return [false, "unable to maintain an altitude of ".concat(nextAltitude)];
      }

      if (!this.model.isAbleToMaintainAltitude(nextAltitude)) {
        var readback = {};
        readback.log = "unable to maintain ".concat(nextAltitude, " due to performance");
        readback.say = "unable to maintain ".concat((0, _radioUtilities.radio_altitude)(nextAltitude), " due to performance");
        return [false, readback];
      }

      if (nextAltitude < airportModel.minAssignableAltitude) {
        var minimumAltitude = airportModel.minAssignableAltitude;
        var _readback = {};
        _readback.log = "unable to maintain ".concat(nextAltitude, ", the MSA is ").concat(minimumAltitude);
        _readback.say = "unable to maintain ".concat((0, _radioUtilities.radio_altitude)(nextAltitude), ", the MSA is ").concat((0, _radioUtilities.radio_altitude)(minimumAltitude));
        return [false, _readback];
      }

      return [true];
    }
    /**
     * Ensure that the provided speed is valid
     *
     * @for AircraftModel
     * @method validateNextSpeed
     * @param nextSpeed {number} speed the aircraft should maintain
     * @return {array}          [success of operation, readback]
     */

  }, {
    key: "validateNextSpeed",
    value: function validateNextSpeed(nextSpeed) {
      if (nextSpeed === _globalConstants.INVALID_NUMBER) {
        return [false, 'unable, no speed assigned'];
      }

      if (typeof nextSpeed !== 'number') {
        return [false, "unable to maintain a speed of ".concat(nextSpeed)];
      }

      if (!this.model.isAbleToMaintainSpeed(nextSpeed)) {
        var readback = {
          log: "unable to maintain ".concat(nextSpeed, " due to performance"),
          say: "unable to maintain ".concat((0, _radioUtilities.radio_spellOut)(nextSpeed), " knots due to performance")
        };
        return [false, readback];
      }

      return [true];
    }
  }, {
    key: "targetHeading",
    get: function get() {
      if ((0, _isNil2["default"])(this._targetHeading)) {
        if ((0, _isNil2["default"])(this._targetGroundTrack)) {
          throw new TypeError('Expected a targetHeading OR targetGroundTrack, but neither has been set!');
        }

        return this._calculateCrabHeadingForGroundTrack(this._targetGroundTrack);
      }

      return this._targetHeading;
    },
    set: function set(heading) {
      this._targetHeading = heading;
      this._targetGroundTrack = null;
    }
    /**
    * The magnetic heading to target, for which a/c SHOULD apply wind correction, in radians
    * NOTE: This will not be the heading the aircraft is actually facing-- the aircraft will be crabbing into
    *       the wind. For the heading the aircraft is physically pointing at, use #targetHeading instead.
    *
    * @for AircraftModel
    * @property targetGroundTrack
    * @type {number} heading, in radians magnetic
    */

  }, {
    key: "targetGroundTrack",
    get: function get() {
      if ((0, _isNil2["default"])(this._targetGroundTrack)) {
        if ((0, _isNil2["default"])(this._targetHeading)) {
          throw new TypeError('Expected a targetHeading OR targetGroundTrack, but neither has been set!');
        }

        return this._calculateGroundTrackForHeading(this._targetHeading);
      }

      return this._targetGroundTrack;
    },
    set: function set(groundTrack) {
      this._targetGroundTrack = groundTrack;
      this._targetHeading = null;
    }
    /**
     * @for AircraftModel
     * @property callsign
     * @return {string}
     */

  }, {
    key: "callsign",
    get: function get() {
      return "".concat(this.airlineId.toUpperCase()).concat(this.flightNumber.toUpperCase());
    }
    /**
     * Current flight phase
     *
     * @for AircraftModel
     * @property flightPhase
     * @type {string}
     */

  }, {
    key: "flightPhase",
    get: function get() {
      return this.fms.currentPhase;
    }
    /**
     * Fascade to access relative position
     *
     * @for AircraftModel
     * @property relativePosition
     * @type {array<number>} [kilometersNorth, kilometersEast]
     */

  }, {
    key: "relativePosition",
    get: function get() {
      return this.positionModel.relativePosition;
    }
  }]);

  return AircraftModel;
}();

exports["default"] = AircraftModel;

},{"../airport/AirportController":284,"../constants/aircraftConstants":303,"../constants/airportConstants":305,"../constants/environmentConstants":307,"../constants/eventNames":308,"../constants/globalConstants":310,"../engine/TimeKeeper":338,"../game/GameController":339,"../lib/EventBus":346,"../math/circle":348,"../math/core":349,"../math/flightMath":351,"../math/vector":352,"../speech":375,"../ui/UiController":385,"../utilities/radioUtilities":389,"../utilities/unitConverters":391,"./AircraftTypeDefinitionModel":267,"./FlightManagementSystem/Fms":268,"./ModeControl/ModeController":272,"./ModeControl/modeControlConstants":273,"./Pilot/Pilot":274,"lodash/ceil":179,"lodash/defaultTo":187,"lodash/findIndex":192,"lodash/floor":198,"lodash/forEach":199,"lodash/get":200,"lodash/isEmpty":213,"lodash/isEqual":214,"lodash/isNil":219,"lodash/uniqueId":250}],266:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _find2 = _interopRequireDefault(require("lodash/find"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _BaseCollection2 = _interopRequireDefault(require("../base/BaseCollection"));

var _AircraftTypeDefinitionModel = _interopRequireDefault(require("./AircraftTypeDefinitionModel"));

var _airlineHelpers = require("../airline/airlineHelpers");

var _validatorUtilities = require("../utilities/validatorUtilities");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Collection of `AircraftModel` objects
 *
 * Responsible for creating new `AircraftModel` objects when a spawnInterval
 * fires its `createAircraftWithSpawnPatternModel` callback.
 *
 * This collection also keeps a list of `AircraftTypeDefinitionModel` objects, which define each
 * aircraft type.
 *
 * @class AircraftTypeDefinitionCollection
 * @extends BaseCollection
 */

/* istanbul ignore next */
var AircraftTypeDefinitionCollection =
/*#__PURE__*/
function (_BaseCollection) {
  _inherits(AircraftTypeDefinitionCollection, _BaseCollection);

  /**
   * @constructor
   * @for AircraftTypeDefinitionCollection
   * @param aircraftTypeDefinitionList {array<object>}
   */
  function AircraftTypeDefinitionCollection(aircraftTypeDefinitionList) {
    var _this;

    _classCallCheck(this, AircraftTypeDefinitionCollection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AircraftTypeDefinitionCollection).call(this));

    if ((0, _validatorUtilities.isEmptyOrNotArray)(aircraftTypeDefinitionList)) {
      // eslint-disable-next-line max-len
      throw new TypeError('Invalid aircraftTypeDefinitionList passed to AircraftTypeDefinitionCollection. Expected and array but ' + "received ".concat(_typeof(aircraftTypeDefinitionList)));
    }
    /**
     * A collection of `AircraftTypeDefinitionModel` objects
     *
     * Not using the inherited `_items` property here for readability
     * and the fact that we need this property to be public.
     *
     * @property definitionList
     * @type {array}
     * @default []
     */


    _this.definitionList = [];

    _this.init(aircraftTypeDefinitionList);

    return _this;
  }
  /**
   * Lifecycle method. Should be run only once on instantiation.
   *
   * Initializes instance properties.
   *
   * @for AircraftTypeDefinitionCollection
   * @method init
   * @param aircraftTypeDefinitionList {array<object>}
   */


  _createClass(AircraftTypeDefinitionCollection, [{
    key: "init",
    value: function init(aircraftTypeDefinitionList) {
      this.definitionList = this._buildAircraftTypeDefinitionModelList(aircraftTypeDefinitionList);
    }
    /**
     * @for AircraftTypeDefinitionCollection
     * @method findAircraftTypeDefinitionModelByIcao
     * @param icao {string}
     * @return {AircraftTypeDefinitionModel}
     */

  }, {
    key: "findAircraftTypeDefinitionModelByIcao",
    value: function findAircraftTypeDefinitionModelByIcao(icao) {
      return (0, _find2["default"])(this.definitionList, {
        icao: icao
      });
    }
    /**
     * Given an `airlineId`, find a random aircraft type from the airline.
     *
     * @for AircraftTypeDefinitionCollection
     * @method getAircraftDefinitionForAirlineId
     * @param airlineId {string}
     * @param airlineModel {AirlineModel}
     * @return aircraftDefinition {AircraftTypeDefinitionModel}
     */

  }, {
    key: "getAircraftDefinitionForAirlineId",
    value: function getAircraftDefinitionForAirlineId(airlineId, airlineModel) {
      var _airlineNameAndFleetH = (0, _airlineHelpers.airlineNameAndFleetHelper)([airlineId]),
          fleet = _airlineNameAndFleetH.fleet;

      var aircraftType = airlineModel.getRandomAircraftType(fleet);
      var aircraftDefinition = (0, _find2["default"])(this.definitionList, {
        icao: aircraftType
      });

      if (typeof aircraftDefinition === 'undefined') {
        console.error("Undefined aircraftDefinition found for ".concat(aircraftType.toUpperCase())); // recurse through this method if an error is encountered

        return this.getAircraftDefinitionForAirlineId(airlineId, airlineModel);
      }

      return aircraftDefinition;
    }
    /**
     * Loop through aircraft defined in the `definitionList` and create an
     * `AircraftTypeDefinitionModel` for each.
     *
     * @for AircraftTypeDefinitionCollection
     * @method _buildAircraftTypeDefinitionModelList
     * @param aircraftTypeDefinitionList {array}
     * @return definitionList {array<AircraftTypeDefinitionModel>}
     * @private
     */

  }, {
    key: "_buildAircraftTypeDefinitionModelList",
    value: function _buildAircraftTypeDefinitionModelList(aircraftTypeDefinitionList) {
      var definitionList = (0, _map2["default"])(aircraftTypeDefinitionList, function (aircraftDefinition) {
        // this is not using a direct return simply for readability
        return new _AircraftTypeDefinitionModel["default"](aircraftDefinition);
      });
      return definitionList;
    }
  }]);

  return AircraftTypeDefinitionCollection;
}(_BaseCollection2["default"]);

exports["default"] = AircraftTypeDefinitionCollection;

},{"../airline/airlineHelpers":282,"../base/BaseCollection":294,"../utilities/validatorUtilities":392,"./AircraftTypeDefinitionModel":267,"lodash/find":191,"lodash/map":231}],267:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _BaseModel2 = _interopRequireDefault(require("../base/BaseModel"));

var _globalConstants = require("../constants/globalConstants");

var _validatorUtilities = require("../utilities/validatorUtilities");

var _airportConstants = require("../constants/airportConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// TODO: abstract these to an appropriate constants file
var HEAVY_LETTER = 'H';
var SUPER_LETTER = 'J';
/**
 * Provides a definition for a specific type of aircraft.
 *
 * Encapsulates an aircraft json file into a JS class that can be used to create an `AircraftModel`.
 *
 * It is important to note that this is not a `type` in the programming sense, this is in reference to
 * a specific aircraft type.
 *
 * @class AircraftTypeDefinitionModel
 * @extends BaseModel
 */

var AircraftTypeDefinitionModel =
/*#__PURE__*/
function (_BaseModel) {
  _inherits(AircraftTypeDefinitionModel, _BaseModel);

  /**
   * @constructor
   * @for AircraftTypeDefinitionModel
   * @param aircraftTypeDefinition {object}
   */
  function AircraftTypeDefinitionModel(aircraftTypeDefinition) {
    var _this;

    _classCallCheck(this, AircraftTypeDefinitionModel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AircraftTypeDefinitionModel).call(this));

    if ((0, _validatorUtilities.isEmptyObject)(aircraftTypeDefinition)) {
      throw new TypeError('Invalid parameter. Expected aircraftTypeDefinition to be an object');
    }
    /**
     * Name of the aircratType
     *
     * @property name
     * @type {string}
     * @default ''
     */


    _this.name = '';
    /**
     * ICAO identifier of the aircraftType
     *
     * @property icao
     * @type {string}
     * @default ''
     */

    _this.icao = '';
    /**
     * Icao identifier that includes a weightClass
     * designation when `Heavy` or `Super`
     *
     * @property icaoWithWeightClass
     * @type {string}
     * @default ''
     */

    _this.icaoWithWeightClass = '';
    /**
     * Describes the number and type of engines
     *
     * @property engines
     * @type {object}
     * @default null
     */

    _this.engines = null;
    /**
     * @property weightClass
     * @type {string}
     * @default ''
     */

    _this.weightClass = '';
    /**
     * @property category
     * @type {object}
     * @default null
     */

    _this.category = null;
    /**
     * Maximum safe altitude
     *
     * @property ceiling
     * @type {number}
     * @default INVALID_NUMBER
     */

    _this.ceiling = _globalConstants.INVALID_NUMBER;
    /**
     * Decsribes rate of:
     * - climb
     * - descent
     * - acceleration
     * - deceleratation
     *
     * @property rate
     * @type {object}
     * @default null
     */

    _this.rate = null;
    /**
     * Takeoff distances needed for landing and Takeoff
     *
     * @property runway
     * @type {object}
     * @default null
     */

    _this.runway = null;
    /**
     * Operating speeds
     * - minimum
     * - landing
     * - cruise
     * - maximum
     *
     * @property speed
     * @type {object}
     * @default null
     */

    _this.speed = null;
    /**
     * Boolean values for:
     * - ils
     * - fix
     *
     * @property capability
     * @type {object}
     * @default
     */

    _this.capability = null;

    _this.init(aircraftTypeDefinition);

    return _this;
  }
  /**
   * Lifecycle method, should be run only once on instantiation.
   *
   * Initialize instance properties
   *
   * @for AircraftDefinitionModel
   * @method init
   * @param aircraftTypeDefinition {object}
   */


  _createClass(AircraftTypeDefinitionModel, [{
    key: "init",
    value: function init(aircraftTypeDefinition) {
      this.name = aircraftTypeDefinition.name;
      this.icao = aircraftTypeDefinition.icao.toLowerCase();
      this.engines = aircraftTypeDefinition.engines;
      this.weightClass = aircraftTypeDefinition.weightClass;
      this.category = aircraftTypeDefinition.category;
      this.ceiling = aircraftTypeDefinition.ceiling;
      this.rate = aircraftTypeDefinition.rate;
      this.runway = aircraftTypeDefinition.runway;
      this.speed = aircraftTypeDefinition.speed;
      this.capability = aircraftTypeDefinition.capability;
      this.icaoWithWeightClass = this._buildTypeForStripView();
    }
    /**
     * Destroy the current instance
     *
     * @for AircraftDefinitionModel
     * @method destroy
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.name = '';
      this.icao = '';
      this.icaoWithWeightClass = '';
      this.engines = null;
      this.weightClass = '';
      this.category = null;
      this.ceiling = _globalConstants.INVALID_NUMBER;
      this.rate = null;
      this.runway = null;
      this.speed = null;
      this.capability = null;
    }
    /**
     * Build the string used for `#icaoWithWeightClass`
     *
     * @for AircraftTypeDefinitionModel
     * @method _buildTypeForStripView
     * @return {string}
     * @private
     */

  }, {
    key: "_buildTypeForStripView",
    value: function _buildTypeForStripView() {
      var aircraftIcao = "".concat(this.icao, "/L");

      switch (this.weightClass) {
        case SUPER_LETTER:
          aircraftIcao = "".concat(SUPER_LETTER, "/").concat(this.icao, "/L");
          break;

        case HEAVY_LETTER:
          aircraftIcao = "".concat(HEAVY_LETTER, "/").concat(this.icao, "/L");
          break;

        default:
          break;
      }

      return aircraftIcao.toUpperCase();
    }
    /**
     * @for AircraftTypeDefinitionModel
     * @method isAbleToMaintainAltitude
     * @param altitude {Number}
     * @return {Boolean}
     */

  }, {
    key: "isAbleToMaintainAltitude",
    value: function isAbleToMaintainAltitude(altitude) {
      return altitude <= this.ceiling;
    }
    /**
     * @for AircraftTypeDefinitionModel
     * @method isAbleToMaintainSpeed
     * @param speed {Number}
     * @return {Boolean}
     */

  }, {
    key: "isAbleToMaintainSpeed",
    value: function isAbleToMaintainSpeed(speed) {
      return speed >= this.speed.min && speed <= this.speed.max;
    }
    /**
     * @for AircraftTypeDefinitionModel
     * @method isHeavyOrSuper
     * @returns {Boolean}
     */

  }, {
    key: "isHeavyOrSuper",
    value: function isHeavyOrSuper() {
      return this.weightClass === HEAVY_LETTER || this.weightClass === SUPER_LETTER;
    }
    /**
     * Returns the minimal distance that is required to a previous aircraft before another aircraft is allowed to use the runway.
     *
     * @for AircraftTypeDefinitionModel
     * @method calculateSameRunwaySeparationDistanceInFeet
     * @param previousTypeModel {AircraftTypeDefinitionModel} the aircraft type that used the runway before us.
     * @returns {number} distance in feet
     */

  }, {
    key: "calculateSameRunwaySeparationDistanceInFeet",
    value: function calculateSameRunwaySeparationDistanceInFeet(previousTypeModel) {
      if (previousTypeModel.isSameRunwaySeparationCatThree()) {
        return _airportConstants.AIRPORT_CONSTANTS.SRS_REDUCED_MINIMA_FEET.CAT3;
      }

      switch (this.category.srs) {
        case 1:
          return _airportConstants.AIRPORT_CONSTANTS.SRS_REDUCED_MINIMA_FEET.CAT1;

        case 2:
          return _airportConstants.AIRPORT_CONSTANTS.SRS_REDUCED_MINIMA_FEET.CAT2;

        default:
          return _airportConstants.AIRPORT_CONSTANTS.SRS_REDUCED_MINIMA_FEET.CAT3;
      }
    }
    /**
     * Returns true if srs cat 3 is required
     *
     * @for AircraftTypeDefinitionModel
     * @method isSameRunwaySeparationCatThree
     * @returns true if srs cat 3 is required
     */

  }, {
    key: "isSameRunwaySeparationCatThree",
    value: function isSameRunwaySeparationCatThree() {
      return typeof this.category.srs === 'undefined' || this.category.srs === 3;
    }
    /**
     * Get the weight classifier for an aircraft's callsign, as spoken over the radio
     *
     * @for AircraftTypeDefinitionModel
     * @method getRadioWeightClass
     * @return {string}
     */

  }, {
    key: "getRadioWeightClass",
    value: function getRadioWeightClass() {
      if (this.weightClass === HEAVY_LETTER) {
        return 'heavy';
      }

      if (this.weightClass === SUPER_LETTER) {
        return 'super';
      }

      return '';
    }
  }]);

  return AircraftTypeDefinitionModel;
}(_BaseModel2["default"]);

exports["default"] = AircraftTypeDefinitionModel;

},{"../base/BaseModel":295,"../constants/airportConstants":305,"../constants/globalConstants":310,"../utilities/validatorUtilities":392}],268:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _find2 = _interopRequireDefault(require("lodash/find"));

var _findLast2 = _interopRequireDefault(require("lodash/findLast"));

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _RouteModel = _interopRequireDefault(require("./RouteModel"));

var _AirportController = _interopRequireDefault(require("../../airport/AirportController"));

var _NavigationLibrary = _interopRequireDefault(require("../../navigationLibrary/NavigationLibrary"));

var _RunwayModel = _interopRequireDefault(require("../../airport/runway/RunwayModel"));

var _aircraftConstants = require("../../constants/aircraftConstants");

var _globalConstants = require("../../constants/globalConstants");

var _routeConstants = require("../../constants/routeConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Provides methods to create, update or replace a flightPlan and the legs
 * and waypoints that make up that flightPlan.
 *
 * This class is concerned only about maintaining the flightPlan, which is
 * really just the collection of `LegModels` and their respective
 * `WaypointModel` objects.
 *
 * This class should always be instantiated from an `AircraftModel` and
 * always instantiated from some form of `spawnPatternModel` using some kind of
 * routeString.
 *
 * This class is always instantiated with a routeString and any changes to the
 * flightPlan must happen with a routeString. For every fix/waypoint called out
 * in a routeString, there must exist a fix in the airport.json file.
 *
 *
 * RouteString examples and the terms used to describe them:
 * - directRouteString: `COWBY`
 *   A directRouteString will equate to a `LegModel` with a single `WaypointModel`.
 *
 * - holdRouteString: `@COWBY`
 *   A holdRouteString will equate to a `LegModel` with a single `WaypointModel` that has holding specifications defined
 *
 * - procedureRouteString: `KLAS.COWBY6.DRK`
 *   A procedureRouteString will equate to a single `LegModel` and possibly many waypoints for the individual waypoints
 *   that make up a procedureRoute (sid/star).
 *
 *
 * - simpleRouteString: `COWBY..DRK`
 * - complexRouteString: `COWBY..@BIKKR..DAG.KEPEC3.KLAS`
 *
 * When working with a complexRouteString, you will also see terms like `directRouteSegment`, `procedureRouteSegment`
 * or `holdRouteSegment`. When the word segment is involved, that means that particular segment is part of a
 * larger, likely complex, routeString.
 *
 *
 * @class Fms
 */
var Fms =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param aircraftInitProps {object}
   */
  function Fms(aircraftInitProps) {
    _classCallCheck(this, Fms);

    if (!(0, _isObject2["default"])(aircraftInitProps) || (0, _isEmpty2["default"])(aircraftInitProps)) {
      throw new TypeError('Invalid aircraftInitProps passed to Fms');
    }
    /**
     * Airport the aircraft arrives at
     *
     * @for Fms
     * @property arrivalAirportModel
     * @type {AirportModel}
     */


    this.arrivalAirportModel = null;
    /**
     * Runway used at arrival airport
     *
     * @for Fms
     * @property arrivalRunwayModel
     * @type {RunwayModel}
     */

    this.arrivalRunwayModel = null;
    /**
     * Current flight phase of an aircraft
     *
     * @property currentPhase
     * @type {string}
     * @default ''
     */

    this.currentPhase = '';
    /**
     * Airport the aircraft departs from
     *
     * @for Fms
     * @property departureAirportModel
     * @type {AirportModel}
     */

    this.departureAirportModel = null;
    /**
     * Runway used at departure airport
     *
     * @for Fms
     * @property departureRunwayModel
     * @type {RunwayModel}
     */

    this.departureRunwayModel = null; // TODO: This value should NOT be changed 'as ATC amends it'

    /**
     * Altitude expected for this flight. Will change as ATC amends it.
     *
     * @property flightPlanAltitude
     * @type {number}
     * @default INVALID_NUMBER
     */

    this.flightPlanAltitude = _globalConstants.INVALID_NUMBER;
    /**
     * Flight plan route for this aircraft, containing lateral and vertical guidance
     *
     * @for Fms
     * @property _routeModel
     * @type {RouteModel}
     * @private
     */

    this._routeModel = null;
    this.init(aircraftInitProps);
  }
  /**
   * The active Leg in the `legCollection`
   *
   * Assumed to ALWAYS be the first `LegModel` in the `legCollection`
   *
   * @property currentLeg
   * @type {LegModel}
   */


  _createClass(Fms, [{
    key: "init",
    // ------------------------------ LIFECYCLE ------------------------------

    /**
     * Initialize instance properties
     *
     * @for Fms
     * @method init
     * @param aircraftInitProps {object}
     * @chainable
     */
    value: function init(aircraftInitProps) {
      var altitude = aircraftInitProps.altitude,
          category = aircraftInitProps.category,
          destination = aircraftInitProps.destination,
          model = aircraftInitProps.model,
          nextFix = aircraftInitProps.nextFix,
          origin = aircraftInitProps.origin,
          routeString = aircraftInitProps.routeString;
      this._routeModel = new _RouteModel["default"](routeString);

      this._verifyRouteContainsMultipleWaypoints();

      this._initializeFlightPhaseForCategory(category);

      this._initializeDepartureAirport(origin);

      this._initializeDepartureRunway();

      this._initializeArrivalAirport(destination);

      this._initializeArrivalRunway();

      this._initializeFlightPlanAltitude(altitude, category, model);

      this._initializePositionInRouteToBeginAtFixName(nextFix, category);

      return this;
    }
    /**
     * Reset instance properties
     *
     * @for LegModel
     * @method reset
     * @chainable
     */

  }, {
    key: "reset",
    value: function reset() {
      this.arrivalAirportModel = null;
      this.arrivalRunwayModel = null;
      this.currentPhase = '';
      this.departureAirportModel = null;
      this.departureRunwayModel = null;
      this.flightPlanAltitude = _globalConstants.INVALID_NUMBER;
      this._routeModel = null;
      return this;
    }
    /**
     * Initialize `#arrivalAirportModel`
     *
     * @for Fms
     * @method _initializeArrivalAirport
     * @param destinationIcao {string} ICAO identifier specified by spawn pattern
     * @private
     */

  }, {
    key: "_initializeArrivalAirport",
    value: function _initializeArrivalAirport(destinationIcao) {
      if (destinationIcao === '') {
        return;
      }

      this.arrivalAirportModel = _AirportController["default"].airport_get(destinationIcao);
    }
    /**
     * Initialize `#arrivalRunwayModel`
     *
     * @for Fms
     * @method _initializeArrivalRunway
     * @private
     */

  }, {
    key: "_initializeArrivalRunway",
    value: function _initializeArrivalRunway() {
      if (!this.arrivalAirportModel) {
        return;
      }

      var arrivalRunwayName = this._routeModel.getArrivalRunwayName();

      if (!arrivalRunwayName) {
        this.setArrivalRunway(this.arrivalAirportModel.arrivalRunwayModel);
        return;
      }

      var arrivalRunwayModel = this.arrivalAirportModel.getRunway(arrivalRunwayName);
      this.setArrivalRunway(arrivalRunwayModel);
    }
    /**
     * Initialize `#departureAirportModel`
     *
     * @for Fms
     * @method _initializeDepartureAirport
     * @param originIcao {string} ICAO identifier specified by spawn pattern
     * @private
     */

  }, {
    key: "_initializeDepartureAirport",
    value: function _initializeDepartureAirport(originIcao) {
      if (originIcao === '') {
        return;
      }

      this.departureAirportModel = _AirportController["default"].airport_get(originIcao);
    }
    /**
     * Initialize `#departureRunwayModel`
     *
     * @for Fms
     * @method _initializeDepartureRunway
     * @private
     */

  }, {
    key: "_initializeDepartureRunway",
    value: function _initializeDepartureRunway() {
      if (!this.departureAirportModel) {
        return;
      }

      var departureRunwayName = this._routeModel.getDepartureRunwayName();

      if (!departureRunwayName) {
        return this.setDepartureRunway(this.departureAirportModel.departureRunwayModel);
      }

      var departureRunwayModel = this.departureAirportModel.getRunway(departureRunwayName);
      this.setDepartureRunway(departureRunwayModel);
    }
    /**
     * Initialize `#currentPhase` as appropriate based on the spawn category
     *
     * @for Fms
     * @method _initializeFlightPhaseForCategory
     * @param category {string}
     * @private
     */

  }, {
    key: "_initializeFlightPhaseForCategory",
    value: function _initializeFlightPhaseForCategory(category) {
      switch (category) {
        case _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL:
        case _aircraftConstants.FLIGHT_CATEGORY.OVERFLIGHT:
          return this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.CRUISE);

        case _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE:
          return this.setFlightPhase(_aircraftConstants.FLIGHT_PHASE.APRON);

        default:
          throw new TypeError("Expected known spawn pattern category, but received \"".concat(category, "\""));
      }
    }
    /**
     * Initialize `#flightPlanAltitude`
     *
     * @for Fms
     * @method _initializeFlightPlanAltitude
     * @param altitude {number}
     * @param category {string} one of `FLIGHT_CATEGORY` enum
     * @param model {AircraftTypeDefinitionModel}
     * @private
     */

  }, {
    key: "_initializeFlightPlanAltitude",
    value: function _initializeFlightPlanAltitude(altitude, category, model) {
      this.flightPlanAltitude = altitude;

      if (category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
        this.flightPlanAltitude = model.ceiling;
      }
    }
    /**
     * Skip ahead to the first waypoint a freshly created FMS should be going to
     *
     * This method is available because we have the ability to spawn aircraft
     * in "the middle" of any route, rather than requiring them to fly their
     * route from the beginning. This way, we have the choice to place the aircraft
     * wherever we want along the route without having to change its contents.
     *
     * This method takes an argument that specifies which fix to go to after spawn,
     * and if not specified, the FMS will target the second fix (because they are)
     * spawned AT the first fix.
     *
     * @for Fms
     * @method _initializePositionInRouteToBeginAtFixName
     * @param fixName {string}
     * @private
     */

  }, {
    key: "_initializePositionInRouteToBeginAtFixName",
    value: function _initializePositionInRouteToBeginAtFixName(fixName, category) {
      if (category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
        return;
      }

      if ((0, _isNil2["default"])(fixName)) {
        return this.moveToNextWaypoint();
      }

      if (!this._routeModel.hasWaypointName(fixName)) {
        throw new TypeError("Expected initial fix to be in flight plan route, but received '".concat(fixName, "'"));
      }

      this.skipToWaypointName(fixName);
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Mark the specified waypoint as a hold waypoint
     *
     * @for Fms
     * @method activateHoldForWaypointName
     * @param waypointName {string} name of waypoint in route
     * @param holdParameters {object}
     * @param fallbackInboundHeading {number} an optional inboundHeading that is used if no default is available
     * @returns {array} [success of operation, readback-error OR holdParameters ]
     */

  }, {
    key: "activateHoldForWaypointName",
    value: function activateHoldForWaypointName(waypointName, holdParameters) {
      var fallbackInboundHeading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (!this._routeModel.hasWaypointName(waypointName)) {
        // force lower-case in verbal readback to get speech synthesis to pronounce the fix instead of spelling it
        return [false, {
          log: "unable to hold at ".concat(waypointName.toUpperCase(), "; it is not on our route!"),
          say: "unable to hold at ".concat(waypointName.toLowerCase(), "; it is not on our route!")
        }];
      }

      return [true, this._routeModel.activateHoldForWaypointName(waypointName, holdParameters, fallbackInboundHeading)];
    }
    /**
     * Apply the specified route, and as applicable, merge it with the current route
     *
     * @for Fms
     * @method applyPartialRouteAmendment
     * @param routeString {tring}  route string in the form of `entry.procedure.airport`
     * @return {array}             [success of operation, readback]
     */

  }, {
    key: "applyPartialRouteAmendment",
    value: function applyPartialRouteAmendment(routeString) {
      var nextRouteModel;

      try {
        nextRouteModel = new _RouteModel["default"](routeString);
      } catch (error) {
        console.error(error);
        return [false, "requested route of \"".concat(routeString.toUpperCase(), "\" is invalid")];
      }

      return this._routeModel.absorbRouteModel(nextRouteModel);
    }
    /**
     * Return the waypoint that matches the provided name
     *
     * @for Fms
     * @method findWaypoiont
     * @param waypointName {string} name of the waypoint
     * @return {WaypointModel}
     */

  }, {
    key: "findWaypoint",
    value: function findWaypoint(waypointName) {
      var name = waypointName.toUpperCase();
      return (0, _find2["default"])(this.waypoints, function (waypoint) {
        return waypoint.name === name;
      });
    }
    /**
     * Return the next waypoint having an #altitudeMaximum equal to or less than the specified value
     *
     * This is helpful to see only future waypoints for which a particular altitude is
     * considered NOT to be compliant. This allows us to focus which waypoints the aircraft
     * will need to adjust altitude for, even if they are many waypoints in the future.
     *
     * @for Fms
     * @method findNextWaypointWithMaximumAltitudeAtOrBelow
     * @param altitude {number}
     * @return {WaypointModel}
     */

  }, {
    key: "findNextWaypointWithMaximumAltitudeAtOrBelow",
    value: function findNextWaypointWithMaximumAltitudeAtOrBelow(altitude) {
      return (0, _find2["default"])(this.waypoints, function (waypointModel) {
        return waypointModel.hasMaximumAltitudeAtOrBelow(altitude);
      });
    }
    /**
     * Return the next waypoint having an #altitudeMaximum restriction
     *
     * @for Fms
     * @method findNextWaypointWithMaximumAltitudeRestriction
     * @return {WaypointModel}
     */

  }, {
    key: "findNextWaypointWithMaximumAltitudeRestriction",
    value: function findNextWaypointWithMaximumAltitudeRestriction() {
      return (0, _find2["default"])(this.waypoints, function (waypointModel) {
        return waypointModel.hasAltiudeMaximumRestriction;
      });
    }
    /**
     * Return the next waypoint having a #speedMaximum equal to or less than the specified value
     *
     * This is helpful to see only future waypoints for which a particular speed is
     * considered NOT to be compliant. This allows us to focus which waypoints the aircraft
     * will need to adjust speed for, even if they are many waypoints in the future.
     *
     * @for Fms
     * @method findNextWaypointWithMaximumSpeedAtOrBelow
     * @param speed {number}
     * @return {WaypointModel}
     */

  }, {
    key: "findNextWaypointWithMaximumSpeedAtOrBelow",
    value: function findNextWaypointWithMaximumSpeedAtOrBelow(speed) {
      return (0, _find2["default"])(this.waypoints, function (waypointModel) {
        return waypointModel.hasMaximumSpeedAtOrBelow(speed);
      });
    }
    /**
     * Return the next waypoint having an #altitudeMinimum equal to or greater than the specified value
     *
     * This is helpful to see only future waypoints for which a particular altitude is
     * considered NOT to be compliant. This allows us to focus which waypoints the aircraft
     * will need to adjust altitude for, even if they are many waypoints in the future.
     *
     * @for Fms
     * @method findNextWaypointWithMinimumAltitudeAtOrAbove
     * @param altitude {number}
     * @return {WaypointModel}
     */

  }, {
    key: "findNextWaypointWithMinimumAltitudeAtOrAbove",
    value: function findNextWaypointWithMinimumAltitudeAtOrAbove(altitude) {
      return (0, _find2["default"])(this.waypoints, function (waypointModel) {
        return waypointModel.hasMinimumAltitudeAtOrAbove(altitude);
      });
    }
    /**
     * Return the next waypoint having an #altitudeMinimum restriction
     *
     * @for Fms
     * @method findNextWaypointWithMinimumAltitudeRestriction
     * @return {WaypointModel}
     */

  }, {
    key: "findNextWaypointWithMinimumAltitudeRestriction",
    value: function findNextWaypointWithMinimumAltitudeRestriction() {
      return (0, _find2["default"])(this.waypoints, function (waypointModel) {
        return waypointModel.hasAltiudeMinimumRestriction;
      });
    }
    /**
     * Return the next waypoint having a #speedMinimum equal to or greater than the specified value
     *
     * This is helpful to see only future waypoints for which a particular speed is
     * considered NOT to be compliant. This allows us to focus which waypoints the aircraft
     * will need to adjust speed for, even if they are many waypoints in the future.
     *
     * @for Fms
     * @method findNextWaypointWithMinimumSpeedAtOrAbove
     * @param speed {number}
     * @return {WaypointModel}
     */

  }, {
    key: "findNextWaypointWithMinimumSpeedAtOrAbove",
    value: function findNextWaypointWithMinimumSpeedAtOrAbove(speed) {
      return (0, _find2["default"])(this.waypoints, function (waypointModel) {
        return waypointModel.hasMinimumSpeedAtOrAbove(speed);
      });
    }
    /**
     * Return an array of waypoints in the flight plan that have altitude restrictions
     *
     * @for Fms
     * @method getAltitudeRestrictedWaypoints
     * @return {array<WaypointModel>}
     */

  }, {
    key: "getAltitudeRestrictedWaypoints",
    value: function getAltitudeRestrictedWaypoints() {
      return this._routeModel.getAltitudeRestrictedWaypoints();
    }
    /**
     * Returns the lowest bottom altitude of any `LegModel` in the `#_legCollection`
     *
     * @for Fms
     * @method getBottomAltitude
     * @return {number}
     */

  }, {
    key: "getBottomAltitude",
    value: function getBottomAltitude() {
      return this._routeModel.getBottomAltitude();
    }
    /**
     * Get the full flight plan route string with legs separated by spaces
     *
     * @for Fms
     * @method getFullRouteStringWithoutAirportsWithSpaces
     * @return {string}
     */

  }, {
    key: "getFullRouteStringWithoutAirportsWithSpaces",
    value: function getFullRouteStringWithoutAirportsWithSpaces() {
      return this._routeModel.getFullRouteStringWithoutAirportsWithSpaces();
    }
    /**
     * Return the first fix in a flightPlan or the exit fix of
     * the current SID procedure
     *
     * Primarily used for aircraft dataBlock
     *
     * @for Fms
     * @method getFlightPlanEntry
     * @returns {string} First fix in flightPlan or exit fix of SID
     */

  }, {
    key: "getFlightPlanEntry",
    value: function getFlightPlanEntry() {
      return this._routeModel.getFlightPlanEntry();
    }
    /**
     * Get the position of the next waypoint in the flight plan
     *
     * Currently only used in `calculateTurnInitiationDistance()` helper function
     *
     * @for Fms
     * @method getNextWaypointPositionModel
     * @return waypointPosition {StaticPositionModel}
     */

  }, {
    key: "getNextWaypointPositionModel",
    value: function getNextWaypointPositionModel() {
      return this.nextWaypoint.positionModel;
    }
    /**
     * Return an array of waypoints in the flight plan that have altitude or speed restrictions
     *
     * @for Fms
     * @method getRestrictedWaypoints
     * @return {array<WaypointModel>}
     */

  }, {
    key: "getRestrictedWaypoints",
    value: function getRestrictedWaypoints() {
      return this.waypoints.filter(function (waypoint) {
        return waypoint.hasRestriction;
      });
    }
    /**
     * Get the flight plan route string in dot notation
     *
     * @for Fms
     * @method getRouteString
     * @return {string}
     */

  }, {
    key: "getRouteString",
    value: function getRouteString() {
      return this._routeModel.getRouteString();
    }
    /**
     * Get the flight plan route string with legs separated by spaces
     *
     * This is primarily meant for use in the `StripViewModel`.
     *
     * @for Fms
     * @method getRouteStringWithSpaces
     * @return {string}
     */

  }, {
    key: "getRouteStringWithSpaces",
    value: function getRouteStringWithSpaces() {
      return this._routeModel.getRouteStringWithSpaces();
    }
    /**
     * Facade for #_routeModel.getSidIcao
     *
     * @for Fms
     * @method getSidIcao
     * @return {string}
     */

  }, {
    key: "getSidIcao",
    value: function getSidIcao() {
      return this._routeModel.getSidIcao();
    }
    /**
     * Facade for #_routeModel.getSidName
     *
     * @for Fms
     * @method getSidName
     * @return {string}
     */

  }, {
    key: "getSidName",
    value: function getSidName() {
      return this._routeModel.getSidName();
    }
    /**
     * Facade for #_routeModel.getInitialClimbClearance
     *
     * @for Fms
     * @method getInitialClimbClearance
     * @return {number}
     */

  }, {
    key: "getInitialClimbClearance",
    value: function getInitialClimbClearance() {
      return this._routeModel.getInitialClimbClearance();
    }
    /**
     * Return an array of waypoints in the flight plan that have speed restrictions
     *
     * @for Fms
     * @method getSpeedRestrictedWaypoints
     * @return {array<WaypointModel>}
     */

  }, {
    key: "getSpeedRestrictedWaypoints",
    value: function getSpeedRestrictedWaypoints() {
      return this.waypoints.filter(function (waypoint) {
        return waypoint.hasSpeedRestriction;
      });
    }
    /**
     * Returns the highest top altitude of any `LegModel` in the `#_legCollection`
     *
     * @for LegModel
     * @method getTopAltitude
     * @return {number}
     */

  }, {
    key: "getTopAltitude",
    value: function getTopAltitude() {
      return this._routeModel.getTopAltitude();
    }
    /**
     * Return whether the route contains a waypoint after the currently active one
     *
     * @for Fms
     * @method hasNextWaypoint
     * @return {boolean}
     */

  }, {
    key: "hasNextWaypoint",
    value: function hasNextWaypoint() {
      return this._routeModel.hasNextWaypoint();
    }
    /**
     * Return whether the route contains a waypoint with the specified name
     *
     * @for Fms
     * @method hasWaypointName
     * @param waypointName {string}
     * @return {boolean}
     */

  }, {
    key: "hasWaypointName",
    value: function hasWaypointName(waypointName) {
      return this._routeModel.hasWaypointName(waypointName);
    }
    /**
     * Returns whether this is an arrival to an airport we control
     *
     * @for Fms
     * @method isArrival
     * @return {boolean}
     */

  }, {
    key: "isArrival",
    value: function isArrival() {
      return !(0, _isNil2["default"])(this.arrivalAirportModel);
    }
    /**
     * Returns whether this is a departure from an airport we control
     *
     * @for Fms
     * @method isDeparture
     * @return {boolean}
     */

  }, {
    key: "isDeparture",
    value: function isDeparture() {
      return !(0, _isNil2["default"])(this.departureAirportModel);
    }
    /**
     * Returns whether this is an overflight
     *
     * @for Fms
     * @method isDeparture
     * @return {boolean}
     */

  }, {
    key: "isOverflight",
    value: function isOverflight() {
      return !this.isArrival() && !this.isDeparture;
    }
    /**
     * Facade for `#_routeModel.isRunwayModelValidForSid()`
     *
     * Other classes will not have access to the `#_routeModel`, but can use this
     * facade to determine whether or not a given runway assignment is allowable,
     * given the departure procedure in the `#_routeModel`.
     *
     * @for Fms
     * @method isRunwayModelValidForSid
     * @param runwayModel {RunwayModel}
     * @return {boolean}
     */

  }, {
    key: "isRunwayModelValidForSid",
    value: function isRunwayModelValidForSid(runwayModel) {
      return this._routeModel.isRunwayModelValidForSid(runwayModel);
    }
    /**
     * Facade for `#_routeModel.isRunwayModelValidForStar()`
     *
     * Other classes will not have access to the `#_routeModel`, but can use this
     * facade to determine whether or not a given runway assignment is allowable,
     * given the arrival procedure in the `#_routeModel`.
     *
     * @for Fms
     * @method isRunwayModelValidForStar
     * @param runwayModel {RunwayModel}
     * @return {boolean}
     */

  }, {
    key: "isRunwayModelValidForStar",
    value: function isRunwayModelValidForStar(runwayModel) {
      return this._routeModel.isRunwayModelValidForStar(runwayModel);
    }
    /**
     * Move to the next possible waypoint
     *
     * This could be the next waypoint in the current leg,
     * or the first waypoint in the next leg.
     *
     * @for LegModel
     * @method moveToNextWaypoint
     */

  }, {
    key: "moveToNextWaypoint",
    value: function moveToNextWaypoint() {
      return this._routeModel.moveToNextWaypoint();
    }
    /**
     * Find the arrival procedure (if it exists) within the `#legCollection` and
     * reset it with a new arrival procedure.
     *
     * This method does not remove any `LegModel`s. It instead finds and updates a
     * `LegModel` with a new routeString. If a `LegModel` without a arrival
     * procedure cannot be found, then we create a new `LegModel` and place it
     * at the end of the `#legCollection`.
     *
     * @for Fms
     * @method replaceArrivalProcedure
     * @param routeString {string}
     * @return {array<boolean, string>}
     */

  }, {
    key: "replaceArrivalProcedure",
    value: function replaceArrivalProcedure(routeString) {
      var routeStringElements = routeString.toUpperCase().split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER);

      if (routeStringElements.length !== 3) {
        return [false, 'arrival procedure format not understood'];
      }

      var procedureId = routeStringElements[1];

      if (!_NavigationLibrary["default"].hasProcedure(procedureId)) {
        return [false, "unknown procedure \"".concat(procedureId, "\"")];
      }

      var wasSuccessful = this._routeModel.replaceArrivalProcedure(routeString);

      if (wasSuccessful) {
        this._updateArrivalRunwayFromRoute();

        return [true, ''];
      }

      return [false, "route of \"".concat(routeString, "\" is not valid")];
    }
    /**
     * Replace departure procedure and departure runway
     *
     * @for Fms
     * @method replaceDepartureProcedure
     * @param routeString {string}
     * @return {boolean}
     */

  }, {
    key: "replaceDepartureProcedure",
    value: function replaceDepartureProcedure(routeString, airportIcao) {
      var routeStringElements = routeString.toUpperCase().split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER);

      if (routeStringElements.length > 3) {
        return [false, 'departure procedure format not understood'];
      }

      var procedureId = routeStringElements[0];

      if (routeStringElements.length === 3) {
        // if the runway IS specified in the route string
        procedureId = routeStringElements[1];
      }

      var sidModel = _NavigationLibrary["default"].getProcedure(procedureId);

      if ((0, _isNil2["default"])(sidModel)) {
        return [false, "unknown procedure \"".concat(procedureId, "\"")];
      }

      if (routeStringElements.length === 1) {
        // RouteString looks like PROC
        var exitPoint = (0, _findLast2["default"])(this.waypoints, function (waypointModel) {
          return sidModel.hasExit(waypointModel.name);
        });

        if (!exitPoint) {
          return [false, "the ".concat(procedureId.toUpperCase(), " departure doesn't have an exit along our route")];
        }

        routeStringElements.push(exitPoint.name);
      }

      if (routeStringElements.length === 2) {
        // RouteString looks like PROC.EXIT
        var expectedRunwayModel = this.departureRunwayModel;
        var entryPoint = "".concat(airportIcao.toUpperCase()).concat(expectedRunwayModel.name);

        if (!sidModel.hasEntry(entryPoint)) {
          entryPoint = sidModel.getFirstEntryPoint();

          if ((0, _isEmpty2["default"])(entryPoint)) {
            throw new TypeError("the '".concat(procedureId, "' departure has no valid entry points"));
          }
        }

        routeStringElements.unshift(entryPoint);
      }

      var nextRouteString = routeStringElements.join(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER);

      var readback = this._routeModel.replaceDepartureProcedure(nextRouteString);

      if (readback[0]) {
        this._updateDepartureRunwayFromRoute();
      }

      return readback;
    } // TODO: we may need to update the runway in this method

    /**
     * Replace the current route with an entirely new one
     *
     * If route contains the same waypoint as the current waypoint, skip to that waypoint
     * and continue along the new route. This is a somewhat questionable strategy, but
     * has the advantage of supporting reroutes done in the middle of the flight,
     * whereas without this approach, the aircraft would turn around to the very first
     * waypoint as soon as they are rerouted.
     *
     * @for Fms
     * @method replaceFlightPlanWithNewRoute
     * @param routeString {string}
     * @return {boolean} whether the operation was successful
     */

  }, {
    key: "replaceFlightPlanWithNewRoute",
    value: function replaceFlightPlanWithNewRoute(routeString) {
      var currentWaypointName = this.currentWaypoint.name;
      var nextRouteModel;

      try {
        nextRouteModel = new _RouteModel["default"](routeString);
      } catch (error) {
        console.error(error);
        var _readback = {};
        _readback.log = "requested route of \"".concat(routeString, "\" is invalid");
        _readback.say = 'that route is invalid';
        return [false, _readback];
      }

      this._routeModel = nextRouteModel;
      this.skipToWaypointName(currentWaypointName); // Build readback

      var readback = {};
      readback.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
      readback.say = 'rerouting as requested';
      return [true, readback];
    }
    /**
     * Verify and then set the value of `#arrivalRunwayModel`
     *
     * @for Fms
     * @method setArrivalRunway
     * @param nextRunwayModel {RunwayModel}
     */

  }, {
    key: "setArrivalRunway",
    value: function setArrivalRunway(nextRunwayModel) {
      if (!(nextRunwayModel instanceof _RunwayModel["default"])) {
        throw new TypeError("Expected instance of RunwayModel, but received ".concat(nextRunwayModel));
      }

      this.arrivalRunwayModel = nextRunwayModel;
    }
    /**
     * Verify and then set the value of `#departureRunwayModel`
     *
     * @for Fms
     * @method setDepartureRunway
     * @param runwayModel {RunwayModel}
     */

  }, {
    key: "setDepartureRunway",
    value: function setDepartureRunway(runwayModel) {
      if (!(runwayModel instanceof _RunwayModel["default"])) {
        throw new TypeError("Expected instance of RunwayModel, but received ".concat(runwayModel));
      }

      if (this.departureRunwayModel && this.departureRunwayModel.name === runwayModel.name) {
        return;
      }

      this.departureRunwayModel = runwayModel;

      this._routeModel.updateSidLegForDepartureRunwayModel(runwayModel);
    }
    /**
     * Set the `#currentPhase`
     *
     * this value is used to determine how to calculate and aircraft's next
     * altitude, heading and speed.
     *
     * @for Fms
     * @method setFlightPhase
     * @param phase {string}
     */

  }, {
    key: "setFlightPhase",
    value: function setFlightPhase(phase) {
      if (!(0, _includes2["default"])(_aircraftConstants.FLIGHT_PHASE, phase)) {
        throw new TypeError("Expected known flight phase, but received '".concat(phase, "'"));
      }

      this.currentPhase = phase;
    }
    /**
     * Fascade
     *
     * @for Fms
     * @method skipToWaypointName
     * @param waypointName {string}
     */

  }, {
    key: "skipToWaypointName",
    value: function skipToWaypointName(waypointName) {
      return this._routeModel.skipToWaypointName(waypointName);
    } // ------------------------------ PRIVATE ------------------------------
    // /**
    // * Build a `LegModel` instance that contains a `WaypointModel` with hold properties
    // *
    // * @for Fms
    // * @method _createLegWithHoldWaypoint
    // * @param waypointProps {object}
    // * @return legModel {LegModel}
    // */
    // _createLegWithHoldWaypoint(waypointProps) {
    //     const legModel = new LegModel(
    //         waypointProps.name,
    //         this.currentRunwayName,
    //         this.currentPhase,
    //         waypointProps
    //     );
    //
    //     return legModel;
    // }

    /**
     * Ensure the STAR leg has the specified arrival runway as the exit point
     *
     * @for Fms
     * @method updateStarLegForArrivalRunway
     * @param nextRunwayModel {RunwayModel}
     * @return {array} [success of operation, response]
     */

  }, {
    key: "updateStarLegForArrivalRunway",
    value: function updateStarLegForArrivalRunway(nextRunwayModel) {
      var currentArrivalRunway = this.arrivalRunwayModel;

      if (!(nextRunwayModel instanceof _RunwayModel["default"])) {
        throw new TypeError("Expected instance of RunwayModel, but received ".concat(nextRunwayModel));
      }

      if (currentArrivalRunway && currentArrivalRunway.name === nextRunwayModel.name) {
        var _readback2 = {};
        _readback2.log = "expect Runway ".concat(nextRunwayModel.name);
        _readback2.say = "expect Runway ".concat(nextRunwayModel.getRadioName());
        return [true, _readback2];
      }

      if (!this._routeModel.isRunwayModelValidForStar(nextRunwayModel)) {
        var _readback3 = {};
        _readback3.log = "unable, according to our charts, Runway ".concat(nextRunwayModel.name, " is ") + "not valid for the ".concat(this._routeModel.getStarIcao(), " arrival, expecting ") + "Runway ".concat(currentArrivalRunway.name, " instead");
        _readback3.say = "unable, according to our charts, Runway ".concat(nextRunwayModel.getRadioName(), " ") + "is not valid for the ".concat(this._routeModel.getStarName(), " arrival, expecting ") + "Runway ".concat(currentArrivalRunway.getRadioName(), " instead");
        return [false, _readback3];
      }

      this._routeModel.updateStarLegForArrivalRunwayModel(nextRunwayModel);

      this.setArrivalRunway(nextRunwayModel);
      var readback = {};
      readback.log = "expecting Runway ".concat(nextRunwayModel.name);
      readback.say = "expecting Runway ".concat(nextRunwayModel.getRadioName());
      return [true, readback];
    }
    /**
     * Update the expected arrival runway based on the STAR's exit point runway
     *
     * @for Fms
     * @method _updateArrivalRunwayFromRoute
     */

  }, {
    key: "_updateArrivalRunwayFromRoute",
    value: function _updateArrivalRunwayFromRoute() {
      var arrivalRunwayModel = this._routeModel.getArrivalRunwayModel();

      if ((0, _isNil2["default"])(arrivalRunwayModel)) {
        console.error('Expected route to have a valid arrival runway');
        return;
      }

      this.setArrivalRunway(arrivalRunwayModel);
    }
    /**
     * Update the expected departure runway based on the SID's entry point runway
     *
     * @for Fms
     * @method _updateArrivalRunwayFromRoute
     */

  }, {
    key: "_updateDepartureRunwayFromRoute",
    value: function _updateDepartureRunwayFromRoute() {
      var departureRunwayModel = this._routeModel.getDepartureRunwayModel();

      if ((0, _isNil2["default"])(departureRunwayModel)) {
        console.error('Expected route to have a valid departure runway');
        return;
      }

      this.setDepartureRunway(departureRunwayModel);
    }
    /**
     * Verify that this FMS's route contains at least two waypoints, or throw an error
     *
     * This is an expectation on spawn so we can point the aircraft somewhere,
     * but OTHER than on spawn, there is no reason an aircraft cannot be assigned
     * a single-fix route (such as "forget everything else, just go direct to the airport!").
     *
     * @for Fms
     * @method _verifyRouteContainsMultipleWaypoints
     * @private
     */

  }, {
    key: "_verifyRouteContainsMultipleWaypoints",
    value: function _verifyRouteContainsMultipleWaypoints() {
      if (this.waypoints.length < 2) {
        throw new TypeError('Expected flight plan route to have at least two ' + "waypoints, but only found ".concat(this.waypoints.length, " waypoints"));
      }
    }
  }, {
    key: "currentLeg",
    get: function get() {
      return this._routeModel.currentLeg;
    }
    /**
     * The active waypoint an aircraft is flying towards
     *
     * Assumed to ALWAYS be the first `WaypointModel` in the `currentLeg`
     *
     * @property currentWaypoint
     * @type {WaypointModel}
     */

  }, {
    key: "currentWaypoint",
    get: function get() {
      return this._routeModel.currentWaypoint;
    }
    /**
     * Return the next waypoint which has an altitude restriction
     *
     * @for Fms
     * @property nextAltitudeRestrictedWaypoint
     * @type {WaypointModel}
     */

  }, {
    key: "nextAltitudeRestrictedWaypoint",
    get: function get() {
      var waypoints = this.getAltitudeRestrictedWaypoints();
      return waypoints[0];
    }
    /**
     * Return the next waypoint which has an "AT" altitude restriction
     *
     * @for Fms
     * @property nextHardAltitudeRestrictedWaypoint
     * @type {WaypointModel}
     */

  }, {
    key: "nextHardAltitudeRestrictedWaypoint",
    get: function get() {
      var waypoints = this.getAltitudeRestrictedWaypoints().filter(function (waypoint) {
        return waypoint.altitudeMaximum === waypoint.altitudeMinimum;
      });
      return waypoints[0];
    }
    /**
     * Return the next waypoint which has an "AT" speed restriction
     *
     * @for Fms
     * @property nextHardSpeedRestrictedWaypoint
     * @type {WaypointModel}
     */

  }, {
    key: "nextHardSpeedRestrictedWaypoint",
    get: function get() {
      var waypoints = this.getSpeedRestrictedWaypoints().filter(function (waypoint) {
        return waypoint.speedMaximum === waypoint.speedMinimum;
      });
      return waypoints[0];
    }
    /**
     * Return the next waypoint which has an altitude or speed restriction
     *
     * @for Fms
     * @property nextRestrictedWaypoint
     * @type {WaypointModel}
     */

  }, {
    key: "nextRestrictedWaypoint",
    get: function get() {
      var waypoints = this.getRestrictedWaypoints();
      return waypoints[0];
    }
    /**
     * Return the next waypoint which has a speed restriction
     *
     * @for Fms
     * @property nextSpeedRestrictedWaypoint
     * @type {WaypointModel}
     */

  }, {
    key: "nextSpeedRestrictedWaypoint",
    get: function get() {
      var waypoints = this.getSpeedRestrictedWaypoints();
      return waypoints[0];
    }
    /**
     * Get the next waypoint in the flight plan, if it exists
     *
     * @for Fms
     * @property nextWaypoint
     * @type {WaypointModel}
     */

  }, {
    key: "nextWaypoint",
    get: function get() {
      return this._routeModel.nextWaypoint;
    }
    /**
     * Return an array of all waypoints in all legs of the route
     *
     * @for Fms
     * @property waypoints
     * @type {array<WaypointModel>}
     */

  }, {
    key: "waypoints",
    get: function get() {
      return this._routeModel.waypoints;
    }
  }]);

  return Fms;
}();

exports["default"] = Fms;

},{"../../airport/AirportController":284,"../../airport/runway/RunwayModel":290,"../../constants/aircraftConstants":303,"../../constants/globalConstants":310,"../../constants/routeConstants":314,"../../navigationLibrary/NavigationLibrary":361,"./RouteModel":270,"lodash/find":191,"lodash/findLast":194,"lodash/includes":206,"lodash/isEmpty":213,"lodash/isNil":219,"lodash/isObject":221}],269:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _findIndex2 = _interopRequireDefault(require("lodash/findIndex"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _without2 = _interopRequireDefault(require("lodash/without"));

var _NavigationLibrary = _interopRequireDefault(require("../../navigationLibrary/NavigationLibrary"));

var _WaypointModel = _interopRequireDefault(require("./WaypointModel"));

var _globalConstants = require("../../constants/globalConstants");

var _routeConstants = require("../../constants/routeConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * A portion of a navigation route containing one or more `WaypointModel` objects.
 *
 * @class LegModel
 */
var LegModel =
/*#__PURE__*/
function () {
  /**
   * @for LegModel
   * @constructor
   * @param routeString {string}
   */
  function LegModel(routeString) {
    _classCallCheck(this, LegModel);

    /**
     * Reference to an instance of a `AirwayModel` object (if this is an airway leg)
     *
     * @for LegModel
     * @property _airwayModel
     * @type {AirwayModel|null}
     * @default null
     * @private
     */
    this._airwayModel = null;
    /**
     * Type of leg from list of types defined in `LEG_TYPE`
     *
     * @for LegModel
     * @property _legType
     * @type {string}
     * @default ''
     * @private
     */

    this._legType = '';
    /**
     * Reference to an instance of a `ProcedureModel` object (if this is a procedure leg)
     *
     * @for LegModel
     * @property _procedureModel
     * @type {ProcedureModel|null}
     * @default null
     * @private
     */

    this._procedureModel = null;
    /**
     * Array of `WaypointModel`s that have been passed (or skipped)
     *
     * Aircraft will proceed along the route to each waypoint, and upon passing
     * a waypoint, it will move that waypoint here to the `#_previousWaypointCollection`,
     * and proceed to the next waypoint in the `#_waypointCollection` until no more
     * `WaypointModel`s remain in the leg, at which point, they continue to the next leg.
     *
     * @for LegModel
     * @property _previousWaypointCollection
     * @type {array<WaypointModel>}
     * @default []
     * @private
     */

    this._previousWaypointCollection = [];
    /**
     * Standard-formatted route string for this leg, excluding any special characters
     *
     * @for LegModel
     * @property _routeString
     * @type {string}
     * @default ''
     * @private
     */

    this._routeString = '';
    /**
     * Array of `WaypointModel`s to follow, excluding any waypoints passed (or skipped)
     *
     * Upon completion of a given `WaypointModel` in the `#_waypointCollection`, that
     * waypoint will be moved to the `#_previousWaypointCollection`, and the aircraft will
     * continue to the next `WaypointModel` in the `#_waypointCollection`.
     *
     * @for LegModel
     * @property _waypointCollection
     * @type {array<WaypointModel>}
     * @default []
     * @private
     */

    this._waypointCollection = [];
    this.init(routeString);
  }
  /**
   * Returns the active `WaypointModel`
   *
   * Assumed to always be the first item in the `#waypointCollection`
   *
   * @for LegModel
   * @property currentWaypoint
   * @type {WaypointModel}
   */


  _createClass(LegModel, [{
    key: "init",
    // ------------------------------ LIFECYCLE ------------------------------

    /**
     * Initialize instance properties
     *
     * @for LegModel
     * @method init
     * @param routeString {string}
     * @chainable
     */
    value: function init(routeString) {
      this._routeString = routeString;

      var _routeString$split = routeString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER),
          _routeString$split2 = _slicedToArray(_routeString$split, 3),
          entryOrFixName = _routeString$split2[0],
          airwayOrProcedureName = _routeString$split2[1],
          exit = _routeString$split2[2];

      this._ensureRouteStringIsSingleSegment(routeString);

      this._legType = this._determineLegType(airwayOrProcedureName);
      this._airwayModel = _NavigationLibrary["default"].getAirway(airwayOrProcedureName);
      this._procedureModel = _NavigationLibrary["default"].getProcedure(airwayOrProcedureName);
      this._waypointCollection = this._generateWaypointCollection(entryOrFixName, exit);
      return this;
    }
    /**
     * Reset instance properties
     *
     * @for LegModel
     * @method reset
     * @chainable
     */

  }, {
    key: "reset",
    value: function reset() {
      this._resetWaypointCollection();

      this._airwayModel = null;
      this._legType = '';
      this._procedureModel = null;
      this._previousWaypointCollection = [];
      this._routeString = '';
      this._waypointCollection = [];
      return this;
    }
    /**
     * Return the type of leg this will be, based on the route string
     *
     * @for LegModel
     * @method _determineLegType
     * @param airwayOrProcedureName {string}
     * @return {string} property of `LEG_TYPE` enum
     */

  }, {
    key: "_determineLegType",
    value: function _determineLegType(airwayOrProcedureName) {
      if (this._routeString.indexOf('.') === _globalConstants.INVALID_NUMBER) {
        return _routeConstants.LEG_TYPE.DIRECT;
      }

      if (_NavigationLibrary["default"].hasAirway(airwayOrProcedureName)) {
        return _routeConstants.LEG_TYPE.AIRWAY;
      }

      if (_NavigationLibrary["default"].hasProcedure(airwayOrProcedureName)) {
        return _routeConstants.LEG_TYPE.PROCEDURE;
      }

      throw new TypeError("Expected airway or procedure name, but we can't ' +\n            'determine what kind of leg ".concat(airwayOrProcedureName, " is"));
    }
    /**
     * Verify that we are not attempting to initialize this `LegModel` with a route
     * string that should have been two separate `LegModels`, and throw errors if
     * we ever DO make such a mistake.
     *
     * @for LegModel
     * @method _ensureRouteStringIsSingleSegment
     * @param routeString {string}
     */

  }, {
    key: "_ensureRouteStringIsSingleSegment",
    value: function _ensureRouteStringIsSingleSegment(routeString) {
      if (routeString.indexOf('..') !== _globalConstants.INVALID_INDEX) {
        throw new TypeError("Expected single fix or single procedure route string, but received '".concat(routeString, "'"));
      }

      if (routeString.split('.').length > 3) {
        throw new TypeError("Expected single procedure route string, but received '".concat(routeString, "'"));
      }
    }
    /**
     * Generate a `WaypointModel` for the specified data
     *
     * @for LegModel
     * @method _generateWaypoint
     * @param data {string|array<string>}
     * @returns {WaypointModel}
     * @private
     */

  }, {
    key: "_generateWaypoint",
    value: function _generateWaypoint(data) {
      var waypoint = new _WaypointModel["default"](data);

      var holdParameters = _NavigationLibrary["default"].findHoldParametersByFix(waypoint.name);

      if (holdParameters != null) {
        waypoint.setDefaultHoldParameters(holdParameters);
      }

      return waypoint;
    }
    /**
     * Generate an array of `WaypointModel`s an aircraft's FMS will need in order to
     * navigate along this leg instance.
     *
     * @for LegModel
     * @param _generateWaypointCollection
     * @param entryOrFixName {string} name of the entry point (if airway/procedure), or fix name
     * @param exit {string} name of exit point (if airway/procedure), or `undefined`
     * @return {array<WaypointModel>}
     */

  }, {
    key: "_generateWaypointCollection",
    value: function _generateWaypointCollection(entryOrFixName, exit) {
      if (this._legType === _routeConstants.LEG_TYPE.DIRECT) {
        return [this._generateWaypoint(entryOrFixName)];
      }

      if (this._legType === _routeConstants.LEG_TYPE.AIRWAY) {
        this._verifyAirwayAndEntryAndExitAreValid(entryOrFixName, exit);

        return this._airwayModel.getWaypointModelsForEntryAndExit(entryOrFixName, exit);
      }

      this._verifyProcedureAndEntryAndExitAreValid(entryOrFixName, exit);

      return this._procedureModel.getWaypointModelsForEntryAndExit(entryOrFixName, exit);
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Mark the specified waypoint as a hold waypoint
     *
     * @for LegModel
     * @method activateHoldForWaypointName
     * @param waypointName {string} name of waypoint in route
     * @param holdParameters {object}
     * @param fallbackInboundHeading {number} an optional inboundHeading that is used if no default is available
     * @returns {object} The hold parameters set for the `WaypointModel`
     */

  }, {
    key: "activateHoldForWaypointName",
    value: function activateHoldForWaypointName(waypointName, holdParameters) {
      var fallbackInboundHeading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (!this.hasWaypointName(waypointName)) {
        return;
      }

      var waypointIndex = this._findIndexOfWaypointName(waypointName);

      var waypointModel = this._waypointCollection[waypointIndex];
      return waypointModel.setHoldParametersAndActivateHold(holdParameters, fallbackInboundHeading);
    }
    /**
     * Return the identifier of the airway being used in this leg
     *
     * @for LegModel
     * @method getAirwayName
     * @return {string}
     */

  }, {
    key: "getAirwayName",
    value: function getAirwayName() {
      if (!this.isAirwayLeg) {
        return;
      }

      return this._airwayModel.icao;
    }
    /**
     * Return an array of WaypointModels AFTER (not including) the specified waypoint
     *
     * @for LegModel
     * @method getAllWaypointModelsAfterWaypointName
     * @return {array<WaypointModel>}
     */

  }, {
    key: "getAllWaypointModelsAfterWaypointName",
    value: function getAllWaypointModelsAfterWaypointName(waypointName) {
      var indexOfWaypointName = this._findIndexOfWaypointName(waypointName);

      return this._waypointCollection.slice().splice(indexOfWaypointName + 1);
    }
    /**
     * Return an array of WaypointModels BEFORE (not including) the specified waypoint
     *
     * @for LegModel
     * @method getAllWaypointModelsBeforeWaypointName
     * @return {array<WaypointModel>}
     */

  }, {
    key: "getAllWaypointModelsBeforeWaypointName",
    value: function getAllWaypointModelsBeforeWaypointName(waypointName) {
      var indexOfWaypointName = this._findIndexOfWaypointName(waypointName);

      var copyOfWaypointCollection = this._waypointCollection.slice();

      copyOfWaypointCollection.splice(indexOfWaypointName);
      return copyOfWaypointCollection;
    }
    /**
     * Return the ICAO identifier for the airport at which this leg will terminate (if
     * it is in fact a STAR leg, of course).
     *
     * @for LegModel
     * @method getArrivalRunwayAirportIcao
     * @return {string}
     */

  }, {
    key: "getArrivalRunwayAirportIcao",
    value: function getArrivalRunwayAirportIcao() {
      if (!this.isStarLeg) {
        return null;
      }

      var airportAndRunway = this._routeString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER)[2];

      var arrivalAirportIcao = airportAndRunway.substr(0, 4);
      return arrivalAirportIcao.toLowerCase();
    }
    /**
     * Return the name of the runway at which this leg will terminate (if it is in fact
     * a STAR leg, of course).
     *
     * @for LegModel
     * @method getArrivalRunwayName
     * @return {string}
     */

  }, {
    key: "getArrivalRunwayName",
    value: function getArrivalRunwayName() {
      if (!this.isStarLeg) {
        return null;
      }

      var airportAndRunway = this._routeString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER)[2];

      var arrivalRunwayName = airportAndRunway.substr(4);
      return arrivalRunwayName;
    }
    /**
    * Returns the lowest `#altitudeMinimum` of all `WaypointModel`s in this leg
    *
    * @for LegModel
    * @method getBottomAltitude
    * @return {number}
    */

  }, {
    key: "getBottomAltitude",
    value: function getBottomAltitude() {
      if (!this.isProcedureLeg) {
        return _globalConstants.INVALID_NUMBER;
      }

      var minimumAltitudes = (0, _map2["default"])(this._waypointCollection, function (waypoint) {
        return waypoint.altitudeMinimum;
      });
      var positiveValueRestrictionList = (0, _without2["default"])(minimumAltitudes, _globalConstants.INVALID_NUMBER);
      var bottomAltitude = Math.min.apply(Math, _toConsumableArray(positiveValueRestrictionList));

      if (bottomAltitude === Infinity) {
        return _globalConstants.INVALID_NUMBER;
      }

      return bottomAltitude;
    }
    /**
    * Return the ICAO identifier for the airport at which this leg originates (if
    * it is in fact a SID leg, of course).
    *
    * @for LegModel
    * @method getDepartureRunwayAirportIcao
    * @return {string}
    */

  }, {
    key: "getDepartureRunwayAirportIcao",
    value: function getDepartureRunwayAirportIcao() {
      if (!this.isSidLeg) {
        return null;
      }

      var airportAndRunway = this._routeString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER)[0];

      var departureAirportIcao = airportAndRunway.substr(0, 4);
      return departureAirportIcao.toLowerCase();
    }
    /**
    * Return the name of the runway at which this leg begins (if it is in fact
    * a SID leg, of course).
    *
    * @for LegModel
    * @method getDepartureRunwayName
    * @return {string}
    */

  }, {
    key: "getDepartureRunwayName",
    value: function getDepartureRunwayName() {
      if (!this.isSidLeg) {
        return null;
      }

      var airportAndRunway = this._routeString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER)[0];

      var departureRunwayName = airportAndRunway.substr(4);
      return departureRunwayName;
    }
    /**
     * Return the ICAO identifier for the procedure being used by this leg
     *
     * @for LegModel
     * @method getProcedureIcao
     * @return {string}
     */

  }, {
    key: "getProcedureIcao",
    value: function getProcedureIcao() {
      if (!this.isProcedureLeg) {
        return;
      }

      return this._procedureModel.icao;
    }
    /**
     * Return the name of the procedure being used by this leg
     *
     * @for LegModel
     * @method getProcedureName
     * @return {string}
     */

  }, {
    key: "getProcedureName",
    value: function getProcedureName() {
      if (!this.isProcedureLeg) {
        return;
      }

      return this._procedureModel.name;
    }
    /**
     * Return the name of this leg's exit fix
     *
     * @for LegModel
     * @method getExitFixName
     * @return {string}
     */

  }, {
    key: "getEntryFixName",
    value: function getEntryFixName() {
      if (this.isDirectLeg) {
        return this._routeString;
      }

      var routeStringElements = this._routeString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER);

      return routeStringElements[0];
    }
    /**
     * Return the name of this leg's exit fix
     *
     * @for LegModel
     * @method getExitFixName
     * @return {string}
     */

  }, {
    key: "getExitFixName",
    value: function getExitFixName() {
      if (this.isDirectLeg) {
        return this._routeString;
      }

      var routeStringElements = this._routeString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER);

      return routeStringElements[2];
    }
    /**
     * Returns the route string for this leg, removing any airports
     * For example, `KSEA16L.BANGR9.PANGL` --> `BANGR9.PANGL`
     *
     * BE CAREFUL using this method, because technically `BANGR9.PANGL` is not technically a
     * valid route string, as it does not follow the proper format. This method was created
     * as a means to remove the airports from the route strings so we can display a route on
     * the flight strip that excludes the airport, since this is instead shown in a separate
     * section of the flight strip, and should not be included in the route section.
     *
     * @for LegModel
     * @method getRouteStringWithoutAirports
     * @return {string}
     */

  }, {
    key: "getRouteStringWithoutAirports",
    value: function getRouteStringWithoutAirports() {
      var routeString = this._routeString;

      if (this.isSidLeg) {
        var elements = routeString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER);
        var procedure = elements[1];
        var exit = elements[2];
        return "".concat(procedure, ".").concat(exit);
      }

      if (this.isStarLeg) {
        var _elements = routeString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER);

        var entry = _elements[0];
        var _procedure = _elements[1];
        return "".concat(entry, ".").concat(_procedure);
      }

      return routeString;
    }
    /**
     * Returns the highest `#altitudeMaximum` of all `WaypointModel`s in this leg
     *
     * @for LegModel
     * @method getTopAltitude
     * @return {number}
     */

  }, {
    key: "getTopAltitude",
    value: function getTopAltitude() {
      if (!this.isProcedureLeg) {
        return _globalConstants.INVALID_NUMBER;
      }

      var maximumAltitudes = (0, _map2["default"])(this._waypointCollection, function (waypoint) {
        return waypoint.altitudeMaximum;
      });
      var positiveValueRestrictionList = (0, _without2["default"])(maximumAltitudes, _globalConstants.INVALID_NUMBER);
      var topAltitude = Math.max.apply(Math, _toConsumableArray(positiveValueRestrictionList));

      if (topAltitude === -Infinity) {
        return _globalConstants.INVALID_NUMBER;
      }

      return topAltitude;
    }
    /**
    * Whether there are any `WaypointModel`s in this leg beyond the `#currentWaypoint`
    *
    * @for LegModel
    * @method hasNextWaypoint
    * @return {boolean}
    */

  }, {
    key: "hasNextWaypoint",
    value: function hasNextWaypoint() {
      return this._waypointCollection.length > 1;
    }
    /**
    * Whether a `WaypointModel` with the specified name exists within the `#_waypointCollection`
    *
    * Note that this will return false even if the specified fix name IS included
    * in the `#_previousWaypointCollection`.
    *
    * @for LegModel
    * @method hasWaypointName
    * @param waypointName {string}
    * @return {boolean}
    */

  }, {
    key: "hasWaypointName",
    value: function hasWaypointName(waypointName) {
      if ((0, _isEmpty2["default"])(waypointName)) {
        throw new TypeError("Expected valid fix name but received '".concat(waypointName, "'"));
      }

      waypointName = waypointName.toUpperCase(); // using a for loop instead of `_find()` to maximize performance
      // because this operation could happen quite frequently

      for (var i = 0; i < this._waypointCollection.length; i++) {
        if (this._waypointCollection[i].name === waypointName) {
          return true;
        }
      }

      return false;
    }
    /**
    * Move the `#currentWaypoint` to the `#_previousWaypointCollection`
    *
    * This also results in the `WaypointModel` previously at index `1` becoming
    * index `0`, thus making it the new `#currentWaypoint`.
    *
    * @for LegModel
    * @method moveToNextWaypoint
    */

  }, {
    key: "moveToNextWaypoint",
    value: function moveToNextWaypoint() {
      var waypointModelToMove = this._waypointCollection.shift();

      this._previousWaypointCollection.push(waypointModelToMove);
    }
  }, {
    key: "procedureHasEntry",
    value: function procedureHasEntry(entryName) {
      if (!this.isProcedureLeg) {
        return false;
      }

      return this._procedureModel.hasEntry(entryName);
    }
  }, {
    key: "procedureHasExit",
    value: function procedureHasExit(exitName) {
      if (!this.isProcedureLeg) {
        return false;
      }

      return this._procedureModel.hasExit(exitName);
    }
    /**
     * Move all `WaypointModel`s to the `#_previousWaypointCollection`
     *
     * @for LegModel
     * @method skipAllWaypointsInLeg
     */

  }, {
    key: "skipAllWaypointsInLeg",
    value: function skipAllWaypointsInLeg() {
      var _this$_previousWaypoi;

      (_this$_previousWaypoi = this._previousWaypointCollection).push.apply(_this$_previousWaypoi, _toConsumableArray(this._waypointCollection));

      this._waypointCollection = [];
    }
    /**
     * Move all `WaypointModel`s before the specified waypoint to the `#_previousWaypointCollection`
     *
     * This also results in the waypoint with the specified name becoming the new `#currentWaypoint`
     *
     * @for LegModel
     * @method skipToWaypointName
     * @param waypointName {string}
     * @return {boolean} success of operation
     */

  }, {
    key: "skipToWaypointName",
    value: function skipToWaypointName(waypointName) {
      var _this$_previousWaypoi2;

      var waypointIndex = this._findIndexOfWaypointName(waypointName);

      if (waypointIndex === _globalConstants.INVALID_INDEX) {
        return false;
      }

      var numberOfWaypointsToMove = waypointIndex;

      var waypointModelsToMove = this._waypointCollection.splice(0, numberOfWaypointsToMove);

      (_this$_previousWaypoi2 = this._previousWaypointCollection).push.apply(_this$_previousWaypoi2, _toConsumableArray(waypointModelsToMove));

      return true;
    }
    /**
    * If applicable, make the SID entry match the specified departure runway
    *
    * @for LegModel
    * @method updateSidLegForDepartureRunwayModel
    * @param runwayModel {RunwayModel}
    */

  }, {
    key: "updateSidLegForDepartureRunwayModel",
    value: function updateSidLegForDepartureRunwayModel(runwayModel) {
      if (!this.isSidLeg) {
        return;
      }

      var routeStringComponents = this._routeString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER);

      var currentEntryName = routeStringComponents[0];
      var currentExitName = routeStringComponents[2]; // assumed first four characters of exit name to be airport ICAO

      var currentRunwayName = currentEntryName.substr(4);
      var nextRunwayName = runwayModel.name;
      var nextEntryName = currentEntryName.substr(0, 4).concat(nextRunwayName);

      if (runwayModel.name === currentRunwayName) {
        return;
      }

      if (!this._procedureModel.hasEntry(nextEntryName)) {
        return;
      }

      this._waypointCollection = this._generateWaypointCollection(nextEntryName, currentExitName);
    }
    /**
     * If applicable, make the STAR exit match the specified arrival runway model
     *
     * @for LegModel
     * @method updateStarLegForArrivalRunwayModel
     * @param runwayModel {RunwayModel}
     */

  }, {
    key: "updateStarLegForArrivalRunwayModel",
    value: function updateStarLegForArrivalRunwayModel(runwayModel) {
      if (!this.isStarLeg) {
        return;
      }

      var routeStringComponents = this._routeString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER);

      var currentEntryName = routeStringComponents[0];
      var currentExitName = routeStringComponents[2]; // assumed first four characters of exit name to be airport ICAO

      var currentRunwayName = currentExitName.substr(4);
      var nextRunwayName = runwayModel.name;
      var nextExitName = currentExitName.substr(0, 4).concat(nextRunwayName);

      if (runwayModel.name === currentRunwayName) {
        return;
      }

      if (!this._procedureModel.hasExit(nextExitName)) {
        return;
      }

      this._waypointCollection = this._generateWaypointCollection(currentEntryName, nextExitName);
    } // ------------------------------ PRIVATE ------------------------------

  }, {
    key: "_findIndexOfWaypointName",
    value: function _findIndexOfWaypointName(waypointName) {
      return (0, _findIndex2["default"])(this._waypointCollection, function (waypointModel) {
        return waypointModel.name === waypointName.toUpperCase();
      });
    }
    /**
     * Reset all waypoints and move them to the `#_previousWaypointCollection`
     *
     * TODO: implement object pooling with `WaypointModel`, this is the method
     *       where the `WaypointModel` is returned to the pool
     *
     * @for LegModel
     * @method _resetWaypointCollection
     * @private
     */

  }, {
    key: "_resetWaypointCollection",
    value: function _resetWaypointCollection() {
      this.skipAllWaypointsInLeg();

      for (var i = 0; i < this._previousWaypointCollection.length; i++) {
        this._previousWaypointCollection[i].reset();
      }
    }
    /**
     * Ensure that the airway, entry, and exit are all valid and can be used to generate waypoints
     *
     * Note that this should only be run on AIRWAY legs!
     *
     * @for LegModel
     * @method _verifyAirwayAndEntryAndExitAreValid
     * @private
     */

  }, {
    key: "_verifyAirwayAndEntryAndExitAreValid",
    value: function _verifyAirwayAndEntryAndExitAreValid(entryName, exitName) {
      if ((0, _isNil2["default"])(this._airwayModel)) {
        throw new TypeError('Unable to generate waypoints because the requested airway does not exist');
      }

      var airwayIcao = this._airwayModel.icao;

      if (!this._airwayModel.hasFixName(entryName)) {
        throw new TypeError("Expected valid entry of ".concat(airwayIcao, ", but received ").concat(entryName));
      }

      if (!this._airwayModel.hasFixName(exitName)) {
        throw new TypeError("Expected valid exit of ".concat(airwayIcao, ", but received ").concat(exitName));
      }
    }
    /**
     * Ensure that the procedure, entry, and exit are all valid and can be used to generate waypoints
     *
     * Note that this should only be run on PROCEDURE legs!
     *
     * @for LegModel
     * @method _verifyProcedureAndEntryAndExitAreValid
     * @private
     */

  }, {
    key: "_verifyProcedureAndEntryAndExitAreValid",
    value: function _verifyProcedureAndEntryAndExitAreValid(entryName, exitName) {
      if ((0, _isNil2["default"])(this._procedureModel)) {
        throw new TypeError('Unable to generate waypoints because the requested procedure does not exist');
      }

      var procedureIcao = this._procedureModel.icao;

      if (!this._procedureModel.hasEntry(entryName)) {
        throw new TypeError("Expected valid entry of ".concat(procedureIcao, ", but received ").concat(entryName));
      }

      if (!this._procedureModel.hasExit(exitName)) {
        throw new TypeError("Expected valid exit of ".concat(procedureIcao, ", but received ").concat(exitName));
      }
    }
  }, {
    key: "currentWaypoint",
    get: function get() {
      if (this._waypointCollection.length === 0) {
        throw new TypeError('Expected the current leg to contain at least one waypoint');
      }

      return this._waypointCollection[0];
    }
    /**
     * Returns whether this leg is an airway leg
     *
     * @for LegModel
     * @property isAirwayLeg
     * @type {boolean}
     */

  }, {
    key: "isAirwayLeg",
    get: function get() {
      return this._legType === _routeConstants.LEG_TYPE.AIRWAY;
    }
    /**
     * Returns whether this leg is a direct leg
     *
     * @for LegModel
     * @property isDirectLeg
     * @type {boolean}
     */

  }, {
    key: "isDirectLeg",
    get: function get() {
      return this._legType === _routeConstants.LEG_TYPE.DIRECT;
    }
    /**
     * Returns whether this leg is a procedure leg
     *
     * @for LegModel
     * @property isProcedureLeg
     * @type {boolean}
     */

  }, {
    key: "isProcedureLeg",
    get: function get() {
      return this._legType === _routeConstants.LEG_TYPE.PROCEDURE;
    }
    /**
     * Whether this leg is a SID Procedure leg
     *
     * @for RouteModel
     * @property isSidLeg
     * @type {boolean}
     */

  }, {
    key: "isSidLeg",
    get: function get() {
      return this.isProcedureLeg && this._procedureModel.procedureType === _routeConstants.PROCEDURE_TYPE.SID;
    }
    /**
     * Whether this leg is a STAR Procedure leg
     *
     * @for RouteModel
     * @property isStarLeg
     * @type {boolean}
     */

  }, {
    key: "isStarLeg",
    get: function get() {
      return this.isProcedureLeg && this._procedureModel.procedureType === _routeConstants.PROCEDURE_TYPE.STAR;
    }
    /**
     * Returns the type of this leg
     *
     * @for LegModel
     * @property legType
     * @type {string}
     */

  }, {
    key: "legType",
    get: function get() {
      return this._legType;
    }
    /**
     * Returns the `WaypointModel` immediately following the `#currentWaypoint`
     *
     * @for LegModel
     * @property nextWaypoint
     * @type {WaypointModel}
     */

  }, {
    key: "nextWaypoint",
    get: function get() {
      return this._waypointCollection[1];
    }
    /**
     * Returns the route string for this leg
     *
     * @for LegModel
     * @property routeString
     * @type {string}
     */

  }, {
    key: "routeString",
    get: function get() {
      return this._routeString;
    }
    /**
     * Return the `#_waypointCollection`
     *
     * @for LegModel
     * @property waypoints
     * @type {array<WaypointModel>}
     */

  }, {
    key: "waypoints",
    get: function get() {
      return this._waypointCollection;
    }
  }, {
    key: "altitude",
    get: function get() {
      return this._procedureModel.altitude;
    }
  }]);

  return LegModel;
}();

exports["default"] = LegModel;

},{"../../constants/globalConstants":310,"../../constants/routeConstants":314,"../../navigationLibrary/NavigationLibrary":361,"./WaypointModel":271,"lodash/findIndex":192,"lodash/isEmpty":213,"lodash/isNil":219,"lodash/map":231,"lodash/without":252}],270:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _chunk2 = _interopRequireDefault(require("lodash/chunk"));

var _first2 = _interopRequireDefault(require("lodash/first"));

var _findIndex2 = _interopRequireDefault(require("lodash/findIndex"));

var _intersection2 = _interopRequireDefault(require("lodash/intersection"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _last4 = _interopRequireDefault(require("lodash/last"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _reduce2 = _interopRequireDefault(require("lodash/reduce"));

var _without2 = _interopRequireDefault(require("lodash/without"));

var _LegModel = _interopRequireDefault(require("./LegModel"));

var _BaseModel2 = _interopRequireDefault(require("../../base/BaseModel"));

var _AirportController = _interopRequireDefault(require("../../airport/AirportController"));

var _RunwayModel = _interopRequireDefault(require("../../airport/runway/RunwayModel"));

var _globalConstants = require("../../constants/globalConstants");

var _routeConstants = require("../../constants/routeConstants");

var _navigationUtilities = require("../../utilities/navigationUtilities");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Representation of an aircraft's flight plan route
 *
 * This object contains all of the legs and waypoints the FMS will use to navigate.
 * Each instance of an Aircraft has an FMS with a `RouteModel`, that it is able
 * to modify, including adding/removing legs/waypoints, adding/removing waypoint
 * restrictions, absorbing another `RouteModel`, etc.
 *
 * @class RouteModel
 */
var RouteModel =
/*#__PURE__*/
function (_BaseModel) {
  _inherits(RouteModel, _BaseModel);

  /**
   * @for RouteModel
   * @constructor
   * @param routeString {string}
   */
  function RouteModel(routeString) {
    var _this;

    _classCallCheck(this, RouteModel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RouteModel).call(this));
    /**
     * Array of `LegModel`s on the route
     *
     * @for RouteModel
     * @property _legCollection
     * @type {array<LegModel>}
     * @private
     */

    _this._legCollection = [];
    /**
     * Array of `LegModel`s that have been passed (or skipped)
     *
     * Aircraft will proceed along the route to each waypoint, and upon completion
     * of any given leg, it will move that leg here to the `#_previousLegCollection`,
     * and proceed to the next leg in the `#_legCollection` until no more `LegModel`s
     * exist, at which point they will simply hold their last assigned heading and altitude.
     *
     * @for RouteModel
     * @property _previousLegCollection
     * @type {array<WaypointModel>}
     * @private
     */

    _this._previousLegCollection = [];

    _this.init(routeString);

    return _this;
  }
  /**
   * Return the current `LegModel`
   *
   * @for RouteModel
   * @property currentLeg
   * @type {LegModel}
   */


  _createClass(RouteModel, [{
    key: "init",
    // ------------------------------ LIFECYCLE ------------------------------

    /**
     * Initialize instance properties
     *
     * @for RouteModel
     * @method init
     * @param routeString {string}
     * @chainable
     */
    value: function init(routeString) {
      this._legCollection = this._generateLegsFromRouteString(routeString);
      return this;
    }
    /**
     * Reset instance properties
     *
     * @for RouteModel
     * @method reset
     * @chainable
     */

  }, {
    key: "reset",
    value: function reset() {
      this._legCollection = [];
      return this;
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Merge the provided route model into this route model, if possible
     *
     * @for RouteModel
     * @method absorbRouteModel
     * @param routeModel {RouteModel}
     * @return {array} [success of operation, response]
     */

  }, {
    key: "absorbRouteModel",
    value: function absorbRouteModel(routeModel) {
      var firstWaypointName = (0, _first2["default"])(routeModel.waypoints).name;
      var lastWaypointName = (0, _last4["default"])(routeModel.waypoints).name;
      var routesConverge = this.hasWaypointName(lastWaypointName);
      var routesDiverge = this.hasWaypointName(firstWaypointName);

      if (routesConverge && routesDiverge) {
        return this._overwriteRouteBetweenWaypointNames(firstWaypointName, lastWaypointName, routeModel);
      }

      if (routesConverge) {
        return this._prependRouteModelEndingAtWaypointName(lastWaypointName, routeModel);
      }

      if (routesDiverge) {
        return this._appendRouteModelBeginningAtWaypointName(firstWaypointName, routeModel);
      }

      return [false, 'routes do not have continuity!'];
    }
    /**
     * Mark the specified waypoint as a hold waypoint
     *
     * @for RouteModel
     * @method activateHoldForWaypointName
     * @param waypointName {string} name of waypoint in route
     * @param holdParameters {object}
     * @param fallbackInboundHeading {number} an optional inboundHeading that is used if no default is available
     * @returns {object} The hold parameters set for the `WaypointModel`
     */

  }, {
    key: "activateHoldForWaypointName",
    value: function activateHoldForWaypointName(waypointName, holdParameters) {
      var fallbackInboundHeading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (!this.hasWaypointName(waypointName)) {
        return;
      }

      var legIndex = this._findIndexOfLegContainingWaypointName(waypointName);

      var legModel = this._legCollection[legIndex]; // This calculates the inbound heading to the fix from the preceding waypoint,
      // and uses that as the fallbackInboundHeading.
      // If no preceding waypoing exists, then the original fallbackInboundHeading passed is used

      var _this$waypoints$reduc = this.waypoints.reduce(function (last, wpt) {
        var _last2 = _slicedToArray(last, 1),
            heading = _last2[0];

        var _last3 = _slicedToArray(last, 2),
            lastWpt = _last3[1];

        if (lastWpt !== null && wpt.name === waypointName.toUpperCase()) {
          heading = wpt.positionModel.bearingFromPosition(lastWpt.positionModel);
        }

        return [heading, wpt];
      }, [fallbackInboundHeading, null]);

      var _this$waypoints$reduc2 = _slicedToArray(_this$waypoints$reduc, 1);

      fallbackInboundHeading = _this$waypoints$reduc2[0];
      return legModel.activateHoldForWaypointName(waypointName, holdParameters, fallbackInboundHeading);
    }
    /**
    * Return an array of waypoints in the flight plan that have altitude restrictions
    *
    * @for RouteModel
    * @method getAltitudeRestrictedWaypoints
    * @return {array<WaypointModel>}
    */

  }, {
    key: "getAltitudeRestrictedWaypoints",
    value: function getAltitudeRestrictedWaypoints() {
      return this.waypoints.filter(function (waypoint) {
        return waypoint.hasAltitudeRestriction;
      });
    }
    /**
     * Return the ICAO identifier for the airport at whose runway this route will terminate
     *
     * @for LegModel
     * @method getArrivalRunwayAirportIcao
     * @return {string}
     */

  }, {
    key: "getArrivalRunwayAirportIcao",
    value: function getArrivalRunwayAirportIcao() {
      if (!this.hasStarLeg()) {
        return null;
      }

      var starLegIndex = this._findStarLegIndex();

      return this._legCollection[starLegIndex].getArrivalRunwayAirportIcao();
    }
    /**
     * Return the `AirportModel` at whose runway this route will terminate
     *
     * @for RouteModel
     * @method getArrivalRunwayAirportModel
     * @return {AirportModel}
     */

  }, {
    key: "getArrivalRunwayAirportModel",
    value: function getArrivalRunwayAirportModel() {
      var airportIcao = this.getArrivalRunwayAirportIcao();

      if (!airportIcao) {
        return null;
      }

      return _AirportController["default"].airport_get(airportIcao);
    }
    /**
     * Return the name of the runway at which this route will terminate
     *
     * @for LegModel
     * @method getArrivalRunwayName
     * @return {string}
     */

  }, {
    key: "getArrivalRunwayName",
    value: function getArrivalRunwayName() {
      if (!this.hasStarLeg()) {
        return null;
      }

      var starLegIndex = this._findStarLegIndex();

      return this._legCollection[starLegIndex].getArrivalRunwayName();
    }
    /**
     * Return the `RunwayModel` at which this route will terminate
     *
     * @for RouteModel
     * @method getArrivalRunwayModel
     * @return {RunwayModel}
     */

  }, {
    key: "getArrivalRunwayModel",
    value: function getArrivalRunwayModel() {
      var arrivalRunwayName = this.getArrivalRunwayName();

      if (!arrivalRunwayName) {
        return null;
      }

      return this.getArrivalRunwayAirportModel().getRunway(arrivalRunwayName);
    }
    /**
    * Return the ICAO identifier for the airport at whose runway this route originates
    *
    * @for LegModel
    * @method getDepartureRunwayAirportIcao
    * @return {string}
    */

  }, {
    key: "getDepartureRunwayAirportIcao",
    value: function getDepartureRunwayAirportIcao() {
      if (!this.hasSidLeg()) {
        return null;
      }

      var sidLegModel = this._findSidLeg();

      return sidLegModel.getDepartureRunwayAirportIcao();
    }
    /**
     * Return the `AirportModel` for the airport at whose runway this route originates
     *
     * @for RouteModel
     * @method getDepartureRunwayAirportModel
     * @return {AirportModel}
     */

  }, {
    key: "getDepartureRunwayAirportModel",
    value: function getDepartureRunwayAirportModel() {
      var airportIcao = this.getDepartureRunwayAirportIcao();

      if (!airportIcao) {
        return null;
      }

      return _AirportController["default"].airport_get(airportIcao);
    }
    /**
    * Return the name of the runway at which this route originates
    *
    * @for LegModel
    * @method getDepartureRunwayName
    * @return {string}
    */

  }, {
    key: "getDepartureRunwayName",
    value: function getDepartureRunwayName() {
      if (!this.hasSidLeg()) {
        return null;
      }

      var sidLegModel = this._findSidLeg();

      return sidLegModel.getDepartureRunwayName();
    }
    /**
     * Return the `RunwayModel` at which this route originates
     *
     * @for RouteModel
     * @method getDepartureRunwayModel
     * @return {RunwayModel}
     */

  }, {
    key: "getDepartureRunwayModel",
    value: function getDepartureRunwayModel() {
      var departureRunwayName = this.getDepartureRunwayName();

      if (!departureRunwayName) {
        return null;
      }

      return this.getDepartureRunwayAirportModel().getRunway(departureRunwayName);
    }
    /**
    * Returns the lowest bottom altitude of any `LegModel` in the `#_legCollection`
    *
    * @for RouteModel
    * @method getBottomAltitude
    * @return {number}
    */

  }, {
    key: "getBottomAltitude",
    value: function getBottomAltitude() {
      var minAltitudesFromLegs = (0, _without2["default"])((0, _map2["default"])(this._legCollection, function (leg) {
        return leg.getBottomAltitude();
      }), _globalConstants.INVALID_NUMBER);
      var bottomAltitude = Math.min.apply(Math, _toConsumableArray(minAltitudesFromLegs));

      if (bottomAltitude === Infinity) {
        return _globalConstants.INVALID_NUMBER;
      }

      return bottomAltitude;
    }
    /**
     * Generate a route string for all legs in the `#_previousLegCollection` an `#_legCollection`
     *
     * @for RouteModel
     * @method getRouteString
     * @return {string}
     */

  }, {
    key: "getFullRouteString",
    value: function getFullRouteString() {
      var pastAndPresentLegModels = this._getPastAndPresentLegModels();

      var pastAndPresentLegRouteStrings = (0, _map2["default"])(pastAndPresentLegModels, function (legModel) {
        return legModel.routeString;
      });
      return this._combineRouteStrings(pastAndPresentLegRouteStrings);
    }
    /**
    * Returns the full route string, with airports removed
    *
    * Example:
    * - `KSEA16L.BANGR9.PANGL` --> `BANGR9.PANGL`
    *
    * @for RouteModel
    * @method getFullRouteStringWithoutAirportsWithSpaces
    * @return {string}
    */

  }, {
    key: "getFullRouteStringWithoutAirportsWithSpaces",
    value: function getFullRouteStringWithoutAirportsWithSpaces() {
      var pastAndPresentLegModels = this._getPastAndPresentLegModels();

      var legRouteStringsWithoutAirports = (0, _map2["default"])(pastAndPresentLegModels, function (legModel) {
        return legModel.getRouteStringWithoutAirports();
      });
      return this._combineRouteStrings(legRouteStringsWithoutAirports).replace(_globalConstants.REGEX.DOUBLE_DOT, ' ').replace(_globalConstants.REGEX.SINGLE_DOT, ' ');
    }
    /**
     * Return `#fullRouteString` with spaces between elements instead of dot notation
     *
     * Example:
     * - `KSEA16L.BANGR9.PANGL` --> `KSEA16L BANGR9 PANGL`
     *
     * Used mostly for representing the route string in the view, like
     * an aircraft strip, etc.
     *
     * @for RouteModel
     * @method getFullRouteStringWithSpaces
     * @return {string}
     */

  }, {
    key: "getFullRouteStringWithSpaces",
    value: function getFullRouteStringWithSpaces() {
      var routeString = this.getFullRouteString();
      return routeString.replace(_globalConstants.REGEX.DOUBLE_DOT, ' ').replace(_globalConstants.REGEX.SINGLE_DOT, ' ');
    }
    /**
     * Generate a route string for all legs in the `#_legCollection`
     *
     * @for RouteModel
     * @method getRouteString
     * @return {string}
     */

  }, {
    key: "getRouteString",
    value: function getRouteString() {
      var legRouteStrings = (0, _map2["default"])(this._legCollection, function (legModel) {
        return legModel.routeString;
      });
      return this._combineRouteStrings(legRouteStrings);
    }
    /**
     * Return `#routeString` with spaces between elements instead of dot notation
     *
     * Example:
     * - `KSEA16L.BANGR9.PANGL..TOU` --> `BANGR9 PANGL TOU`
     *
     * @for RouteModel
     * @method getRouteStringWithSpaces
     * @return {string}
     */

  }, {
    key: "getRouteStringWithSpaces",
    value: function getRouteStringWithSpaces() {
      var routeString = this.getRouteString();
      return routeString.replace(_globalConstants.REGEX.DOUBLE_DOT, ' ').replace(_globalConstants.REGEX.SINGLE_DOT, ' ');
    }
    /**
     * Returns exit waypoint for a departure aircraft, to be used in datablock
     *
     * When a SID procedure is defined, this will return the exit waypoint
     * Example:
     * - `KLAS07R.BOACH6.TNP` -> `TNP`
     *
     * When no SID procedure is defined, this will return the first fix in the route
     * Example:
     * - `OAL..MLF..PGS` -> `OAL`
     *
     * @for RouteModel
     * @method getFlightPlanEntry
     * @returns {string} First fix in flightPlan or exit fix of SID
     */

  }, {
    key: "getFlightPlanEntry",
    value: function getFlightPlanEntry() {
      if (!this.hasSidLeg()) {
        return this.getFullRouteString().split('..')[0];
      }

      var sidLegModel = this._findSidLeg();

      return sidLegModel.getExitFixName();
    }
    /**
     * Return the ICAO identifier of the SID in use (if any)
     *
     * @for RouteModel
     * @method getSidIcao
     * @return {string}
     */

  }, {
    key: "getSidIcao",
    value: function getSidIcao() {
      if (!this.hasSidLeg()) {
        return;
      }

      var sidLegModel = this._findSidLeg();

      return sidLegModel.getProcedureIcao();
    }
    /**
     * Return the name of the SID in use (if any)
     *
     * @for RouteModel
     * @method getSidName
     * @return {string}
     */

  }, {
    key: "getSidName",
    value: function getSidName() {
      if (!this.hasSidLeg()) {
        return;
      }

      var sidLegModel = this._findSidLeg();

      return sidLegModel.getProcedureName();
    }
    /**
     * Return the initial altitude of the SID or the airport
     *
     * @for RouteModel
     * @method getInitialClimbClearance
     * @return {number}
     */

  }, {
    key: "getInitialClimbClearance",
    value: function getInitialClimbClearance() {
      var sidLegModel = this._findSidLeg();

      if (sidLegModel && sidLegModel.altitude) {
        return sidLegModel.altitude;
      }

      var airport = _AirportController["default"].airport_get();

      return airport.initial_alt;
    }
    /**
     * Return the ICAO identifier of the STAR in use (if any)
     *
     * @for RouteModel
     * @method getStarIcao
     * @return {string}
     */

  }, {
    key: "getStarIcao",
    value: function getStarIcao() {
      if (!this.hasStarLeg()) {
        return;
      }

      var starLegModel = this._legCollection[this._findStarLegIndex()];

      return starLegModel.getProcedureIcao();
    }
    /**
     * Return the name of the STAR in use (if any)
     *
     * @for RouteModel
     * @method getStarName
     * @return {string}
     */

  }, {
    key: "getStarName",
    value: function getStarName() {
      if (!this.hasStarLeg()) {
        return;
      }

      var starLegModel = this._legCollection[this._findStarLegIndex()];

      return starLegModel.getProcedureName();
    }
    /**
     * Returns the highest top altitude of any `LegModel` in the `#_legCollection`
    *
    * @for RouteModel
    * @method getTopAltitude
    * @return {number}
    */

  }, {
    key: "getTopAltitude",
    value: function getTopAltitude() {
      var maxAltitudesFromLegs = (0, _without2["default"])((0, _map2["default"])(this._legCollection, function (leg) {
        return leg.getTopAltitude();
      }), _globalConstants.INVALID_NUMBER);
      var topAltitude = Math.max.apply(Math, _toConsumableArray(maxAltitudesFromLegs));

      if (topAltitude === -Infinity) {
        return _globalConstants.INVALID_NUMBER;
      }

      return topAltitude;
    }
    /**
     * Whether the route has another leg after the current one
     *
     * @for RouteModel
     * @method hasNextLeg
     * @return {boolean}
     */

  }, {
    key: "hasNextLeg",
    value: function hasNextLeg() {
      return this._legCollection.length > 1;
    }
    /**
     * Whether the route has another waypoint after the current one
     *
     * This includes waypoints in the current and future legs
     *
     * @for RouteModel
     * @method hasNextWaypoint
     * @return {boolean}
     */

  }, {
    key: "hasNextWaypoint",
    value: function hasNextWaypoint() {
      if (this.currentLeg.hasNextWaypoint()) {
        return true;
      }

      if (!this.hasNextLeg()) {
        return false;
      }

      return !(0, _isNil2["default"])(this.nextLeg.currentWaypoint);
    }
    /**
     * Return whether the route has a SID leg
     *
     * @for RouteModel
     * @method hasSidLeg
     * @return {boolean}
     */

  }, {
    key: "hasSidLeg",
    value: function hasSidLeg() {
      return this._findSidLegIndex() !== _globalConstants.INVALID_INDEX;
    }
    /**
     * Return whether the route has a STAR leg
     *
     * @for RouteModel
     * @method hasStarLeg
     * @return {boolean}
     */

  }, {
    key: "hasStarLeg",
    value: function hasStarLeg() {
      return this._findStarLegIndex() !== _globalConstants.INVALID_INDEX;
    }
    /**
     * Return whether the route contains a waypoint with the specified name
     *
     * @for RouteModel
     * @method hasWaypointName
     * @param waypointName {string}
     * @return {boolean}
     */

  }, {
    key: "hasWaypointName",
    value: function hasWaypointName(waypointName) {
      for (var i = 0; i < this._legCollection.length; i++) {
        if (this._legCollection[i].hasWaypointName(waypointName)) {
          return true;
        }
      }

      return false;
    }
    /**
     * Returns whether the specified runway is valid for this route's SID leg (if it has one)
     *
     * If there is no SID, there is no issue with changing runways, so we would treat this as "valid"
     *
     * @for RouteModel
     * @method isRunwayModelValidForSid
     * @param runwayModel {RunwayModel}
     * @return {boolean}
     */

  }, {
    key: "isRunwayModelValidForSid",
    value: function isRunwayModelValidForSid(runwayModel) {
      if (!(runwayModel instanceof _RunwayModel["default"])) {
        return false;
      }

      var sidLegModel = this._findSidLeg();

      if (!sidLegModel) {
        return true;
      }

      var departureAirportIcao = this.getDepartureRunwayAirportIcao().toUpperCase();
      var entryName = "".concat(departureAirportIcao).concat(runwayModel.name);
      return sidLegModel.procedureHasEntry(entryName);
    }
    /**
     * Returns whether the specified runway is valid for this route's STAR leg (if it has one)
     *
     * If there is no STAR, there is no issue with changing runways, so we would treat this as "valid"
     *
     * @for RouteModel
     * @method isRunwayModelValidForStar
     * @param runwayModel {RunwayModel}
     * @return {boolean}
     */

  }, {
    key: "isRunwayModelValidForStar",
    value: function isRunwayModelValidForStar(runwayModel) {
      if (!(runwayModel instanceof _RunwayModel["default"])) {
        return false;
      }

      var starLegIndex = this._findStarLegIndex();

      var starLegModel = this._legCollection[starLegIndex];

      if (!starLegModel) {
        return true;
      }

      var arrivalAirportIcao = this.getArrivalRunwayAirportIcao().toUpperCase();
      var exitName = "".concat(arrivalAirportIcao).concat(runwayModel.name);
      return starLegModel.procedureHasExit(exitName);
    }
    /**
     * Skip ahead to the next waypoint
     *
     * If there are no more waypoints in the `#currentLeg`, this will also cause
     * us to skip to the next leg.
     *
     * @for RouteModel
     * @method moveToNextWaypoint
     */

  }, {
    key: "moveToNextWaypoint",
    value: function moveToNextWaypoint() {
      if (!this.currentLeg.hasNextWaypoint()) {
        return this.moveToNextLeg();
      }

      this.currentLeg.moveToNextWaypoint();
    }
    /**
     * Replace the arrival procedure leg with a new one (if it exists in the route)
     *
     * Create a new STAR leg from the specified route string. If a STAR leg already
     * exists, replace that leg with the new one. Else, add the new one at the end
     * of the #_legCollection.
     *
     * @for RouteModel
     * @method replaceArrivalProcedure
     * @param routeString {string}
     * @return {boolean} whether operation was successful
     */

  }, {
    key: "replaceArrivalProcedure",
    value: function replaceArrivalProcedure(routeString) {
      var starLegModel;

      try {
        starLegModel = new _LegModel["default"](routeString);
      } catch (error) {
        console.error(error);
        return false;
      } // if no STAR leg exists, insert the new one as the new last leg


      if (!this.hasStarLeg()) {
        this._legCollection.push(starLegModel);

        return true;
      }

      this._legCollection[this._findStarLegIndex()] = starLegModel;
      return true;
    }
    /**
     * Replace the departure procedure leg with a new one (if it exists in the route)
     *
     * Create a new SID leg from the specified route string. If a SID leg already
     * exists, replace that leg with the new one. Else, add the new one at the
     * beginning of the #_legCollection.
     *
     * @for RouteModel
     * @method replaceDepartureProcedure
     * @param routeString {string}
     * @return {array} [success of operation, response]
     */

  }, {
    key: "replaceDepartureProcedure",
    value: function replaceDepartureProcedure(routeString) {
      var routeModel;

      try {
        routeModel = new RouteModel(routeString);
      } catch (error) {
        console.error(error);
        return [false, "requested route of \"".concat(routeString.toUpperCase(), "\" is invalid")];
      }

      return this.absorbRouteModel(routeModel);
    }
    /**
     * Move the current leg into the `#_previousLegCollection`
     *
     * This also results in the `#nextLeg` becoming the `#currentLeg`
     *
     * @for RouteModel
     * @method moveToNextLeg
     */

  }, {
    key: "moveToNextLeg",
    value: function moveToNextLeg() {
      var _this$_previousLegCol;

      if (!this.hasNextLeg()) {
        return;
      }

      var legToMove = this._legCollection.splice(0, 1);

      (_this$_previousLegCol = this._previousLegCollection).push.apply(_this$_previousLegCol, _toConsumableArray(legToMove));
    }
    /**
     * Skip ahead to the waypoint with the specified name, if it exists
     *
     * @for RouteModel
     * @method skipToWaypointName
     * @param waypointName {string}
     * @return {boolean} success of operation
     */

  }, {
    key: "skipToWaypointName",
    value: function skipToWaypointName(waypointName) {
      var _this$_previousLegCol2;

      if (!this.hasWaypointName(waypointName)) {
        return false;
      }

      if (this.currentLeg.hasWaypointName(waypointName)) {
        return this.currentLeg.skipToWaypointName(waypointName);
      }

      var legIndex = (0, _findIndex2["default"])(this._legCollection, function (legModel) {
        return legModel.hasWaypointName(waypointName);
      });

      var legModelsToMove = this._legCollection.splice(0, legIndex);

      (_this$_previousLegCol2 = this._previousLegCollection).push.apply(_this$_previousLegCol2, _toConsumableArray(legModelsToMove));

      return this.currentLeg.skipToWaypointName(waypointName);
    }
    /**
     * Ensure the SID leg has the specified departure runway as the entry point
     *
     * @for RouteModel
     * @method updateSidLegForDepartureRunwayModel
     * @param runwayModel {RunwayModel}
     */

  }, {
    key: "updateSidLegForDepartureRunwayModel",
    value: function updateSidLegForDepartureRunwayModel(runwayModel) {
      if (!this.hasSidLeg()) {
        return;
      }

      var sidLegModel = this._findSidLeg();

      sidLegModel.updateSidLegForDepartureRunwayModel(runwayModel);
    }
    /**
    * Ensure the STAR leg has the specified arrival runway as the exit point
    *
    * @for RouteModel
    * @method updateStarLegForArrivalRunwayModel
    * @param runwayModel {RunwayModel}
    */

  }, {
    key: "updateStarLegForArrivalRunwayModel",
    value: function updateStarLegForArrivalRunwayModel(runwayModel) {
      if (!this.hasStarLeg()) {
        return;
      }

      if (!this.isRunwayModelValidForStar(runwayModel)) {
        console.error("Received Runway ".concat(runwayModel.name, ", which is not valid for the assigned STAR. ") + 'The runway should have been validated before passing it to this method!');
        return;
      }

      var originalCurrentWaypointName = this.currentWaypoint.name;
      var nextExitName = "".concat(this.getArrivalRunwayAirportIcao().toUpperCase()).concat(runwayModel.name);

      var starLegIndex = this._findStarLegIndex();

      var amendedStarLegModel = this._createAmendedStarLegUsingDifferentExitName(nextExitName, starLegIndex);

      this._legCollection[starLegIndex] = amendedStarLegModel;
      this.skipToWaypointName(originalCurrentWaypointName);
    } // ------------------------------ PRIVATE ------------------------------

    /**
     * Append a provided route model onto the end of this RouteModel
     *
     * This method only serves to call the method that contains the appropriate logic
     * based on the type of leg in which the divergent waypoint resides, since this
     * heavily weighs in to how the merging of the routes should be done. Note that
     * the #_legCollection will be mutated in this process.
     *
     * @for RouteModel
     * @method _appendRouteModelBeginningAtWaypointName
     * @param divergentWaypointName {string} name of waypoint at which the two routes have continuity
     * @param routeModel {RouteModel} the RouteModel to be absorbed into this
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "_appendRouteModelBeginningAtWaypointName",
    value: function _appendRouteModelBeginningAtWaypointName(divergentWaypointName, routeModel) {
      var indexOfDivergentLeg = this._findIndexOfLegContainingWaypointName(divergentWaypointName);

      var divergentLeg = this._legCollection[indexOfDivergentLeg];

      if (divergentLeg.isAirwayLeg) {
        return this._appendRouteModelOutOfAirwayLeg(divergentWaypointName, routeModel);
      }

      if (divergentLeg.isDirectLeg) {
        return this._appendRouteModelOutOfDirectLeg(divergentWaypointName, routeModel);
      }

      if (divergentLeg.isSidLeg) {
        return this._appendRouteModelOutOfSidLeg(divergentWaypointName, routeModel);
      }

      if (divergentLeg.isStarLeg) {
        return this._appendRouteModelOutOfStarLeg(divergentWaypointName, routeModel);
      }

      throw new TypeError("Expected known leg type, but received \"".concat(divergentLeg.legType, "\" ") + 'type leg, preventing ability to determine the appropriate route merging strategy!');
    }
    /**
     * Append a provided route model into this RouteModel when the divergent waypoint is in an airway leg
     *
     * This should only ever be called by `._appendRouteModelBeginningAtWaypointName()`
     *
     * @for RouteModel
     * @method _appendRouteModelOutOfAirwayLeg
     * @param divergentWaypointName {string} name of waypoint at which the two routes have continuity
     * @param routeModel {RouteModel} the RouteModel to be absorbed into this
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "_appendRouteModelOutOfAirwayLeg",
    value: function _appendRouteModelOutOfAirwayLeg(divergentWaypointName, routeModel) {
      var indexOfDivergentLeg = this._findIndexOfLegContainingWaypointName(divergentWaypointName);

      var amendedAirwayLeg = this._createAmendedAirwayLegUsingDifferentExitName(divergentWaypointName, indexOfDivergentLeg);

      this._legCollection.splice(indexOfDivergentLeg);

      this._legCollection = [].concat(_toConsumableArray(this._legCollection), [amendedAirwayLeg], _toConsumableArray(routeModel.legCollection));
      var readback = {};
      readback.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
      readback.say = 'rerouting as requested';
      return [true, readback];
    }
    /**
     * Append a provided route model into this RouteModel when the divergent waypoint is in a direct leg
     *
     * This should only ever be called by `._appendRouteModelBeginningAtWaypointName()`
     *
     * @for RouteModel
     * @method _appendRouteModelOutOfDirectLeg
     * @param divergentWaypointName {string} name of waypoint at which the two routes have continuity
     * @param routeModel {RouteModel} the RouteModel to be absorbed into this
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "_appendRouteModelOutOfDirectLeg",
    value: function _appendRouteModelOutOfDirectLeg(divergentWaypointName, routeModel) {
      var indexOfDivergentLeg = this._findIndexOfLegContainingWaypointName(divergentWaypointName);

      this._legCollection.splice(indexOfDivergentLeg);

      this._legCollection = this._legCollection.concat(routeModel.legCollection);
      var readback = {};
      readback.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
      readback.say = 'rerouting as requested';
      return [true, readback];
    }
    /**
     * Append a provided route model into this RouteModel when the divergent waypoint is in a SID leg
     *
     * This should only ever be called by `._appendRouteModelBeginningAtWaypointName()`
     *
     * @for RouteModel
     * @method _appendRouteModelOutOfSidLeg
     * @param divergentWaypointName {string} name of waypoint at which the two routes have continuity
     * @param routeModel {RouteModel} the RouteModel to be absorbed into this
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "_appendRouteModelOutOfSidLeg",
    value: function _appendRouteModelOutOfSidLeg(divergentWaypointName, routeModel) {
      var indexOfDivergentLeg = this._findIndexOfLegContainingWaypointName(divergentWaypointName);

      var remainingLegWaypointsAsLegs = this._createLegsFromSidWaypointsBeforeWaypointName(divergentWaypointName, indexOfDivergentLeg);

      this._legCollection.splice(indexOfDivergentLeg);

      this._legCollection = [].concat(_toConsumableArray(this._legCollection), _toConsumableArray(remainingLegWaypointsAsLegs), _toConsumableArray(routeModel.legCollection));
      var readback = {};
      readback.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
      readback.say = 'rerouting as requested';
      return [true, readback];
    }
    /**
     * Append a provided route model into this RouteModel when the divergent waypoint is in a STAR leg
     *
     * This should only ever be called by `._appendRouteModelBeginningAtWaypointName()`
     *
     * @for RouteModel
     * @method _appendRouteModelOutOfSidLeg
     * @param divergentWaypointName {string} name of waypoint at which the two routes have continuity
     * @param routeModel {RouteModel} the RouteModel to be absorbed into this
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "_appendRouteModelOutOfStarLeg",
    value: function _appendRouteModelOutOfStarLeg(divergentWaypointName, routeModel) {
      var indexOfDivergentLeg = this._findIndexOfLegContainingWaypointName(divergentWaypointName);

      var divergentLegModel = this._legCollection[indexOfDivergentLeg];

      if (divergentLegModel.procedureHasExit(divergentWaypointName)) {
        var amendedStarLeg = this._createAmendedStarLegUsingDifferentExitName(divergentWaypointName, indexOfDivergentLeg);

        this._legCollection.splice(indexOfDivergentLeg);

        this._legCollection = [].concat(_toConsumableArray(this._legCollection), [amendedStarLeg], _toConsumableArray(routeModel.legCollection));
        var _readback = {};
        _readback.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
        _readback.say = 'rerouting as requested';
        return [true, _readback];
      }

      var remainingLegWaypointsAsLegs = this._createLegsFromStarWaypointsBeforeWaypointName(divergentWaypointName, indexOfDivergentLeg);

      this._legCollection.splice(indexOfDivergentLeg);

      this._legCollection = [].concat(_toConsumableArray(this._legCollection), _toConsumableArray(remainingLegWaypointsAsLegs), _toConsumableArray(routeModel._legCollection));
      var readback = {};
      readback.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
      readback.say = 'rerouting as requested';
      return [true, readback];
    }
    /**
    * Combine all provided route strings
    *
    * This enables us to get a route string for a SPECIFIABLE series of legs, which
    * may be a portion of the `#_legCollection` or of the `#_previousLegCollection`,
    * or any combination thereof, including manipulated route strings.
    *
    * @for RouteModel
    * @method _combineRouteStrings
    * @param legRouteStrings {array<string>}
    * @return {string}
    */

  }, {
    key: "_combineRouteStrings",
    value: function _combineRouteStrings(legRouteStrings) {
      var directRouteSegments = [(0, _first2["default"])(legRouteStrings)];

      for (var i = 1; i < legRouteStrings.length; i++) {
        var exitOfPreviousLeg = (0, _last4["default"])(legRouteStrings[i - 1].split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER));
        var leg = legRouteStrings[i];
        var legEntry = (0, _first2["default"])(leg.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER));

        if (legEntry === exitOfPreviousLeg) {
          var indexOfPreviousLeg = directRouteSegments.length - 1;
          var legRouteStringWithoutEntry = leg.replace(legEntry, '');
          directRouteSegments[indexOfPreviousLeg] += legRouteStringWithoutEntry;
          continue;
        }

        directRouteSegments.push(leg);
      }

      return directRouteSegments.join(_routeConstants.DIRECT_SEGMENT_DIVIDER);
    }
    /**
     * Create an airway leg based on the provided one, except with the new specified entry
     *
     * NOTE: this assumes the entry fix provided has already been verified as valid for this airway
     *
     * We know that `_createAmendedConvergentLeg()` and `_prependRouteModelIntoAirwayLeg()` both
     * are called only in situations where a requested route amendment ends at a fix that was already
     * included in the #_waypointCollection of an airway leg of the previous route. If this method is
     * called by either of them, we can be confident that the `entryFixName` is on the airway.
     *
     * @for RouteModel
     * @method _createAmendedAirwayLegUsingDifferentEntryName
     * @param entryFixName {string} name of airway entry to use for the new airway leg
     * @param legIndex {number} index of leg in the #_legCollection
     * @return {LegModel}
     */

  }, {
    key: "_createAmendedAirwayLegUsingDifferentEntryName",
    value: function _createAmendedAirwayLegUsingDifferentEntryName(entryFixName, legIndex) {
      var convergentLegModel = this._legCollection[legIndex];
      var airwayName = convergentLegModel.getAirwayName();
      var exitFixName = convergentLegModel.getExitFixName();
      var amendedAirwayRouteString = (0, _navigationUtilities.assembleProceduralRouteString)(entryFixName, airwayName, exitFixName);
      var amendedAirwayLeg = new _LegModel["default"](amendedAirwayRouteString);
      return amendedAirwayLeg;
    }
    /**
     * Create an airway leg based on the provided one, except with the new specified exit
     *
     * NOTE: this assumes the exit fix provided has already been verified as valid for this airway
     *
     * @for RouteModel
     * @method _createAmendedAirwayLegUsingDifferentExitName
     * @param exitFixName {string} name of airway exit to use for the new airway leg
     * @param legIndex {number} index of leg in the #_legCollection
     * @return {LegModel}
     */

  }, {
    key: "_createAmendedAirwayLegUsingDifferentExitName",
    value: function _createAmendedAirwayLegUsingDifferentExitName(exitFixName, legIndex) {
      var divergentLeg = this._legCollection[legIndex];
      var airwayName = divergentLeg.getAirwayName();
      var entryFixName = divergentLeg.getEntryFixName();
      var amendedAirwayRouteString = (0, _navigationUtilities.assembleProceduralRouteString)(entryFixName, airwayName, exitFixName);
      var amendedAirwayLeg = new _LegModel["default"](amendedAirwayRouteString);
      return amendedAirwayLeg;
    }
    /**
     * Amend the leg from #_legCollection at which a provided RouteModel converges with this model, such
     * that the amended leg begins at the point of convergence.
     *
     * @for RouteModel
     * @method _createAmendedConvergentLeg
     * @param indexOfConvergentLegModel {number} index of leg which intersects with the provided RouteModel
     * @param endWaypointName {string} name of the waypoint within that leg at which the routes converge
     * @return {array<LegModel>}
     */

  }, {
    key: "_createAmendedConvergentLeg",
    value: function _createAmendedConvergentLeg(indexOfConvergentLegModel, endWaypointName) {
      var convergentLegModel = this._legCollection[indexOfConvergentLegModel];

      if (convergentLegModel.isAirwayLeg) {
        return [this._createAmendedAirwayLegUsingDifferentEntryName(endWaypointName, indexOfConvergentLegModel)];
      }

      if (convergentLegModel.isDirectLeg) {
        return [];
      }

      if (convergentLegModel.isSidLeg) {
        var firstWaypointName = (0, _first2["default"])(convergentLegModel.waypoints).name;

        if (firstWaypointName === endWaypointName) {
          return [convergentLegModel];
        }

        return this._createLegsFromSidWaypointsAfterWaypointName(endWaypointName, indexOfConvergentLegModel);
      }

      if (convergentLegModel.isStarLeg) {
        var _firstWaypointName = (0, _first2["default"])(convergentLegModel.waypoints).name;

        if (_firstWaypointName === endWaypointName) {
          return [convergentLegModel];
        }

        if (convergentLegModel.procedureHasEntry(endWaypointName)) {
          return [this._createAmendedStarLegUsingDifferentEntryName(endWaypointName, indexOfConvergentLegModel)];
        }

        return this._createLegsFromStarWaypointsAfterWaypointName(endWaypointName, indexOfConvergentLegModel);
      }

      throw new TypeError("Expected known leg type, but received type \"".concat(convergentLegModel.legType, "\""));
    }
    /**
     * Amend the leg from #_legCollection at which a provided RouteModel diverges from this model, such
     * that the amended leg ends at the point of divergence.
     *
     * @for RouteModel
     * @method _createAmendedDivergentLeg
     * @param indexOfDivergentLegModel {number} index of leg which intersects with the provided RouteModel
     * @param startWaypointName {string} name of the waypoint within that leg at which the routes diverge
     * @return {array<LegModel>}
     */

  }, {
    key: "_createAmendedDivergentLeg",
    value: function _createAmendedDivergentLeg(indexOfDivergentLegModel, startWaypointName) {
      var divergentLegModel = this._legCollection[indexOfDivergentLegModel];

      if (divergentLegModel.isAirwayLeg) {
        return [this._createAmendedAirwayLegUsingDifferentExitName(startWaypointName, indexOfDivergentLegModel)];
      }

      if (divergentLegModel.isDirectLeg) {
        return [];
      }

      if (divergentLegModel.isSidLeg) {
        var endingWaypointName = (0, _last4["default"])(divergentLegModel.waypoints).name;

        if (endingWaypointName === startWaypointName) {
          return [divergentLegModel];
        }

        return this._createLegsFromSidWaypointsBeforeWaypointName(startWaypointName, indexOfDivergentLegModel);
      }

      if (divergentLegModel.isStarLeg) {
        var _endingWaypointName = (0, _last4["default"])(divergentLegModel.waypoints).name;

        if (_endingWaypointName === startWaypointName) {
          return [divergentLegModel];
        }

        if (divergentLegModel.procedureHasExit(startWaypointName)) {
          return [this._createAmendedStarLegUsingDifferentExitName(startWaypointName, indexOfDivergentLegModel)];
        }

        return this._createLegsFromStarWaypointsBeforeWaypointName(startWaypointName, indexOfDivergentLegModel);
      }

      throw new TypeError("Expected known leg type, but received type \"".concat(divergentLegModel.legType, "\""));
    }
    /**
     * Accept a SID leg, and explode it into direct legs, including only waypoints before the specified one
     *
     * @for RouteModel
     * @method _createLegsFromSidWaypointsBeforeWaypointName
     * @param waypointName {string} name of waypoint where we begin to discard waypoints
     * @param legIndex {number} index of leg in the #_legCollection
     * @return {array<LegModel>}
     */

  }, {
    key: "_createLegsFromSidWaypointsBeforeWaypointName",
    value: function _createLegsFromSidWaypointsBeforeWaypointName(waypointName, legIndex) {
      var divergentLeg = this._legCollection[legIndex];
      var waypointModels = divergentLeg.getAllWaypointModelsBeforeWaypointName(waypointName);

      var remainingLegWaypointsAsLegs = this._createLegModelsFromWaypointModels(waypointModels);

      return remainingLegWaypointsAsLegs;
    }
    /**
     * Accept a STAR leg, and explode it into direct legs, including only waypoints after the specified one
     *
     * @for RouteModel
     * @method _createLegsFromStarWaypointsAfterWaypointName
     * @param waypointName {string} name of waypoint after which we begin to keep waypoints
     * @param legIndex {number} index of leg in the #_legCollection
     * @return {array<LegModel>}
     */

  }, {
    key: "_createLegsFromStarWaypointsAfterWaypointName",
    value: function _createLegsFromStarWaypointsAfterWaypointName(waypointName, legIndex) {
      var convergentLegModel = this._legCollection[legIndex];
      var waypointModels = convergentLegModel.getAllWaypointModelsAfterWaypointName(waypointName);

      var remainingLegWaypointsAsLegs = this._createLegModelsFromWaypointModels(waypointModels);

      return remainingLegWaypointsAsLegs;
    }
    /**
     * Accept a STAR leg, and explode it into direct legs, including only waypoints before the specified one
     *
     * @for RouteModel
     * @method _createLegsFromStarWaypointsBeforeWaypointName
     * @param waypointName {string} name of waypoint where we begin to discard waypoints
     * @param legIndex {number} index of leg in the #_legCollection
     * @return {array<LegModel>}
     */

  }, {
    key: "_createLegsFromStarWaypointsBeforeWaypointName",
    value: function _createLegsFromStarWaypointsBeforeWaypointName(waypointName, legIndex) {
      var divergentLegModel = this._legCollection[legIndex];
      var waypointModels = divergentLegModel.getAllWaypointModelsBeforeWaypointName(waypointName);

      var remainingLegWaypointsAsLegs = this._createLegModelsFromWaypointModels(waypointModels);

      return remainingLegWaypointsAsLegs;
    }
    /**
     * Return a STAR leg based on the provided leg, except with the new specified entry
     *
     * @for RouteModel
     * @method _createAmendedStarLegUsingDifferentEntryName
     * @param entryFixName {string} name of STAR entry to use for the new STAR leg
     * @param legIndex {number} index of leg in the #_legCollection
     * @return {LegModel}
     */

  }, {
    key: "_createAmendedStarLegUsingDifferentEntryName",
    value: function _createAmendedStarLegUsingDifferentEntryName(entryFixName, legIndex) {
      var convergentLegModel = this._legCollection[legIndex];
      var procedureIcao = convergentLegModel.getProcedureIcao();
      var exitFixName = convergentLegModel.getExitFixName();
      var amendedStarRouteString = (0, _navigationUtilities.assembleProceduralRouteString)(entryFixName, procedureIcao, exitFixName);
      var amendedStarLeg = new _LegModel["default"](amendedStarRouteString);
      return amendedStarLeg;
    }
    /**
     * Return a STAR leg based on the provided leg, except with the new specified exit
     *
     * @for RouteModel
     * @method _createAmendedStarLegUsingDifferentExitName
     * @param exitFixName {string} name of STAR exit to use for the new STAR leg
     * @param legIndex {number} index of leg in the #_legCollection
     * @return {LegModel}
     */

  }, {
    key: "_createAmendedStarLegUsingDifferentExitName",
    value: function _createAmendedStarLegUsingDifferentExitName(exitFixName, legIndex) {
      var divergentLegModel = this._legCollection[legIndex];
      var procedureIcao = divergentLegModel.getProcedureIcao();
      var entryFixName = divergentLegModel.getEntryFixName();
      var amendedStarRouteString = (0, _navigationUtilities.assembleProceduralRouteString)(entryFixName, procedureIcao, exitFixName);
      var amendedStarLeg = new _LegModel["default"](amendedStarRouteString);
      return amendedStarLeg;
    }
    /**
     * Accept a SID leg, and explode it into direct legs, including only waypoints after the specified one
     *
     * @for RouteModel
     * @method _createLegsFromSidWaypointsAfterWaypointName
     * @param waypointName {string} name of waypoint where we begin to keep waypoints
     * @param legIndex {number} index of leg in the #_legCollection
     * @return {array<LegModel>}
     */

  }, {
    key: "_createLegsFromSidWaypointsAfterWaypointName",
    value: function _createLegsFromSidWaypointsAfterWaypointName(waypointName, legIndex) {
      var convergentLeg = this._legCollection[legIndex];
      var waypointModels = convergentLeg.getAllWaypointModelsAfterWaypointName(waypointName);

      var remainingLegWaypointsAsLegs = this._createLegModelsFromWaypointModels(waypointModels);

      return remainingLegWaypointsAsLegs;
    } // TODO: Also add support for preserving waypoint data (restrictions, hold instructions, etc)

    /**
     * Return an array of direct LegModels, one for each of the proided WaypointModels
     *
     * @for RouteModel
     * @method _createLegModelsFromWaypointModels
     * @param waypointModels {array<WaypointModel>} waypoint models to convert to direct legs
     * @return {array<LegModel>}
     */

  }, {
    key: "_createLegModelsFromWaypointModels",
    value: function _createLegModelsFromWaypointModels(waypointModels) {
      return (0, _map2["default"])(waypointModels, function (waypointModel) {
        return new _LegModel["default"](waypointModel.name);
      });
    }
    /**
     * Divide a long route string into segments that can be individually represented by a `LegModel`
     *
     * @for RouteModel
     * @method _divideRouteStringIntoSegments
     * @param routeString {string}
     * @return {array<string>}
     * @private
     */

  }, {
    key: "_divideRouteStringIntoSegments",
    value: function _divideRouteStringIntoSegments(routeString) {
      if (!(0, _isString2["default"])(routeString)) {
        throw new TypeError("Expected routeString's type to be string, but received '".concat(_typeof(routeString), "'"));
      }

      if (routeString.indexOf(' ') !== _globalConstants.INVALID_INDEX) {
        throw new TypeError("Expected a route string that does not contain spaces, but received '".concat(routeString, "'"));
      }

      var chainedRouteStrings = routeString.split(_routeConstants.DIRECT_SEGMENT_DIVIDER);
      var segmentRouteStrings = []; // deal with chained route strings (eg 'KSFO28R.OFFSH9.SXC.V458.IPL')

      for (var i = 0; i < chainedRouteStrings.length; i++) {
        var chainedRouteString = chainedRouteStrings[i];
        var elementsInChain = chainedRouteString.split(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER);
        var firstSegment = elementsInChain.splice(0, 3);
        var segments = [firstSegment].concat(_toConsumableArray((0, _chunk2["default"])(elementsInChain, 2)));
        segmentRouteStrings.push(firstSegment.join(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER));

        for (var j = 1; j < segments.length; j++) {
          var exitOfPreviousSegment = (0, _last4["default"])(segments[j - 1]);
          var procedureAndExitOfSegment = segments[j].join(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER);
          segmentRouteStrings.push("".concat(exitOfPreviousSegment, ".").concat(procedureAndExitOfSegment));
        }
      }

      return segmentRouteStrings;
    }
    /**
    * Return the name of the first waypoint at which this route and the specified route converge
    * For routes that do not have continuity, this function will return undefined.
    *
    * @for RouteModel
    * @method _findConvergentWaypointNameWithRouteModel
    * @param routeModel {RouteModel}
    * @return {string} name of the first waypoint where the routes converge
    */

  }, {
    key: "_findConvergentWaypointNameWithRouteModel",
    value: function _findConvergentWaypointNameWithRouteModel(routeModel) {
      var currentRouteWaypointNames = (0, _map2["default"])(this.waypoints, function (waypointModel) {
        return waypointModel.name;
      });
      var nextRouteWaypointNames = (0, _map2["default"])(routeModel.waypoints, function (waypointModel) {
        return waypointModel.name;
      });
      return (0, _first2["default"])((0, _intersection2["default"])(currentRouteWaypointNames, nextRouteWaypointNames));
    }
    /**
     * Return the index of the leg in the #_legCollection that contains the specified waypoint name
     *
     * @for RouteModel
     * @method _findIndexOfLegContainingWaypointName
     * @return {number}
     */

  }, {
    key: "_findIndexOfLegContainingWaypointName",
    value: function _findIndexOfLegContainingWaypointName(waypointName) {
      return (0, _findIndex2["default"])(this._legCollection, function (legModel) {
        return legModel.hasWaypointName(waypointName);
      });
    }
    /**
     * Return the index of the SID leg
     *
     * If for some reason there are multiple, this returns the first one.
     * This search does NOT include legs in the `#_previousLegCollection`.
     *
     * @for RouteModel
     * @method _findSidLegIndex
     * @return {number}
     * @private
     */

  }, {
    key: "_findSidLegIndex",
    value: function _findSidLegIndex() {
      return (0, _findIndex2["default"])(this._legCollection, function (legModel) {
        return legModel.isSidLeg;
      });
    }
    /**
     * Return the SID leg
     *
     * If for some reason there are multiple, this returns the first one.
     * This search does NOT include legs in the `#_previousLegCollection`.
     *
     * @for RouteModel
     * @method findSidLeg
     * @return {ProcedureModel}
     */

  }, {
    key: "_findSidLeg",
    value: function _findSidLeg() {
      return this._legCollection.find(function (legModel) {
        return legModel.isSidLeg;
      });
    }
    /**
     * Return the index of the STAR leg within the `#_legCollection`
     *
     * If for some reason there are multiple, this returns the first one.
     * This search does NOT include legs in the `#_previousLegCollection`.
     *
     * @for RouteModel
     * @method _findStarLegIndex
     * @return {number}
     * @private
     */

  }, {
    key: "_findStarLegIndex",
    value: function _findStarLegIndex() {
      return (0, _findIndex2["default"])(this._legCollection, function (legModel) {
        return legModel.isStarLeg;
      });
    }
    /**
     * Generate an array of `LegModel`s according to the provided route string
     *
     * @for RouteModel
     * @method _generateLegsFromRouteString
     * @param routeString {string}
     * @return {array<LegModel>}
     * @private
     */

  }, {
    key: "_generateLegsFromRouteString",
    value: function _generateLegsFromRouteString(routeString) {
      var segments = this._divideRouteStringIntoSegments(routeString);

      var legs = (0, _map2["default"])(segments, function (segmentRouteString) {
        return new _LegModel["default"](segmentRouteString);
      });
      return legs;
    }
    /**
     * Return a single continuous array containing the #_previousLegCollection AND #_legCollection
     *
     * @for RouteModel
     * @method _getPastAndPresentLegModels
     * @return {array<LegModel>}
     */

  }, {
    key: "_getPastAndPresentLegModels",
    value: function _getPastAndPresentLegModels() {
      return [].concat(_toConsumableArray(this._previousLegCollection), _toConsumableArray(this._legCollection));
    }
    /**
     * Remove portions of the route between the specified waypoint names, and insert the provided RouteModel
     *
     * This will also result in amending (or exploding into direct legs) any leg with which
     * the provided RouteModel intersects in the middle. For example, if the provided RouteModel
     * intersects an airway leg at a waypoint somewhere other than the entry or exit of that airway
     * leg, this method will change the entry/exit of the airway leg such that it aligns with the
     * provided RouteModel.
     *
     * @for RouteModel
     * @method _overwriteRouteBetweenWaypointNames
     * @param startWaypointName {string}
     * @param endWaypointName {string}
     * @param routeModel {RouteModel}
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "_overwriteRouteBetweenWaypointNames",
    value: function _overwriteRouteBetweenWaypointNames(startWaypointName, endWaypointName, routeModel) {
      var legCollection = this._legCollection.slice(0);

      var indexOfDivergentLegModel = this._findIndexOfLegContainingWaypointName(startWaypointName);

      var indexOfConvergentLegModel = this._findIndexOfLegContainingWaypointName(endWaypointName);

      var amendedDivergentLegModels = this._createAmendedDivergentLeg(indexOfDivergentLegModel, startWaypointName);

      var amendedConvergentLegModels = this._createAmendedConvergentLeg(indexOfConvergentLegModel, endWaypointName);

      var endingLegCollection = legCollection.splice(indexOfConvergentLegModel + 1);
      legCollection.splice(indexOfDivergentLegModel);
      var beginningLegCollection = legCollection;
      this._legCollection = [].concat(_toConsumableArray(beginningLegCollection), _toConsumableArray(amendedDivergentLegModels), _toConsumableArray(routeModel.legCollection), _toConsumableArray(amendedConvergentLegModels), _toConsumableArray(endingLegCollection));
      var readback = {};
      readback.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
      readback.say = 'rerouting as requested';
      return [true, readback];
    }
    /**
     * Prepend a provided route model into this RouteModel
     *
     * This method only serves to call the method that contains the appropriate logic
     * based on the type of leg in which the convergent waypoint resides, since this
     * heavily weighs in to how the merging of the routes should be done.
     *
     * @for RouteModel
     * @method _prependRouteModelEndingAtWaypointName
     * @param convergentWaypointName {string} name of waypoint at which the two routes have continuity
     * @param routeModel {RouteModel} the RouteModel to be absorbed into this
     */

  }, {
    key: "_prependRouteModelEndingAtWaypointName",
    value: function _prependRouteModelEndingAtWaypointName(convergentWaypointName, routeModel) {
      var indexOfConvergentLegModel = this._findIndexOfLegContainingWaypointName(convergentWaypointName);

      var convergentLegModel = this._legCollection[indexOfConvergentLegModel];

      if (convergentLegModel.isAirwayLeg) {
        return this._prependRouteModelIntoAirwayLeg(convergentWaypointName, routeModel);
      }

      if (convergentLegModel.isDirectLeg) {
        return this._prependRouteModelIntoDirectLeg(convergentWaypointName, routeModel);
      }

      if (convergentLegModel.isSidLeg) {
        return this._prependRouteModelIntoSidLeg(convergentWaypointName, routeModel);
      }

      if (convergentLegModel.isStarLeg) {
        return this._prependRouteModelIntoStarLeg(convergentWaypointName, routeModel);
      }

      throw new TypeError("Expected known leg type, but received \"".concat(convergentLegModel.legType, "\" ") + 'type leg, preventing ability to determine the appropriate route merging strategy!');
    }
    /**
     * Prepend a provided route model into this RouteModel when the convergent waypoint is in an airway leg
     *
     * This should only ever be called by `._prependRouteModelEndingAtWaypointName()`
     *
     * @for RouteModel
     * @method _prependRouteModelIntoAirwayLeg
     * @param convergentWaypointName {string} name of waypoint at which the two routes have continuity
     * @param routeModel {RouteModel} the RouteModel to be absorbed into this
     */

  }, {
    key: "_prependRouteModelIntoAirwayLeg",
    value: function _prependRouteModelIntoAirwayLeg(convergentWaypointName, routeModel) {
      var indexOfConvergentLegModel = this._findIndexOfLegContainingWaypointName(convergentWaypointName);

      var amendedAirwayLeg = this._createAmendedAirwayLegUsingDifferentEntryName(convergentWaypointName, indexOfConvergentLegModel);

      this._legCollection = [].concat(_toConsumableArray(routeModel.legCollection), [amendedAirwayLeg], _toConsumableArray(this._legCollection.splice(indexOfConvergentLegModel + 1)));
      var readback = {};
      readback.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
      readback.say = 'rerouting as requested';
      return [true, readback];
    }
    /**
     * Prepend a provided route model into this RouteModel when the convergent waypoint is in a direct leg
     *
     * This should only ever be called by `._prependRouteModelEndingAtWaypointName()`
     *
     * @for RouteModel
     * @method _prependRouteModelIntoDirectLeg
     * @param convergentWaypointName {string} name of waypoint at which the two routes have continuity
     * @param routeModel {RouteModel} the RouteModel to be absorbed into this
     */

  }, {
    key: "_prependRouteModelIntoDirectLeg",
    value: function _prependRouteModelIntoDirectLeg(convergentWaypointName, routeModel) {
      var indexOfConvergentLegModel = this._findIndexOfLegContainingWaypointName(convergentWaypointName);

      this._legCollection = [].concat(_toConsumableArray(routeModel.legCollection), _toConsumableArray(this._legCollection.splice(indexOfConvergentLegModel + 1)));
      var readback = {};
      readback.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
      readback.say = 'rerouting as requested';
      return [true, readback];
    }
    /**
     * Prepend a provided route model into this RouteModel when the convergent waypoint is in a SID leg
     *
     * This should only ever be called by `._prependRouteModelEndingAtWaypointName()`
     *
     * @for RouteModel
     * @method _prependRouteModelIntoSidLeg
     * @param convergentWaypointName {string} name of waypoint at which the two routes have continuity
     * @param routeModel {RouteModel} the RouteModel to be absorbed into this
     */

  }, {
    key: "_prependRouteModelIntoSidLeg",
    value: function _prependRouteModelIntoSidLeg(convergentWaypointName, routeModel) {
      var indexOfConvergentLegModel = this._findIndexOfLegContainingWaypointName(convergentWaypointName);

      var remainingLegWaypointsAsLegs = this._createLegsFromSidWaypointsAfterWaypointName(convergentWaypointName, indexOfConvergentLegModel);

      this._legCollection = [].concat(_toConsumableArray(routeModel.legCollection), _toConsumableArray(remainingLegWaypointsAsLegs), _toConsumableArray(this._legCollection.splice(indexOfConvergentLegModel + 1)));
      var readback = {};
      readback.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
      readback.say = 'rerouting as requested';
      return [true, readback];
    }
    /**
     * Prepend a provided route model into this RouteModel when the convergent waypoint is in a STAR leg
     *
     * This should only ever be called by `._prependRouteModelEndingAtWaypointName()`
     *
     * @for RouteModel
     * @method _prependRouteModelIntoStarLeg
     * @param convergentWaypointName {string} name of waypoint at which the two routes have continuity
     * @param routeModel {RouteModel} the RouteModel to be absorbed into this
     */

  }, {
    key: "_prependRouteModelIntoStarLeg",
    value: function _prependRouteModelIntoStarLeg(convergentWaypointName, routeModel) {
      var indexOfConvergentLegModel = this._findIndexOfLegContainingWaypointName(convergentWaypointName);

      var convergentLegModel = this._legCollection[indexOfConvergentLegModel];

      if (convergentLegModel.procedureHasEntry(convergentWaypointName)) {
        var amendedStarLeg = this._createAmendedStarLegUsingDifferentEntryName(convergentWaypointName, indexOfConvergentLegModel);

        this._legCollection = [].concat(_toConsumableArray(routeModel.legCollection), [amendedStarLeg], _toConsumableArray(this._legCollection.splice(indexOfConvergentLegModel + 1)));
        var _readback2 = {};
        _readback2.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
        _readback2.say = 'rerouting as requested';
        return [true, _readback2];
      }

      var remainingLegWaypointsAsLegs = this._createLegsFromStarWaypointsAfterWaypointName(convergentWaypointName, indexOfConvergentLegModel);

      this._legCollection = [].concat(_toConsumableArray(routeModel.legCollection), _toConsumableArray(remainingLegWaypointsAsLegs), _toConsumableArray(this._legCollection.splice(indexOfConvergentLegModel + 1)));
      var readback = {};
      readback.log = "rerouting to: ".concat(this.getRouteStringWithSpaces());
      readback.say = 'rerouting as requested';
      return [true, readback];
    }
  }, {
    key: "currentLeg",
    get: function get() {
      if (this._legCollection.length < 1) {
        throw new TypeError('Expected the route to contain at least one leg');
      }

      return this._legCollection[0];
    }
    /**
     * Return the current `WaypointModel`
     *
     * @for RouteModel
     * @property currentWaypoint
     * @type {WaypointModel}
     */

  }, {
    key: "currentWaypoint",
    get: function get() {
      return this.currentLeg.currentWaypoint;
    }
    /**
     * Return the current `#_legCollection`
     *
     * @for RouteModel
     * @property legCollection
     * @type {array<LegModel>}
     */

  }, {
    key: "legCollection",
    get: function get() {
      return this._legCollection;
    }
    /**
     * Return the next `LegModel`, if it exists
     *
     * @for RouteModel
     * @property nextLeg
     * @type {LegModel}
     */

  }, {
    key: "nextLeg",
    get: function get() {
      if (!this.hasNextLeg()) {
        return null;
      }

      return this._legCollection[1];
    }
    /**
     * Return the next `WaypointModel`, from current or future leg
     *
     * @for RouteModel
     * @property nextWaypoint
     * @type {WaypointModel}
     */

  }, {
    key: "nextWaypoint",
    get: function get() {
      if (!this.hasNextWaypoint()) {
        return null;
      }

      if (this.currentLeg.hasNextWaypoint()) {
        return this.currentLeg.nextWaypoint;
      }

      return this.nextLeg.currentWaypoint;
    }
    /**
     * Return an array of all waypoints in all legs of the route
     *
     * @for RouteModel
     * @property waypoints
     * @type {array<WaypointModel>}
     */

  }, {
    key: "waypoints",
    get: function get() {
      return (0, _reduce2["default"])(this._legCollection, function (waypointList, legModel) {
        return waypointList.concat(legModel.waypoints);
      }, []);
    }
  }]);

  return RouteModel;
}(_BaseModel2["default"]);

exports["default"] = RouteModel;

},{"../../airport/AirportController":284,"../../airport/runway/RunwayModel":290,"../../base/BaseModel":295,"../../constants/globalConstants":310,"../../constants/routeConstants":314,"../../utilities/navigationUtilities":388,"./LegModel":269,"lodash/chunk":180,"lodash/findIndex":192,"lodash/first":196,"lodash/intersection":207,"lodash/isNil":219,"lodash/isString":224,"lodash/last":229,"lodash/map":231,"lodash/reduce":238,"lodash/without":252}],271:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));

var _FixCollection = _interopRequireDefault(require("../../navigationLibrary/FixCollection"));

var _globalConstants = require("../../constants/globalConstants");

var _waypointConstants = require("../../constants/waypointConstants");

var _navigationUtilities = require("../../utilities/navigationUtilities");

var _unitConverters = require("../../utilities/unitConverters");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * A navigation point within an aircraft's flight plan
 *
 * This may include various types of restrictions or holding information, all
 * of which are used by the aircraft to follow various routes and procedures
 * utilized by the controller.
 *
 * @class WaypointModel
 */
var WaypointModel =
/*#__PURE__*/
function () {
  /**
   * @for WaypointModel
   * @constructor
   */
  function WaypointModel(data) {
    _classCallCheck(this, WaypointModel);

    if (typeof data !== 'string' && !(0, _isArray2["default"])(data)) {
      throw new TypeError("Expected valid data to create WaypointModel but received ".concat(data));
    }

    this.altitudeMaximum = _globalConstants.INVALID_NUMBER;
    this.altitudeMinimum = _globalConstants.INVALID_NUMBER;
    this._speedMaximum = _globalConstants.INVALID_NUMBER;
    this._speedMinimum = _globalConstants.INVALID_NUMBER;
    this._defaultHoldParameters = Object.assign({}, _waypointConstants.DEFAULT_HOLD_PARAMETERS);
    this._holdParameters = Object.assign({}, _waypointConstants.DEFAULT_HOLD_PARAMETERS);
    this._isFlyOverWaypoint = false;
    this._isHoldWaypoint = false;
    this._isVectorWaypoint = false;
    this._name = '';
    this._positionModel = null;
    this.init(data);
  }
  /**
   * Returns whether this waypoint has a value for #altitudeMaximum
   *
   * @for WaypointModel
   * @property hasAltiudeMaximumRestriction
   * @type {boolean}
   */


  _createClass(WaypointModel, [{
    key: "init",
    // ------------------------------ LIFECYCLE ------------------------------

    /**
     * Initialize instance properties
     *
     * @for WaypointModel
     * @method init
     * @param data {object}
     * @chainable
     */
    value: function init(data) {
      var fixName = data;
      var restrictions = '';

      if ((0, _isArray2["default"])(data)) {
        if (data.length !== 2) {
          throw new TypeError("Expected restricted fix to have restrictions, but received ".concat(data));
        }

        var _data = _slicedToArray(data, 2);

        fixName = _data[0];
        restrictions = _data[1];
      }

      this._name = fixName.replace('@', '').replace('^', '');

      this._initSpecialWaypoint(fixName);

      this._applyRestrictions(restrictions);

      this._initializePosition();
    }
    /**
     * Reset instance properties
     *
     * @for WaypointModel
     * @method reset
     * @chainable
     */

  }, {
    key: "reset",
    value: function reset() {
      this.altitudeMaximum = _globalConstants.INVALID_NUMBER;
      this.altitudeMinimum = _globalConstants.INVALID_NUMBER;
      this._speedMaximum = _globalConstants.INVALID_NUMBER;
      this._speedMinimum = _globalConstants.INVALID_NUMBER;
      this._defaultHoldParameters = Object.assign({}, _waypointConstants.DEFAULT_HOLD_PARAMETERS);
      this._holdParameters = Object.assign({}, _waypointConstants.DEFAULT_HOLD_PARAMETERS);
      this._isFlyOverWaypoint = false;
      this._isHoldWaypoint = false;
      this._isVectorWaypoint = false;
      this._name = '';
      this._positionModel = null;
      return this;
    }
    /**
     * Initialize properties to make this waypoint a fly-over waypoint
     *
     * @for WaypointModel
     * @method _initFlyOverWaypoint
     * @private
     */

  }, {
    key: "_initFlyOverWaypoint",
    value: function _initFlyOverWaypoint() {
      this._isFlyOverWaypoint = true;
    }
    /**
     * Initialize properties to make this waypoint a hold waypoint
     *
     * @for WaypointModel
     * @method _initHoldWaypoint
     * @private
     */

  }, {
    key: "_initHoldWaypoint",
    value: function _initHoldWaypoint() {
      this._isHoldWaypoint = true;
    }
    /**
     * Perform additional initialization tasks as needed if waypoint is a flyover/hold/vector/etc waypoint
     *
     * @for WaypointModel
     * @method _initSpecialWaypoint
     * @param fixname {string} name of the fix, including any special characters
     */

  }, {
    key: "_initSpecialWaypoint",
    value: function _initSpecialWaypoint(fixName) {
      if (fixName.indexOf('^') !== _globalConstants.INVALID_INDEX) {
        this._initFlyOverWaypoint();

        return;
      }

      if (fixName.indexOf('@') !== _globalConstants.INVALID_INDEX) {
        this._initHoldWaypoint();

        return;
      }

      if (fixName.indexOf('#') !== _globalConstants.INVALID_INDEX) {
        this._initVectorWaypoint();
      }
    }
    /**
     * Initialize properties to make this waypoint a vector waypoint
     *
     * @for WaypointModel
     * @method _initVectorWaypoint
     * @private
     */

  }, {
    key: "_initVectorWaypoint",
    value: function _initVectorWaypoint() {
      this._isVectorWaypoint = true;
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Mark this waypoint as a hold waypoint
     *
     * @for WaypointModel
     * @method activateHold
     */

  }, {
    key: "activateHold",
    value: function activateHold() {
      this._isHoldWaypoint = true;
    }
    /**
     * Calculate the distance between two waypoint models
     *
     * @for WaypointModel
     * @method calculateBearingToWaypoint
     * @param waypointModel {WaypointModel}
     * @return {number} bearing, in radians
     */

  }, {
    key: "calculateBearingToWaypoint",
    value: function calculateBearingToWaypoint(waypointModel) {
      this._ensureNonVectorWaypointsForThisAndWaypoint(waypointModel);

      return this._positionModel.bearingToPosition(waypointModel.positionModel);
    }
    /**
     * Calculate the distance between two waypoint models
     *
     * @for WaypointModel
     * @method calculateDistanceToWaypoint
     * @param waypointModel {WaypointModel}
     * @return {number} distance, in nautical miles
     */

  }, {
    key: "calculateDistanceToWaypoint",
    value: function calculateDistanceToWaypoint(waypointModel) {
      this._ensureNonVectorWaypointsForThisAndWaypoint(waypointModel);

      return this._positionModel.distanceToPosition(waypointModel.positionModel);
    }
    /**
     * Cancel any hold at this waypoint
     *
     * @for WaypointModel
     * @method deactivateHold
     */

  }, {
    key: "deactivateHold",
    value: function deactivateHold() {
      this._isHoldWaypoint = false;
    }
    /**
     * Returns the name of the waypoint, amended for display to user
     *
     * Will return `[RNAV]` for waypoints prefixed with an underscore
     *
     * @for WaypointModel
     * @property name
     * @type {string}
     */

  }, {
    key: "getDisplayName",
    value: function getDisplayName() {
      if (this._name.indexOf(_waypointConstants.RNAV_WAYPOINT_PREFIX) !== _globalConstants.INVALID_INDEX) {
        return _waypointConstants.RNAV_WAYPOINT_DISPLAY_NAME;
      }

      return this._name;
    }
    /**
     * When `#_isVector` is true, this gets the heading that should be flown
     *
     * @for WaypointModel
     * @method _getVector
     * @type {number}
     */

  }, {
    key: "getVector",
    value: function getVector() {
      if (!this._isVectorWaypoint) {
        return;
      }

      var fixNameWithOutPoundSign = this._name.replace('#', '');

      var headingInDegrees = parseInt(fixNameWithOutPoundSign, _unitConverters.DECIMAL_RADIX);
      var headingInRadians = (0, _unitConverters.degreesToRadians)(headingInDegrees);
      return headingInRadians;
    }
    /**
     * Check for a maximum altitude restriction at or below the given altitude
     *
     * @for WaypointModel
     * @method hasMaximumAltitudeAtOrBelow
     * @param altitude {number} in feet
     * @return {boolean}
     */

  }, {
    key: "hasMaximumAltitudeAtOrBelow",
    value: function hasMaximumAltitudeAtOrBelow(altitude) {
      return this.altitudeMaximum !== _globalConstants.INVALID_NUMBER && this.altitudeMaximum <= altitude;
    }
    /**
     * Check for a minimum altitude restriction at or above the given altitude
     *
     * @for WaypointModel
     * @method hasMinimumAltitudeAtOrAbove
     * @param altitude {number} in feet
     * @return {boolean}
     */

  }, {
    key: "hasMinimumAltitudeAtOrAbove",
    value: function hasMinimumAltitudeAtOrAbove(altitude) {
      return this.altitudeMinimum !== _globalConstants.INVALID_NUMBER && this.altitudeMinimum >= altitude;
    }
    /**
     * Check for a maximum speed restriction at or below the given speed
     *
     * @for WaypointModel
     * @method hasMaximumSpeedAtOrBelow
     * @param speed {number} in knots
     * @return {boolean}
     */

  }, {
    key: "hasMaximumSpeedAtOrBelow",
    value: function hasMaximumSpeedAtOrBelow(speed) {
      var speedMax = this.speedMaximum;
      return speedMax !== _globalConstants.INVALID_NUMBER && speedMax <= speed;
    }
    /**
     * Check for a minimum speed restriction at or above the given speed
     *
     * @for WaypointModel
     * @method hasMinimumSpeedAtOrAbove
     * @param speed {number} in knots
     * @return {boolean}
     */

  }, {
    key: "hasMinimumSpeedAtOrAbove",
    value: function hasMinimumSpeedAtOrAbove(speed) {
      return this.speedMinimum !== _globalConstants.INVALID_NUMBER && this.speedMinimum >= speed;
    }
    /**
     * Reset the value of #_holdParameters.timer to the default
     *
     * @for WaypointModel
     * @method resetHoldTimer
     */

  }, {
    key: "resetHoldTimer",
    value: function resetHoldTimer() {
      this._holdParameters.timer = _waypointConstants.DEFAULT_HOLD_PARAMETERS.timer;
    }
    /**
     * Set the #speedMinimum and #speedMaximum to the specified speed
     *
     * @for WaypointModel
     * @method setSpeed
     * @param speec {number} in knots
     */

  }, {
    key: "setSpeed",
    value: function setSpeed(speed) {
      this.setSpeedMinimum(speed);
      this.setSpeedMaximum(speed);
    }
    /**
     * Set the #_speedMaximum to the specified speed
     *
     * @for WaypointModel
     * @method setSpeedMaximum
     * @param speedMaximum {number} in knots
     */

  }, {
    key: "setSpeedMaximum",
    value: function setSpeedMaximum(speedMaximum) {
      if (!(0, _isNumber2["default"])(speedMaximum)) {
        console.warn("Expected number to set as max speed of waypoint '".concat(this.name, "', ") + "but received '".concat(speedMaximum, "'"));
        return;
      }

      this._speedMaximum = speedMaximum;
    }
    /**
     * Set the #_speedMinimum to the specified speed
     *
     * @for WaypointModel
     * @method setSpeedMinimum
     * @param speedMinimum {number} in knots
     */

  }, {
    key: "setSpeedMinimum",
    value: function setSpeedMinimum(speedMinimum) {
      if (!(0, _isNumber2["default"])(speedMinimum)) {
        console.warn("Expected number to set as minimum speed of waypoint '".concat(this.name, "', ") + "but received '".concat(speedMinimum, "'"));
        return;
      }

      this._speedMinimum = speedMinimum;
    }
    /**
     * Set the #altitudeMinimum and #altitudeMaximum to the specified altitude
     *
     * @for WaypointModel
     * @method setAltitude
     * @param altitude {number} in feet
     */

  }, {
    key: "setAltitude",
    value: function setAltitude(altitude) {
      this.setAltitudeMaximum(altitude);
      this.setAltitudeMinimum(altitude);
    }
    /**
     * Set the #altitudeMaximum to the specified altitude
     *
     * @for WaypointModel
     * @method setAltitudeMaximum
     * @param altitudeMaximum {number} in feet
     */

  }, {
    key: "setAltitudeMaximum",
    value: function setAltitudeMaximum(altitudeMaximum) {
      if (!(0, _isNumber2["default"])(altitudeMaximum)) {
        console.warn("Expected number to set as max altitude of waypoint '".concat(this._name, "', ") + "but received '".concat(altitudeMaximum, "'"));
        return;
      }

      if (altitudeMaximum < 0 || altitudeMaximum > 60000) {
        console.warn("Expected requested waypoint '".concat(this._name, "' max altitude to be reasonable, ") + "but received altitude of '".concat(altitudeMaximum, "'"));
        return;
      }

      this.altitudeMaximum = altitudeMaximum;
    }
    /**
     * Set the #altitudeMinimum to the specified altitude
     *
     * @for WaypointModel
     * @method setAltitudeMinimum
     * @param altitudeMinimum {number} in feet
     */

  }, {
    key: "setAltitudeMinimum",
    value: function setAltitudeMinimum(altitudeMinimum) {
      if (!(0, _isNumber2["default"])(altitudeMinimum)) {
        console.warn("Expected number to set as max altitude of waypoint '".concat(this._name, "', ") + "but received '".concat(altitudeMinimum, "'"));
        return;
      }

      if (altitudeMinimum < 0 || altitudeMinimum > 60000) {
        console.warn("Expected requested waypoint '".concat(this._name, "' max altitude to be reasonable, ") + "but received altitude altitude of '".concat(altitudeMinimum, "'"));
        return;
      }

      this.altitudeMinimum = altitudeMinimum;
    }
    /**
     * Set default parameters for the planned holding pattern at this waypoint, and will
     * set both `#_defaultHoldParameters` and `#_holdParameters` properties
     *
     * This should only be called immedately after creating a new `WaypointModel`
     *
     * @for WaypointModel
     * @method setDefaultHoldParameters
     * @param holdParameters {object}
     */

  }, {
    key: "setDefaultHoldParameters",
    value: function setDefaultHoldParameters(holdParameters) {
      // The rationale behind having both _defaultHoldParameters and _holdParameters is:
      // * Without this, once a hold command is executed with specific options (eg. HOLD BPK left 225),
      //   it could overwrite the parameters for a procedural hold
      // * This would mean that if the hold was cancelled and re-requested without any specific options (eg. HOLD BPK)
      //   it would still use "left 225", and not the expected defaults from the pocedure
      // These can't be the same reference, as we don't want any changes to made _holdParameters
      // (eg. timer) to be passed onto _defaultHoldParameters
      this._defaultHoldParameters = Object.assign({}, _waypointConstants.DEFAULT_HOLD_PARAMETERS, holdParameters);
      this._holdParameters = Object.assign({}, _waypointConstants.DEFAULT_HOLD_PARAMETERS, holdParameters);
    }
    /**
     * Set parameters for the planned holding pattern at this waypoint. This does NOT
     * inherently make this a hold waypoint, but simply describes the holding pattern
     * aircraft should follow IF they are told to hold at this waypoint
     *
     * @for WaypointModel
     * @method setHoldParameters
     * @param holdParameters {object}
     * @param fallbackInboundHeading {number} an optional inboundHeading that is used if no default is available
     * @returns {object} The hold parameters set for the `WaypointModel`
     */

  }, {
    key: "setHoldParameters",
    value: function setHoldParameters(holdParameters, fallbackInboundHeading) {
      var params = Object.assign({}, this._defaultHoldParameters, holdParameters);

      if (params.inboundHeading == null) {
        params.inboundHeading = fallbackInboundHeading;
      }

      this._holdParameters = params;
      return params;
    }
    /**
     * Stores provided parameters for holding pattern, and marks this as a hold waypoint
     *
     * @for WaypointModel
     * @method setHoldParametersAndActivateHold
     * @param inboundHeading {number} in radians
     * @param turnDirection {string} either left or right
     * @param legLength {string} length of the hold leg in minutes or nm
     * @param fallbackInboundHeading {number} an optional inboundHeading that is used if no default is available
     * @returns {object} The hold parameters set
     */

  }, {
    key: "setHoldParametersAndActivateHold",
    value: function setHoldParametersAndActivateHold(holdParameters) {
      var fallbackInboundHeading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var params = this.setHoldParameters(holdParameters, fallbackInboundHeading);
      this.activateHold();
      return params;
    }
    /**
     * Set the value of #_holdParameters.timer
     *
     * @for WaypointModel
     * @method setHoldTimer
     * @param expirationTime {number} game time (seconds) when the timer should "expire"
     */

  }, {
    key: "setHoldTimer",
    value: function setHoldTimer(expirationTime) {
      if (typeof expirationTime !== 'number') {
        throw new TypeError('Expected hold timer expiration time to be a ' + "number, but received type ".concat(_typeof(expirationTime)));
      }

      this._holdParameters.timer = expirationTime;
    } // ------------------------------ PRIVATE ------------------------------

    /**
     * Apply an altitude restriction in the appropriate properties
     *
     * @for WaypointModel
     * @method _applyAltitudeRestriction
     * @param restriction {string}
     */

  }, {
    key: "_applyAltitudeRestriction",
    value: function _applyAltitudeRestriction(restriction) {
      var _parseAltitudeRestric = (0, _navigationUtilities.parseAltitudeRestriction)(restriction),
          _parseAltitudeRestric2 = _slicedToArray(_parseAltitudeRestric, 2),
          altitude = _parseAltitudeRestric2[0],
          limit = _parseAltitudeRestric2[1];

      if (altitude == null) {
        throw new Error("Expected valid altitude restriction, but received ".concat(restriction));
      }

      if (limit === '+') {
        this.altitudeMinimum = altitude;
        return;
      }

      if (limit === '-') {
        this.altitudeMaximum = altitude;
        return;
      }

      this.altitudeMaximum = altitude;
      this.altitudeMinimum = altitude;
    }
    /**
     * Parse the restrictions, and store the inferred meaning in the appropriate properties
     *
     * @for WaypointModel
     * @method _applyRestrictions
     * @param restrictions {string} restrictions, separated by pipe symbol: '|'
     */

  }, {
    key: "_applyRestrictions",
    value: function _applyRestrictions(restrictions) {
      if ((0, _isEmpty2["default"])(restrictions)) {
        return;
      }

      var restrictionCollection = restrictions.split('|');

      for (var i = 0; i < restrictionCollection.length; i++) {
        var restriction = restrictionCollection[i]; // looking at the first letter of a restriction

        if (restriction[0] === 'A') {
          this._applyAltitudeRestriction(restriction);
        } else if (restriction[0] === 'S') {
          this._applySpeedRestriction(restriction);
        } else {
          throw new TypeError('Expected "A" or "S" prefix on restriction, ' + "but received prefix '".concat(restriction[0], "'"));
        }
      }
    }
    /**
     * Apply a speed restriction in the appropriate properties
     *
     * @for WaypointModel
     * @method _applySpeedRestriction
     * @param restriction {string}
     */

  }, {
    key: "_applySpeedRestriction",
    value: function _applySpeedRestriction(restriction) {
      var _parseSpeedRestrictio = (0, _navigationUtilities.parseSpeedRestriction)(restriction),
          _parseSpeedRestrictio2 = _slicedToArray(_parseSpeedRestrictio, 2),
          speed = _parseSpeedRestrictio2[0],
          limit = _parseSpeedRestrictio2[1];

      if (speed == null) {
        throw new Error("Expected valid speed restriction, but received ".concat(restriction));
      }

      if (limit === '+') {
        this._speedMinimum = speed;
        return;
      }

      if (limit === '-') {
        this._speedMaximum = speed;
        return;
      }

      this._speedMaximum = speed;
      this._speedMinimum = speed;
    }
    /**
     * Verify that this waypoint and the specified waypoint are both valid, non-vector waypoints
     *
     * If either are not, then throw some errors about it.
     *
     * This method is used to protect certain methods that would have undesirable
     * behaviors with vector waypoints (such as those measuring angles or distances
     * between waypoint models, etc). In those cases, we should be cognizant to
     * exclude vector (or other undesirable) waypoints from those operations, rather
     * than attempting to execute a calculation that cannot yield a logical result.
     *
     * @for WaypointModel
     * @method _ensureNonVectorWaypointsForThisAndWaypoint
     * @param waypointModel {WaypointModel}
     * @private
     */

  }, {
    key: "_ensureNonVectorWaypointsForThisAndWaypoint",
    value: function _ensureNonVectorWaypointsForThisAndWaypoint(waypointModel) {
      if (!(waypointModel instanceof WaypointModel)) {
        throw new TypeError("Expected a WaypointModel instance, but received type '".concat(waypointModel, "'"));
      }

      if (this._isVectorWaypoint || waypointModel.isVectorWaypoint) {
        throw new TypeError('Expected .calculateBearingToWaypoint() to never be called with vector waypoints!');
      }
    }
    /**
     * Initialize the waypoint's position model based on #_name
     *
     * @for WaypointModel
     * @method _initializePosition
     */

  }, {
    key: "_initializePosition",
    value: function _initializePosition() {
      if (this._isVectorWaypoint) {
        return;
      }

      var fixPosition = _FixCollection["default"].getPositionModelForFixName(this._name);

      if (!fixPosition) {
        throw new TypeError("Expected fix with known position, but cannot find fix '".concat(this._name, "'"));
      }

      this._positionModel = fixPosition;
    }
  }, {
    key: "hasAltiudeMaximumRestriction",
    get: function get() {
      return this.altitudeMaximum !== _globalConstants.INVALID_NUMBER;
    }
    /**
     * Returns whether this waypoint has a value for #altitudeMinimum
     *
     * @for WaypointModel
     * @property hasAltiudeMinimumRestriction
     * @type {boolean}
     */

  }, {
    key: "hasAltiudeMinimumRestriction",
    get: function get() {
      return this.altitudeMinimum !== _globalConstants.INVALID_NUMBER;
    }
    /**
     * Returns whether this waypoint has an altitude restriction of any kind
     *
     * @for WaypointModel
     * @property hasAltitudeRestriction
     * @type {boolean}
     */

  }, {
    key: "hasAltitudeRestriction",
    get: function get() {
      return this.hasAltiudeMaximumRestriction || this.hasAltiudeMinimumRestriction;
    }
    /**
     * Returns whether this waypoint has a restriction of any kind
     *
     * @for WaypointModel
     * @property hasRestriction
     * @type {boolean}
     */

  }, {
    key: "hasRestriction",
    get: function get() {
      return this.hasAltitudeRestriction || this.hasSpeedRestriction;
    }
    /**
     * Returns whether this waypoint has a value for #speedMaximum
     *
     * @for WaypointModel
     * @property hasSpeedMaximumRestriction
     * @type {boolean}
     */

  }, {
    key: "hasSpeedMaximumRestriction",
    get: function get() {
      return this.speedMaximum !== _globalConstants.INVALID_NUMBER;
    }
    /**
     * Returns whether this waypoint has a value for #speedMinimum
     *
     * @for WaypointModel
     * @property hasSpeedMinimumRestriction
     * @type {boolean}
     */

  }, {
    key: "hasSpeedMinimumRestriction",
    get: function get() {
      return this.speedMinimum !== _globalConstants.INVALID_NUMBER;
    }
    /**
     * Returns whether this waypoint has a speed restriction of any kind
     *
     * @for WaypointModel
     * @property hasSpeedRestriction
     * @type {boolean}
     */

  }, {
    key: "hasSpeedRestriction",
    get: function get() {
      return this.hasSpeedMaximumRestriction || this.hasSpeedMinimumRestriction;
    }
    /**
     * Provides properties needed for an aircraft to execute a
     * holding pattern.
     *
     * This is used to match an existing API
     *
     * @for WaypointModel
     * @property hold
     * @return {object}
     */

  }, {
    key: "holdParameters",
    get: function get() {
      if (!this._isHoldWaypoint) {
        return;
      }

      return this._holdParameters;
    }
    /**
     * Returns whether this waypoint is a fly-over waypoint
     *
     * Fly-over waypoints are waypoints that aircraft may not begin the turn to their
     * next fix until they fully pass this waypoint
     *
     * @for WaypointModel
     * @property isFlyOverWaypoint
     * @return {boolean}
     */

  }, {
    key: "isFlyOverWaypoint",
    get: function get() {
      return this._isFlyOverWaypoint;
    }
    /**
    * Returns whether this waypoint includes an activated holding pattern
    *
    * @for WaypointModel
    * @property isHoldWaypoint
    * @type {boolean}
    */

  }, {
    key: "isHoldWaypoint",
    get: function get() {
      return this._isHoldWaypoint;
    }
    /**
    * Returns whether this waypoint is a vector waypoint
    *
    * Vector waypoints are simply an instruction to fly a particular heading
    *
    * @for WaypointModel
    * @property isVector
    * @return {boolean}
    */

  }, {
    key: "isVectorWaypoint",
    get: function get() {
      return this._isVectorWaypoint;
    }
    /**
     * Returns the value of #_name
     *
     * @for WaypointModel
     * @property name
     * @type {string}
     */

  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
    /**
     * Provide read-only public access to this._positionModel
     *
     * @for SpawnPatternModel
     * @property positionModel
     * @type {StaticPositionModel}
     */

  }, {
    key: "positionModel",
    get: function get() {
      return this._positionModel;
    }
    /**
     * Facade to access relative position
     *
     * @for WaypointModel
     * @property relativePosition
     * @return {array<number>} [kilometersNorth, kilometersEast]
     */

  }, {
    key: "relativePosition",
    get: function get() {
      if (this.isVectorWaypoint) {
        return;
      }

      return this._positionModel.relativePosition;
    }
    /**
     * The maxmimum speed allowed for the Waypoint, or hold if `#isHoldwaypoint`
     *
     * @returns {number}
     */

  }, {
    key: "speedMaximum",
    get: function get() {
      if (this.isHoldWaypoint && this._holdParameters.speedMaximum !== undefined) {
        return this._holdParameters.speedMaximum;
      }

      return this._speedMaximum;
    }
    /**
     * The minimum speed allowed for the Waypoint
     *
     * @returns {number}
     */

  }, {
    key: "speedMinimum",
    get: function get() {
      return this._speedMinimum;
    }
  }]);

  return WaypointModel;
}();

exports["default"] = WaypointModel;

},{"../../constants/globalConstants":310,"../../constants/waypointConstants":335,"../../navigationLibrary/FixCollection":357,"../../utilities/navigationUtilities":388,"../../utilities/unitConverters":391,"lodash/isArray":209,"lodash/isEmpty":213,"lodash/isNumber":220}],272:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _modeControlConstants = require("./modeControlConstants");

var _globalConstants = require("../../constants/globalConstants");

var _unitConverters = require("../../utilities/unitConverters");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Part of the autopilot system that determines the source from which to derive the aircraft's targeted telemetry
 *
 * @class ModeController
 */
var ModeController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @for ModeController
   */
  function ModeController() {
    _classCallCheck(this, ModeController);

    /**
     * Flag used to determine if the controller is enabled
     *
     * @property isEnabled
     * @type {boolean}
     * @default flase
     * @private
     */
    this.isEnabled = false; // Mode Selectors

    /**
     * The current altitudeMode
     *
     * This mode informs what value to use for `aircraft.target.altitude`
     *
     * @property
     * @type
     * @default
     */

    this.altitudeMode = _modeControlConstants.MCP_MODE.ALTITUDE.OFF;
    /**
     *
     *
     * @property autopilotMode
     * @type
     * @default MCP_MODE.AUTOPILOT.OFF
     */

    this.autopilotMode = _modeControlConstants.MCP_MODE.AUTOPILOT.OFF;
    /**
     * The current headingeMode
     *
     * This mode informs what value to use for `aircraft.targetHeading`
     *
     *
     * @property headingMode
     * @type
     * @default MCP_MODE.HEADING.OFF
     */

    this.headingMode = _modeControlConstants.MCP_MODE.HEADING.OFF;
    /**
     * The current speedMode
     *
     * This mode informs what value to use for `aircraft.target.speed`
     *
     * @property speedMode
     * @type
     * @default MCP_MODE.SPEED.OFF
     */

    this.speedMode = _modeControlConstants.MCP_MODE.SPEED.OFF; // Fields

    /**
     * Altitude value
     *
     * Used when `altitudeMode` is 'HOLD'
     *
     * @property altitude
     * @type {number}
     * @default INVALID_NUMBER
     */

    this.altitude = _globalConstants.INVALID_NUMBER;
    /**
     *
     *
     * @property course
     * @type {number}
     * @default INVALID_NUMBER
     */

    this.course = _globalConstants.INVALID_NUMBER;
    /**
     * Heading value in radians
     *
     * Used when `headingMode` is `HOLD`
     *
     * Use `#headingInDegrees` when this value needs to
     * be shown to the user, like in the `AircraftStripView`
     *
     * @property heading
     * @type {number}
     * @default INVALID_NUMBER
     */

    this.heading = _globalConstants.INVALID_NUMBER;
    /**
     * Speed value in knots
     *
     * Used when `speedMode` is `HOLD`
     *
     * @property speed
     * @type {number}
     * @default INVALID_NUMBER
     */

    this.speed = _globalConstants.INVALID_NUMBER; // Other

    /**
     *
     *
     * @property shouldExpediteAltitudeChange
     * @type {boolean}
     * @default false
     */

    this.shouldExpediteAltitudeChange = false;
    /**
     *
     *
     * @property nav1Datum
     * @type
     * @default null
     */

    this.nav1Datum = null;
    /**
     *
     *
     * @property descentAngle
     * @type {number}
     * @default 0
     */

    this.descentAngle = 0;
    this.init();
  }
  /**
   * Current heading value expressed in degrees (0 - 359)
   *
   * @property headingInDegrees
   * @return {number}
   */


  _createClass(ModeController, [{
    key: "init",

    /**
     * Initialize the instance
     *
     * @for ModeController
     * @method init
     */
    value: function init() {
      return this;
    }
    /**
     * Sets `#isEnabled` flag to `true`
     *
     * @for ModeController
     * @method enable
     */

  }, {
    key: "enable",
    value: function enable() {
      if (this.isEnabled) {
        return;
      }

      this.isEnabled = true;

      this._setModeSelectorMode(_modeControlConstants.MCP_MODE_NAME.AUTOPILOT, _modeControlConstants.MCP_MODE.AUTOPILOT.ON);
    }
    /**
     * Sets `#isEnabled` flag to `false`
     *
     * @for ModeController
     * @method disable
     */

  }, {
    key: "disable",
    value: function disable() {
      if (!this.isEnabled) {
        return;
      }

      this.isEnabled = false;

      this._setModeSelectorMode(_modeControlConstants.MCP_MODE_NAME.AUTOPILOT, _modeControlConstants.MCP_MODE.AUTOPILOT.OFF);
    }
    /**
     *
     *
     * @for ModeController
     * @method setNav1Datum
     * @param nav1Datum {number}
     */

  }, {
    key: "setNav1Datum",
    value: function setNav1Datum(datum) {
      this.nav1Datum = datum;
    } // TODO: the descentAngle is a part of the ILS system itself, and should not be owned by the MCP

    /**
     *
     *
     * @for ModeController
     * @method setDescentAngle
     * @param descentAngle {number}
     */

  }, {
    key: "setDescentAngle",
    value: function setDescentAngle(descentAngle) {
      this.descentAngle = descentAngle;
    }
    /**
     * Set the MCP altitude mode to `APCH`
     *
     * @for ModeController
     * @method setAltitudeApproach
     */

  }, {
    key: "setAltitudeApproach",
    value: function setAltitudeApproach() {
      this._setModeSelectorMode(_modeControlConstants.MCP_MODE_NAME.ALTITUDE, _modeControlConstants.MCP_MODE.ALTITUDE.APPROACH);
    }
    /**
     * Set the value of the MCP's altitude field to a given value
     *
     * @for ModeController
     * @method setAltitudeFieldValue
     * @param altitude {Number} value to set in the altitude field
     */

  }, {
    key: "setAltitudeFieldValue",
    value: function setAltitudeFieldValue(altitude) {
      this._setFieldValue(_modeControlConstants.MCP_FIELD_NAME.ALTITUDE, altitude);
    }
    /**
     * Set the MCP altitude mode to `HOLD`
     *
     * @for ModeController
     * @method setAltitudeHold
     */

  }, {
    key: "setAltitudeHold",
    value: function setAltitudeHold() {
      this._setModeSelectorMode(_modeControlConstants.MCP_MODE_NAME.ALTITUDE, _modeControlConstants.MCP_MODE.ALTITUDE.HOLD);
    }
    /**
     * Set the MCP altitude mode to `VNAV`
     *
     * @for ModeController
     * @method setAltitudeVnav
     */

  }, {
    key: "setAltitudeVnav",
    value: function setAltitudeVnav() {
      this._setModeSelectorMode(_modeControlConstants.MCP_MODE_NAME.ALTITUDE, _modeControlConstants.MCP_MODE.ALTITUDE.VNAV);
    }
    /**
     * Set the value of the MCP's course field to a given value
     *
     * @for ModeController
     * @method setCourseFieldValue
     * @param course {number}  magnetic course (in radians)
     */

  }, {
    key: "setCourseFieldValue",
    value: function setCourseFieldValue(course) {
      this._setFieldValue(_modeControlConstants.MCP_FIELD_NAME.COURSE, course);
    }
    /**
     * Set the value of the MCP's heading field to a given value
     *
     * @for ModeController
     * @method setHeadingFieldValue
     * @param heading {number}  magnetic heading (in radians)
     */

  }, {
    key: "setHeadingFieldValue",
    value: function setHeadingFieldValue(heading) {
      this._setFieldValue(_modeControlConstants.MCP_FIELD_NAME.HEADING, heading);
    }
    /**
     * Set the MCP heading mode to `HOLD`
     *
     * @for ModeController
     * @method setHeadingHold
     */

  }, {
    key: "setHeadingHold",
    value: function setHeadingHold() {
      this._setModeSelectorMode(_modeControlConstants.MCP_MODE_NAME.HEADING, _modeControlConstants.MCP_MODE.HEADING.HOLD);
    }
    /**
     * Set the MCP heading mode to `LNAV`
     *
     * @for ModeController
     * @method setHeadingLnav
     */

  }, {
    key: "setHeadingLnav",
    value: function setHeadingLnav() {
      this._setModeSelectorMode(_modeControlConstants.MCP_MODE_NAME.HEADING, _modeControlConstants.MCP_MODE.HEADING.LNAV);
    }
    /**
     * Set the MCP heading mode to `VOR_LOC`
     *
     * @for ModeController
     * @method setHeadingVorLoc
     */

  }, {
    key: "setHeadingVorLoc",
    value: function setHeadingVorLoc() {
      this._setModeSelectorMode(_modeControlConstants.MCP_MODE_NAME.HEADING, _modeControlConstants.MCP_MODE.HEADING.VOR_LOC);
    }
    /**
     * Set the value of the MCP's speed field to a given value
     *
     * @for ModeController
     * @method setSpeedFieldValue
     * @param speed {Number}  speed to set value to
     */

  }, {
    key: "setSpeedFieldValue",
    value: function setSpeedFieldValue(speed) {
      this._setFieldValue(_modeControlConstants.MCP_FIELD_NAME.SPEED, speed);
    }
    /**
     * Set the MCP speed mode to `HOLD`
     *
     * @for ModeController
     * @method setSpeedHold
     */

  }, {
    key: "setSpeedHold",
    value: function setSpeedHold() {
      this._setModeSelectorMode(_modeControlConstants.MCP_MODE_NAME.SPEED, _modeControlConstants.MCP_MODE.SPEED.HOLD);
    }
    /**
     * Set the MCP speed mode to `N1`
     *
     * @for ModeController
     * @method setSpeedN1
     */

  }, {
    key: "setSpeedN1",
    value: function setSpeedN1() {
      this._setModeSelectorMode(_modeControlConstants.MCP_MODE_NAME.SPEED, _modeControlConstants.MCP_MODE.SPEED.N1);
    }
    /**
     * Set the MCP speed mode to `VNAV`
     *
     * @for ModeController
     * @method setSpeedVnav
     */

  }, {
    key: "setSpeedVnav",
    value: function setSpeedVnav() {
      this._setModeSelectorMode(_modeControlConstants.MCP_MODE_NAME.SPEED, _modeControlConstants.MCP_MODE.SPEED.VNAV);
    }
    /**
     * Set the appropriate values in the MCP when spawning an aircraft already in flight
     *
     * @for ModeController
     * @method initializeForAirborneFlight
     * @param {number} bottomAltitude - the lowest altitude restriction in the FMS
     * @param {number} airspaceCeiling - maximum altitude belonging to the controller
     * @param {number} currentAltitude - aircraft's current altitude, in feet ASL
     * @param {number} currentHeading - aircraft's current heading, in radians
     * @param {number} currentSpeed - aircraft's current speed, in knots
     */

  }, {
    key: "initializeForAirborneFlight",
    value: function initializeForAirborneFlight(bottomAltitude, airspaceCeiling, currentAltitude, currentHeading, currentSpeed) {
      // ensure aircraft will always descend at least to reach our airspace ceiling
      var descentAltitude = Math.min(bottomAltitude, airspaceCeiling, currentAltitude);
      this.setAltitudeFieldValue(descentAltitude);
      this.setAltitudeVnav(); // if unable to descend via STAR, force a descent to the top of our airspace

      if (bottomAltitude === -1) {
        this.setAltitudeFieldValue(Math.min(airspaceCeiling, currentAltitude));
        this.setAltitudeHold();
      }

      this.setHeadingFieldValue(currentHeading);
      this.setHeadingLnav();
      this.setSpeedFieldValue(currentSpeed);
      this.setSpeedVnav();
      this.enable();
    }
    /**
    * Set the value of a given fieldName
    *
    * @for ModeController
    * @method _setFieldValue
    * @param fieldName {MCP_FIELD_NAME}
    * @param value {number}
    */

  }, {
    key: "_setFieldValue",
    value: function _setFieldValue(fieldName, value) {
      this[fieldName] = value;
    }
    /**
     * Set the mode of a given modeSelector
     *
     * @for ModeController
     * @method _setModeSelectorMode
     * @param modeSelector {MCP_MODE_NAME}
     * @param mode {MCP_MODE}
     */

  }, {
    key: "_setModeSelectorMode",
    value: function _setModeSelectorMode(modeSelector, mode) {
      this[modeSelector] = mode;
    }
  }, {
    key: "headingInDegrees",
    get: function get() {
      return Math.floor((0, _unitConverters.radiansToDegrees)(this.heading));
    }
  }]);

  return ModeController;
}();

exports["default"] = ModeController;

},{"../../constants/globalConstants":310,"../../utilities/unitConverters":391,"./modeControlConstants":273}],273:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MCP_FIELD_NAME = exports.MCP_MODE_NAME = exports.MCP_MODE = exports.MCP_SPEED_MODE = exports.MCP_HEADING_MODE = exports.MCP_AUTOPILOT_MODE = exports.MCP_ALTITUDE_MODE = void 0;

/**
 * Available values for `ModeController#altitudeMode`
 *
 * @memberof MCP_MODE
 * @property MCP_ALTITUDE_MODE
 * @type {Object}
 * @final
 */
var MCP_ALTITUDE_MODE = {
  HOLD: 'HOLD',
  APPROACH: 'APPROACH',
  LEVEL_CHANGE: 'LEVEL_CHANGE',
  OFF: 'OFF',
  VERTICAL_SPEED: 'VERTICAL_SPEED',
  VNAV: 'VNAV'
};
/**
 * Available values for `ModeController#autopilotMode`
 *
 * @memberof MCP_MODE
 * @property MCP_AUTOPILOT_MODE
 * @type {Object}
 * @final
 */

exports.MCP_ALTITUDE_MODE = MCP_ALTITUDE_MODE;
var MCP_AUTOPILOT_MODE = {
  ON: 'ON',
  OFF: 'OFF'
};
/**
 * Available values for `ModeController#headingMode`
 *
 * @memberof MCP_MODE
 * @property MCP_HEADING_MODE
 * @type {Object}
 * @final
 */

exports.MCP_AUTOPILOT_MODE = MCP_AUTOPILOT_MODE;
var MCP_HEADING_MODE = {
  HOLD: 'HOLD',
  LNAV: 'LNAV',
  OFF: 'OFF',
  VOR_LOC: 'VOR_LOC'
};
/**
 * Available values for `ModeController#speedMode`
 *
 * @memberof MCP_MODE
 * @property MCP_SPEED_MODE
 * @type {Object}
 * @final
 */

exports.MCP_HEADING_MODE = MCP_HEADING_MODE;
var MCP_SPEED_MODE = {
  LEVEL_CHANGE: 'LEVEL_CHANGE',
  N1: 'N1',
  OFF: 'OFF',
  HOLD: 'HOLD',
  VNAV: 'VNAV'
};
/**
 * Available modes for `ModeController`
 *
 * @property MCP_MODE
 * @type {Object}
 * @final
 */

exports.MCP_SPEED_MODE = MCP_SPEED_MODE;
var MCP_MODE = {
  ALTITUDE: MCP_ALTITUDE_MODE,
  AUTOPILOT: MCP_AUTOPILOT_MODE,
  HEADING: MCP_HEADING_MODE,
  SPEED: MCP_SPEED_MODE
};
/**
 *
 *
 * @property MCP_MODE_NAME
 * @type {Object}
 * @final
 */

exports.MCP_MODE = MCP_MODE;
var MCP_MODE_NAME = {
  ALTITUDE: 'altitudeMode',
  AUTOPILOT: 'autopilotMode',
  HEADING: 'headingMode',
  SPEED: 'speedMode'
};
/**
 * Representation of the numerical values of the various dials on the MCP
 *
 * @property MCP_FIELDS
 * @type {Object}
 * @final
 */

exports.MCP_MODE_NAME = MCP_MODE_NAME;
var MCP_FIELD_NAME = {
  ALTITUDE: 'altitude',
  COURSE: 'course',
  HEADING: 'heading',
  SPEED: 'speed'
};
exports.MCP_FIELD_NAME = MCP_FIELD_NAME;

},{}],274:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _ceil2 = _interopRequireDefault(require("lodash/ceil"));

var _find2 = _interopRequireDefault(require("lodash/find"));

var _floor2 = _interopRequireDefault(require("lodash/floor"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _AirportController = _interopRequireDefault(require("../../airport/AirportController"));

var _Fms = _interopRequireDefault(require("../FlightManagementSystem/Fms"));

var _ModeController = _interopRequireDefault(require("../ModeControl/ModeController"));

var _NavigationLibrary = _interopRequireDefault(require("../../navigationLibrary/NavigationLibrary"));

var _modeControlConstants = require("../ModeControl/modeControlConstants");

var _aircraftConstants = require("../../constants/aircraftConstants");

var _globalConstants = require("../../constants/globalConstants");

var _circle = require("../../math/circle");

var _radioUtilities = require("../../utilities/radioUtilities");

var _unitConverters = require("../../utilities/unitConverters");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Executes control actions upon the aircraft by manipulating the MCP and FMS, and provides
 * readbacks to air traffic control instructions.
 *
 * @class Pilot
 */
var Pilot =
/*#__PURE__*/
function () {
  /**
   * @for Pilot
   * @constructor
   * @param modeController {ModeController}
   * @param fms {Fms}
   */
  function Pilot(fms, modeController) {
    _classCallCheck(this, Pilot);

    if (!(fms instanceof _Fms["default"])) {
      throw new TypeError("Expected fms to an instance of Fms but received ".concat(_typeof(fms)));
    }

    if (!(modeController instanceof _ModeController["default"])) {
      throw new TypeError('Expected modeController to an instance of ' + "ModeController, but received ".concat(_typeof(modeController)));
    }
    /**
     * @for Pilot
     * @property _fms
     * @type {Fms}
     * @private
     */


    this._fms = null;
    /**
     * @for Pilot
     * @property _mcp
     * @type {ModeController}
     * @private
     */

    this._mcp = null;
    /**
     * Whether the aircraft has received a clearance to conduct an approach to a runway
     *
     * @for Pilot
     * @property hasApproachClearance
     * @type {boolean}
     * @default false
     */

    this.hasApproachClearance = false;
    /**
     * Whether the aircraft has received an IFR clearance to their destination
     *
     * @for Pilot
     * @property hasDepartureClearance
     * @type {boolean}
     * @default false
     */

    this.hasDepartureClearance = false;
    return this.init(fms, modeController);
  }
  /**
   * @for Pilot
   * @method init
   * @chainable
   */


  _createClass(Pilot, [{
    key: "init",
    value: function init(fms, modeController) {
      this._fms = fms;
      this._mcp = modeController;
      this.hasApproachClearance = false;
      this.hasDepartureClearance = false;
      return this;
    }
    /**
     * @for Pilot
     * @method reset
     * @chainable
     */

  }, {
    key: "reset",
    value: function reset() {
      this._fms = null;
      this._mcp = null;
      this.hasApproachClearance = false;
      this.hasDepartureClearance = false;
      return this;
    }
    /**
     * Maintain a given altitude
     *
     * @for Pilot
     * @method maintainAltitude
     * @param altitude {number}   the altitude to maintain, in feet
     * @param expedite {boolean}  whether to use maximum possible climb/descent rate
     * @param shouldUseSoftCeiling {boolean}
     * @param airportModel {AirportModel}
     * @param aircraftModel {AircraftModel}
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "maintainAltitude",
    value: function maintainAltitude(altitude, expedite, shouldUseSoftCeiling, airportModel, aircraftModel) {
      var response = aircraftModel.validateNextAltitude(altitude, airportModel);

      if (!response[0]) {
        return response;
      }

      var currentAltitude = aircraftModel.altitude;
      var clampedAltitude = airportModel.clampWithinAssignableAltitudes(altitude);

      if (shouldUseSoftCeiling && clampedAltitude === airportModel.maxAssignableAltitude) {
        // causes aircraft to 'leave' airspace, and continue climb through ceiling
        clampedAltitude += 1;
      }

      this.cancelApproachClearance(aircraftModel);

      this._mcp.setAltitudeFieldValue(clampedAltitude);

      this._mcp.setAltitudeHold();

      this._mcp.shouldExpediteAltitudeChange = false; // Build readback

      var readbackAltitude = (0, _floor2["default"])(clampedAltitude, -2);
      var altitudeInstruction = (0, _radioUtilities.radio_trend)('altitude', currentAltitude, altitude);
      var altitudeVerbal = (0, _radioUtilities.radio_altitude)(readbackAltitude);
      var expediteReadback = '';

      if (expedite) {
        // including space here so when expedite is false there isnt an extra space after altitude
        expediteReadback = ' and expedite';
        this.shouldExpediteAltitudeChange();
      }

      var readback = {};
      readback.log = "".concat(altitudeInstruction, " ").concat(readbackAltitude).concat(expediteReadback);
      readback.say = "".concat(altitudeInstruction, " ").concat(altitudeVerbal).concat(expediteReadback);
      return [true, readback];
    }
    /**
     * Maintain a given heading
     *
     * @for Pilot
     * @method maintainHeading
     * @param aircraftModel {AircraftModel}
     * @param headingInDegrees {number}                 the heading to maintain, in degrees
     * @param direction      {string|null}  (optional)  the direction of turn; either 'left' or 'right'
     * @param incremental    {boolean}      (optional)  whether the value is a numeric heading, or a
     *                                                  number of degrees to turn
     * @return {array}                                  [success of operation, readback]
     */

  }, {
    key: "maintainHeading",
    value: function maintainHeading(aircraftModel, headingInDegrees, direction, incremental) {
      var nextHeadingInRadians = (0, _unitConverters.degreesToRadians)(headingInDegrees);
      var correctedHeading = nextHeadingInRadians;

      if (incremental) {
        // if direction is left
        correctedHeading = (0, _circle.radians_normalize)(aircraftModel.heading - nextHeadingInRadians);

        if (direction === 'right') {
          correctedHeading = (0, _circle.radians_normalize)(aircraftModel.heading + nextHeadingInRadians);
        }
      }

      this.cancelApproachClearance(aircraftModel);
      this.cancelHoldingPattern();

      this._mcp.setHeadingFieldValue(correctedHeading);

      this._mcp.setHeadingHold();

      var headingStr = (0, _unitConverters.heading_to_string)(correctedHeading);
      var readback = {};
      readback.log = "fly heading ".concat(headingStr);
      readback.say = "fly heading ".concat((0, _radioUtilities.radio_heading)(headingStr));

      if (incremental) {
        readback.log = "turn ".concat(headingInDegrees, " degrees ").concat(direction);
        readback.say = "turn ".concat((0, _radioUtilities.groupNumbers)(headingInDegrees), " degrees ").concat(direction);
      } else if (direction) {
        readback.log = "turn ".concat(direction, " heading ").concat(headingStr);
        readback.say = "turn ".concat(direction, " heading ").concat((0, _radioUtilities.radio_heading)(headingStr));
      }

      return [true, readback];
    }
    /**
     * Maintain the aircraft's present magnetic heading
     *
     * @for Pilot
     * @method maintainPresentHeading
     * @param aircraftModel {AircraftModel} the heading the aircraft is facing at the time the command is given
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "maintainPresentHeading",
    value: function maintainPresentHeading(aircraftModel) {
      this.cancelApproachClearance(aircraftModel);

      this._mcp.setHeadingFieldValue(aircraftModel.heading);

      this._mcp.setHeadingHold();

      var readback = {};
      readback.log = 'fly present heading';
      readback.say = 'fly present heading';
      return [true, readback];
    }
    /**
     * Maintain a given speed
     *
     * @for Pilot
     * @method maintainSpeed
     * @param speed {Number} - the speed to maintain, in knots
     * @param aircraftModel {AircraftModel}
     * @return {Array} [success of operation, readback]
     */

  }, {
    key: "maintainSpeed",
    value: function maintainSpeed(speed, aircraftModel) {
      if (!aircraftModel.model.isAbleToMaintainSpeed(speed)) {
        var _readback = {};
        _readback.log = "unable to maintain ".concat(speed, " knots due to performance");
        _readback.say = "unable to maintain ".concat((0, _radioUtilities.radio_spellOut)(speed), " knots due to performance");
        return [false, _readback];
      }

      var currentSpeed = aircraftModel.speed;
      var instruction = (0, _radioUtilities.radio_trend)('speed', currentSpeed, speed);

      this._mcp.setSpeedFieldValue(speed);

      this._mcp.setSpeedHold(); // Build the readback


      var readback = {};
      readback.log = "".concat(instruction, " ").concat(speed);
      readback.say = "".concat(instruction, " ").concat((0, _radioUtilities.radio_spellOut)(speed));
      return [true, readback];
    }
    /**
     * Apply the specified arrival procedure by adding it to the fms route
     * Note: SHOULD NOT change the heading mode
     *
     * @for Pilot
     * @method applyArrivalProcedure
     * @param routeString {string}       route string in the form of `entry.procedure.airport`
     * @param airportName {string}
     * @return {array}                   [success of operation, readback]
     */

  }, {
    key: "applyArrivalProcedure",
    value: function applyArrivalProcedure(routeString, airportName) {
      var _this$_fms$replaceArr = this._fms.replaceArrivalProcedure(routeString),
          _this$_fms$replaceArr2 = _slicedToArray(_this$_fms$replaceArr, 2),
          successful = _this$_fms$replaceArr2[0],
          response = _this$_fms$replaceArr2[1];

      if (!successful) {
        return [false, response];
      }

      this.cancelHoldingPattern(); // Build readback

      var readback = {};
      readback.log = "cleared to ".concat(airportName, " via the ").concat(this._fms._routeModel.getStarIcao().toUpperCase(), " arrival");
      readback.say = "cleared to ".concat(airportName, " via the ").concat(this._fms._routeModel.getStarName().toUpperCase(), " arrival");
      return [true, readback];
    }
    /**
     * Apply the specified departure procedure by adding it to the fms route
     * Note: SHOULD NOT change the heading mode
     *
     * @for Pilot
     * @method applyDepartureProcedure
     * @param routeString {String}          the route
     * @param airportIcao {string}          airport icao identifier
     * @return {array}                      [success of operation, readback]
     */

  }, {
    key: "applyDepartureProcedure",
    value: function applyDepartureProcedure(routeString, airportIcao) {
      var _this$_fms$replaceDep = this._fms.replaceDepartureProcedure(routeString, airportIcao),
          _this$_fms$replaceDep2 = _slicedToArray(_this$_fms$replaceDep, 2),
          successful = _this$_fms$replaceDep2[0],
          response = _this$_fms$replaceDep2[1];

      if (!successful) {
        return [false, response];
      }

      this.hasDepartureClearance = true;

      var sidIcao = this._fms.getSidIcao();

      var sidName = this._fms.getSidName();

      var readback = {};
      readback.log = "cleared to destination via the ".concat(sidIcao.toUpperCase(), " departure, then as filed");
      readback.say = "cleared to destination via the ".concat(sidName.toUpperCase(), " departure, then as filed");
      return [true, readback];
    }
    /**
     * Apply the specified route, and as applicable, merge it with the current route
     *
     * @for Pilot
     * @method applyPartialRouteAmendment
     * @param routeString {tring}  route string in the form of `entry.procedure.airport`
     * @return {array}             [success of operation, readback]
     */

  }, {
    key: "applyPartialRouteAmendment",
    value: function applyPartialRouteAmendment(routeString) {
      var readback = this._fms.applyPartialRouteAmendment(routeString);

      if (readback[0]) {
        this.hasDepartureClearance = true;
        this.cancelHoldingPattern();
      }

      return readback;
    }
    /**
     * Ensure the STAR leg has the specified arrival runway as the exit point and
     * set the specified runway as the new arrival runway.
     *
     * @for Pilot
     * @method updateStarLegForArrivalRunway
     * @param aircraft {AircraftModel}
     * @param nextRunwayModel {RunwayModel}
     * @return {array} [success of operation, response]
     */

  }, {
    key: "updateStarLegForArrivalRunway",
    value: function updateStarLegForArrivalRunway(aircraft, nextRunwayModel) {
      if (aircraft.isOnGround()) {
        return [false, 'unable to accept arrival runway assignment until airborne'];
      }

      return this._fms.updateStarLegForArrivalRunway(nextRunwayModel);
    }
    /**
     * Stop conducting the instrument approach, and maintain:
     * - current or last assigned altitude (whichever is lower)
     * - current heading
     * - last assigned speed
     *
     * @for Pilot
     * @method cancelApproachClearance
     * @param aircraftModel {AircraftModel}
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "cancelApproachClearance",
    value: function cancelApproachClearance(aircraftModel) {
      if (!this.hasApproachClearance) {
        return [false, 'we have no approach clearance to cancel!'];
      }

      var airport = _AirportController["default"].airport_get();

      var currentAltitude = (0, _floor2["default"])(aircraftModel.altitude, -2);
      var descentAltitude = Math.min(currentAltitude, this._mcp.altitude);
      var altitudeToMaintain = Math.max(descentAltitude, airport.minAssignableAltitude);

      this._mcp.setAltitudeFieldValue(altitudeToMaintain);

      this._mcp.setAltitudeHold();

      this._mcp.setHeadingFieldValue(aircraftModel.heading);

      this._mcp.setHeadingHold();

      this._mcp.setSpeedHold();

      this.hasApproachClearance = false;
      var readback = 'cancel approach clearance, fly present heading, ' + 'maintain last assigned altitude and speed';
      return [true, readback];
    }
    /**
     * Cancel departure clearance
     *
     * @for Pilot
     * @method cancelDepartureClearance
     * @param aircraftModel {AircraftModel}
     * @return {array} [success of operation, response]
     */

  }, {
    key: "cancelDepartureClearance",
    value: function cancelDepartureClearance(aircraftModel) {
      if (aircraftModel.isAirborne()) {
        return;
      }

      this.hasDepartureClearance = false;
      return [true, 'roger, understand IFR clearance is cancelled, standing by'];
    }
    /**
    * Arm the exit of the holding pattern
    *
    * @for Pilot
    * @method cancelHoldingPattern
    * @param fixName {string} name of the fix at which the hold should be canceled (optional)
    * @return {array} [success of operation, readback]
    */

  }, {
    key: "cancelHoldingPattern",
    value: function cancelHoldingPattern(fixName) {
      var holdWaypointModel = (0, _find2["default"])(this._fms.waypoints, function (waypointModel) {
        return waypointModel.isHoldWaypoint;
      });

      if (!holdWaypointModel) {
        return [false, 'that must be for somebody else, we weren\'t given any holding instructions'];
      }

      if (fixName) {
        holdWaypointModel = this._fms.findWaypoint(fixName);

        if (!holdWaypointModel || !holdWaypointModel.isHoldWaypoint) {
          return [false, {
            log: "that must be for somebody else, we weren't given holding over ".concat(fixName.toUpperCase()),
            say: "that must be for somebody else, we weren't given holding over ".concat(fixName.toLowerCase())
          }];
        }
      }

      holdWaypointModel.deactivateHold(); // force lower-case in verbal readback to get speech synthesis to pronounce the fix instead of speling it

      return [true, {
        log: "roger, we'll cancel the hold at ".concat(holdWaypointModel.getDisplayName()),
        say: "roger, we'll cancel the hold at ".concat(holdWaypointModel.name.toLowerCase())
      }];
    }
    /**
     * Configure the aircraft to fly in accordance with the requested flightplan
     *
     * @for Pilot
     * @method clearedAsFiled
     * @return {Array}                  [success of operation, readback]
     */

  }, {
    key: "clearedAsFiled",
    value: function clearedAsFiled() {
      this.hasDepartureClearance = true;
      var readback = {};
      readback.log = 'cleared to destination as filed';
      readback.say = 'cleared to destination as filed';
      return [true, readback];
    }
    /**
     * Climb in accordance with the altitude restrictions, and sets
     * altitude at which the climb will end regardless of fix restrictions.
     *
     * https://www.faa.gov/about/office_org/headquarters_offices/avs/offices/afx/afs/afs400/afs470/pbn/
     *      media/Climb_Descend_Via_FAQ.pdf
     * https://www.faa.gov/documentLibrary/media/Notice/N7110.584.pdf
     *
     * @for Pilot
     * @method climbViaSid
     * @param aircraftModel {AircraftModel}
     * @param maximumAltitude {number} (optional) altitude at which the climb will end (regardless of fix restrictions)
     * @return {array}           [success of operation, readback]
     */

  }, {
    key: "climbViaSid",
    value: function climbViaSid(aircraftModel, maximumAltitude) {
      var nextAltitude = maximumAltitude;

      if (typeof nextAltitude === 'undefined') {
        nextAltitude = this._fms.flightPlanAltitude;
      }

      var departureAirportModel = this._fms.departureAirportModel;
      var altitudeCheck = aircraftModel.validateNextAltitude(nextAltitude, departureAirportModel);

      if (!altitudeCheck[0]) {
        return altitudeCheck;
      }

      nextAltitude = departureAirportModel.clampWithinAssignableAltitudes(nextAltitude);

      if (aircraftModel.altitude > nextAltitude) {
        var currentAltitude = (0, _ceil2["default"])(aircraftModel.altitude, -2);
        var _readback2 = {};
        _readback2.log = "unable, we're already at ".concat(currentAltitude);
        _readback2.say = "unable, we're already at ".concat((0, _radioUtilities.radio_altitude)(currentAltitude));
        return [false, _readback2];
      }

      this._mcp.setAltitudeFieldValue(nextAltitude);

      this._mcp.setAltitudeVnav();

      this._mcp.setSpeedVnav();

      var readback = {};
      readback.log = "climb via SID and maintain ".concat(nextAltitude);
      readback.say = "climb via SID and maintain ".concat((0, _radioUtilities.radio_altitude)(nextAltitude));
      return [true, readback];
    }
    /**
     * Descend in accordance with the altitude restrictions
     *
     * https://www.faa.gov/about/office_org/headquarters_offices/avs/offices/afx/afs/afs400/afs470/pbn/
     *      media/Climb_Descend_Via_FAQ.pdf
     * https://www.faa.gov/documentLibrary/media/Notice/N7110.584.pdf
     *
     * @for Pilot
     * @method descendViaStar
     * @param aircraftModel {AircraftModel}
     * @param bottomAltitude {number} (optional) altitude at which the descent will end (regardless of fix restrictions)
     * @return {array}                [success of operation, readback]
     */

  }, {
    key: "descendViaStar",
    value: function descendViaStar(aircraftModel, bottomAltitude) {
      var nextAltitude = bottomAltitude;

      if (typeof nextAltitude === 'undefined') {
        nextAltitude = this._fms.getBottomAltitude();
      }

      var arrivalAirportModel = this._fms.arrivalAirportModel;
      var altitudeCheck = aircraftModel.validateNextAltitude(nextAltitude, arrivalAirportModel);

      if (!altitudeCheck[0]) {
        return altitudeCheck;
      }

      nextAltitude = arrivalAirportModel.clampWithinAssignableAltitudes(nextAltitude);

      if (aircraftModel.altitude < nextAltitude) {
        var currentAltitude = (0, _ceil2["default"])(aircraftModel.altitude, -2);
        var _readback3 = {};
        _readback3.log = "unable, we're already at ".concat(currentAltitude);
        _readback3.say = "unable, we're already at ".concat((0, _radioUtilities.radio_altitude)(currentAltitude));
        return [false, _readback3];
      }

      this._mcp.setAltitudeFieldValue(nextAltitude);

      this._mcp.setAltitudeVnav();

      this._mcp.setSpeedVnav();

      var readback = {};
      readback.log = "descend via STAR and maintain ".concat(nextAltitude);
      readback.say = "descend via STAR and maintain ".concat((0, _radioUtilities.radio_altitude)(nextAltitude));
      return [true, readback];
    }
    /**
     * Cross a fix at a certain altitude and/or speed
     *
     * @for Pilot
     * @method crossFix
     * @param aircraftModel {AircraftModel}
     * @param fixName  {string} name of the fix
     * @param altitude {number} the altitude
     * @param speed {number} the speed
     * @return {array}  success of operation, readback]
     */

  }, {
    key: "crossFix",
    value: function crossFix(aircraftModel, fixName, altitude, speed) {
      if (!altitude && !speed) {
        return [false, 'say again? In crossing restrictions, prefix altitudes with A and speeds with S!'];
      }

      if (!_NavigationLibrary["default"].hasFixName(fixName)) {
        return [false, "unable to find '".concat(fixName, "'")];
      }

      if (!this._fms.hasWaypointName(fixName)) {
        return [false, "unable, '".concat(fixName, "' is not on our route")];
      }

      var airportModel = this._fms.arrivalAirportModel || this._fms.departureAirportModel;

      var waypoint = this._fms.findWaypoint(fixName); // altitude-only crossing restriction


      if (!speed) {
        var _altitudeCheck = aircraftModel.validateNextAltitude(altitude, airportModel);

        if (!_altitudeCheck[0]) {
          return _altitudeCheck;
        }

        altitude = airportModel.clampWithinAssignableAltitudes(altitude);
        waypoint.setAltitude(altitude);

        this._mcp.setAltitudeFieldValue(altitude);

        this._mcp.setAltitudeVnav();

        var _readback4 = {
          log: "cross ".concat(fixName.toUpperCase(), " at ").concat(altitude),
          say: "cross ".concat(fixName.toLowerCase(), " at ").concat((0, _radioUtilities.radio_altitude)(altitude))
        };
        return [true, _readback4];
      } // speed-only crossing restriction


      if (!altitude) {
        var _speedCheck = aircraftModel.validateNextSpeed(speed);

        if (!_speedCheck[0]) {
          return _speedCheck;
        }

        waypoint.setSpeed(speed);

        this._mcp.setSpeedFieldValue(speed);

        this._mcp.setSpeedVnav();

        var _readback5 = {
          log: "cross ".concat(fixName.toUpperCase(), " at ").concat(speed, "kt"),
          say: "cross ".concat(fixName.toLowerCase(), " at ").concat((0, _radioUtilities.radio_spellOut)(speed), " knots")
        };
        return [true, _readback5];
      } // altitude AND speed crossing restriction


      var altitudeCheck = aircraftModel.validateNextAltitude(altitude, airportModel);
      var speedCheck = aircraftModel.validateNextSpeed(speed);

      if (!altitudeCheck[0]) {
        return altitudeCheck;
      }

      if (!speedCheck[0]) {
        return speedCheck;
      }

      waypoint.setAltitude(altitude);
      waypoint.setSpeed(speed);

      this._mcp.setAltitudeFieldValue(altitude);

      this._mcp.setSpeedFieldValue(speed);

      this._mcp.setAltitudeVnav();

      this._mcp.setSpeedVnav();

      var readback = {
        log: "cross ".concat(fixName.toUpperCase(), " at ").concat(altitude, " and ").concat(speed, "kt"),
        say: "cross ".concat(fixName.toLowerCase(), " at ").concat((0, _radioUtilities.radio_altitude)(altitude), " and ").concat((0, _radioUtilities.radio_spellOut)(speed), " knots")
      };
      return [true, readback];
    }
    /**
     * Abort the landing attempt; maintain present heading/speed, and climb to a reasonable altitude
     *
     * @for Pilot
     * @method goAround
     * @param heading {number}           the aircraft's current heading
     * @param speed {number}             the aircraft's current speed
     * @param airportElevation {number}  the elevation of the airport, in feet MSL
     * @return {array}                   [success of operation, readback]
     */

  }, {
    key: "goAround",
    value: function goAround(heading, speed, airportElevation) {
      var altitudeToMaintain = (0, _ceil2["default"])(airportElevation, -2) + 1000;

      this._mcp.setHeadingFieldValue(heading);

      this._mcp.setHeadingHold();

      this._mcp.setAltitudeFieldValue(altitudeToMaintain);

      this._mcp.setAltitudeHold();

      this._mcp.setSpeedFieldValue(speed);

      this._mcp.setSpeedHold();

      var readback = {};
      readback.log = "go around, fly present heading, maintain ".concat(altitudeToMaintain);
      readback.say = "go around, fly present heading, maintain ".concat((0, _radioUtilities.radio_altitude)(altitudeToMaintain));
      return [true, readback];
    }
    /**
     * Intercept a radial course or localizer (horizontal guidance)
     *
     * @for Pilot
     * @method _interceptCourse
     * @param datum {StaticPositionModel}  the position the course is based upon
     * @param course {number}              the heading inbound to the datum
     * @return {array}                     [success of operation, readback]
     * @private
     */

  }, {
    key: "_interceptCourse",
    value: function _interceptCourse(datum, course) {
      this._mcp.setNav1Datum(datum);

      this._mcp.setCourseFieldValue(course);

      this._mcp.setHeadingVorLoc();

      var readback = {};
      readback.log = 'intercept localizer';
      readback.say = 'intercept localizer';
      return [true, readback];
    }
    /**
     * Intercept a glidepath or glideslop (vertical guidance)
     *
     * @for Pilot
     * @method _interceptGlidepath
     * @param datum {StaticPositionModel}  the position the glidepath is projected from
     * @param course {number}              the heading inbound to the datum
     * @param descentAngle {number}        the angle of descent along the glidepath
     * @return {array}                     [success of operation, readback]
     * @private
     */

  }, {
    key: "_interceptGlidepath",
    value: function _interceptGlidepath(datum, course, descentAngle) {
      // TODO: I feel like our description of lateral/vertical guidance should be done with its
      // own class rather than like this by storing all sorts of irrelevant stuff in the pilot/MCP.
      if (this._mcp.nav1Datum !== datum) {
        return [false, 'cannot follow glidepath because we are using lateral navigation from a different origin'];
      }

      if (this._mcp.course !== course) {
        return [false, 'cannot follow glidepath because its course differs from that specified for lateral guidance'];
      } // TODO: the descentAngle is a part of the ILS system itself, and should not be owned by the MCP


      this._mcp.setDescentAngle(descentAngle); // TODO: Though not realistic, to emulate the refusal to descend below MCP altitude
      // until established on the localizer, we should not be setting the altitude mode to
      // 'APP' until established on the localizer. This will prevent improper descent behaviors.


      this._mcp.setAltitudeApproach();

      return [true, 'intercept glidepath'];
    }
    /**
     * Conduct the specified instrument approachType
     * Note: Currently only supports ILS approaches
     * Note: Approach variants cannot yet be specified (eg RNAV-Y)
     *
     * @for pilot
     * @method conductInstrumentApproach
     * @param aircraftModel {AircraftModel} the aircraft model belonging to this pilot
     * @param approachType {string}         the type of instrument approach (eg 'ILS', 'RNAV', 'VOR', etc)
     * @param runwayModel {RunwayModel}     the runway the approach ends at
     * @return {array}                      [success of operation, readback]
     */

  }, {
    key: "conductInstrumentApproach",
    value: function conductInstrumentApproach(aircraftModel, approachType, runwayModel) {
      if ((0, _isNil2["default"])(runwayModel)) {
        return [false, 'the specified runway does not exist'];
      }

      var minimumGlideslopeInterceptAltitude = runwayModel.getMinimumGlideslopeInterceptAltitude();

      if (aircraftModel.mcp.altitude < minimumGlideslopeInterceptAltitude) {
        var _readback6 = {};
        _readback6.log = "unable ILS ".concat(runwayModel.name, ", our assigned altitude is below the minimum ") + "glideslope intercept altitude, request climb to ".concat(minimumGlideslopeInterceptAltitude);
        _readback6.say = "unable ILS ".concat((0, _radioUtilities.radio_runway)(runwayModel.name), ", our assigned altitude is below the minimum ") + "glideslope intercept altitude, request climb to ".concat((0, _radioUtilities.radio_altitude)(minimumGlideslopeInterceptAltitude));
        return [false, _readback6];
      } // TODO: split these two method calls and the corresponding ifs to a new method


      var datum = runwayModel.positionModel;
      var course = runwayModel.angle;
      var descentAngle = runwayModel.ils.glideslopeGradient;

      var lateralGuidance = this._interceptCourse(datum, course);

      var verticalGuidance = this._interceptGlidepath(datum, course, descentAngle); // TODO: As written, `._interceptCourse()` will always return true.


      if (!lateralGuidance[0]) {
        return lateralGuidance;
      }

      if (!verticalGuidance[0]) {
        return verticalGuidance;
      }

      this.cancelHoldingPattern();

      this._fms.setArrivalRunway(runwayModel);

      this.hasApproachClearance = true;
      var readback = {};
      readback.log = "cleared ".concat(approachType.toUpperCase(), " runway ").concat(runwayModel.name, " approach");
      readback.say = "cleared ".concat(approachType.toUpperCase(), " runway ").concat((0, _radioUtilities.radio_runway)(runwayModel.name), " approach");
      return [true, readback];
    } // TODO: Add ability to hold at present position

    /**
     * Conduct a holding pattern at a specific fix
     *
     * @for Fms
     * @method initiateHoldingPattern
     * @param fixName {string} name of the fix to hold over
     * @param holdParameters {object} parameters to apply to WaypointModel._holdParameters
     * @param fallbackInboundHeading {number} the inboundHeading that is used if no default is available
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "initiateHoldingPattern",
    value: function initiateHoldingPattern(fixName, holdParameters, fallbackInboundHeading) {
      var _this$_fms$activateHo = this._fms.activateHoldForWaypointName(fixName, holdParameters, fallbackInboundHeading),
          _this$_fms$activateHo2 = _slicedToArray(_this$_fms$activateHo, 2),
          success = _this$_fms$activateHo2[0],
          responseValue = _this$_fms$activateHo2[1];

      if (!success) {
        return [success, responseValue];
      } // When successful, the responseValue contains the actual holdParameters used by the
      // `WaypointModel`. This means that we can send partial holdParameters, to patch
      // the `WaypointModel`s _holdParameters property


      holdParameters = responseValue;
      var radialText = (0, _unitConverters.heading_to_string)(holdParameters.inboundHeading + Math.PI);
      var cardinalDirectionFromFix = (0, _radioUtilities.getRadioCardinalDirectionNameForHeading)(holdParameters.inboundHeading);
      var holdParametersReadback = "".concat(holdParameters.turnDirection, " turns, ").concat(holdParameters.legLength, " legs");
      var radialReadbackLog = "on the ".concat(radialText, " radial");
      var radialReadbackSay = "on the ".concat((0, _radioUtilities.radio_heading)(radialText), " radial"); // force lower-case in verbal readback to get speech synthesis to pronounce the fix instead of spelling it

      return [true, {
        log: "hold ".concat(cardinalDirectionFromFix, " of ").concat(fixName.toUpperCase(), " ").concat(radialReadbackLog, ", ").concat(holdParametersReadback),
        say: "hold ".concat(cardinalDirectionFromFix, " of ").concat(fixName.toLowerCase(), " ").concat(radialReadbackSay, ", ").concat(holdParametersReadback)
      }];
    }
    /**
     * Initialize all autopilot systems after being given an IFR clearance to destination
     *
     * @for Pilot
     * @method configureForTakeoff
     * @param initialAltitude {number} the altitude aircraft can automatically climb to at this airport
     * @param runway {RunwayModel} the runway taking off on
     * @param cruiseSpeed {number} the cruise speed of the aircraft, in knots
     */

  }, {
    key: "configureForTakeoff",
    value: function configureForTakeoff(initialAltitude, runway, cruiseSpeed) {
      if (this._mcp.altitude === _globalConstants.INVALID_NUMBER) {
        this._mcp.setAltitudeFieldValue(initialAltitude);
      }

      if (this._mcp.altitudeMode === _modeControlConstants.MCP_MODE.ALTITUDE.OFF) {
        this._mcp.setAltitudeHold();
      }

      if (this._mcp.heading === _globalConstants.INVALID_NUMBER) {
        this._mcp.setHeadingFieldValue(runway.angle);
      }

      if (this._mcp.headingMode === _modeControlConstants.MCP_MODE.HEADING.OFF) {
        this._mcp.setHeadingLnav();
      }

      if (this._mcp.speed === _globalConstants.INVALID_NUMBER) {
        this._mcp.setSpeedFieldValue(cruiseSpeed);
      }

      if (this._mcp.speedMode === _modeControlConstants.MCP_MODE.SPEED.OFF) {
        this._mcp.setSpeedN1();
      }
    }
    /**
     * Expedite the climb or descent to the assigned altitude, to use maximum possible rate
     *
     * @for Pilot
     * @method shouldExpediteAltitudeChange
     * @return {Array} [success of operation, readback]
     */

  }, {
    key: "shouldExpediteAltitudeChange",
    value: function shouldExpediteAltitudeChange() {
      this._mcp.shouldExpediteAltitudeChange = true;
      return [true, 'expediting to assigned altitude'];
    }
    /**
     * Skip ahead in the FMS to the waypoint for the specified waypointName, and activate LNAV to fly to it
     *
     * @for Pilot
     * @method proceedDirect
     * @param waypointName {string}  name of the fix we are flying direct to
     * @return {array}               [success of operation, readback]
     */

  }, {
    key: "proceedDirect",
    value: function proceedDirect(waypointName) {
      if (!this._fms.hasWaypointName(waypointName)) {
        return [false, "cannot proceed direct to ".concat(waypointName, ", it does not exist in our flight plan")];
      }

      this._fms.skipToWaypointName(waypointName);

      this.cancelHoldingPattern();

      this._mcp.setHeadingLnav();

      return [true, "proceed direct ".concat(waypointName)];
    }
    /**
     * End of takeoff, stop hand flying, and give the autopilot control of the aircraft
     *
     * Note: This should be done when the phase changes from takeoff to climb
     * Note: The 'raise landing gear' portion has no relevance, and exists solely for specificity of context
     *
     * @for Pilot
     * @method raiseLandingGearAndActivateAutopilot
     */

  }, {
    key: "raiseLandingGearAndActivateAutopilot",
    value: function raiseLandingGearAndActivateAutopilot() {
      this._mcp.enable();
    }
    /**
     * Replace the entire route with a new one built from the provided route string
     *
     * @for Pilot
     * @method replaceFlightPlanWithNewRoute
     * @param routeString {string}  routeString defining the new route to use
     * @return {array}              [success of operation, readback]
     */

  }, {
    key: "replaceFlightPlanWithNewRoute",
    value: function replaceFlightPlanWithNewRoute(routeString) {
      var readback = this._fms.replaceFlightPlanWithNewRoute(routeString);

      if (readback[0]) {
        this.hasDepartureClearance = true;
      }

      return readback;
    }
    /**
     * Return the altitude the aircraft is currently assigned. May be moving toward this altitude,
     * or already established at that altitude.
     *
     * @for Pilot
     * @method sayTargetedAltitude
     * @return {Array} [success of operation, readback]
     */

  }, {
    key: "sayTargetedAltitude",
    value: function sayTargetedAltitude() {
      var readback = {};
      readback.log = "we're assigned ".concat(this._mcp.altitude);
      readback.say = "we're assigned ".concat((0, _radioUtilities.radio_altitude)(this._mcp.altitude));
      return [true, readback];
    }
    /**
     * Return the heading the aircraft is currently targeting. May be moving toward this heading,
     * or already established at that heading.
     *
     * @for Pilot
     * @method sayTargetHeading
     * @return {array} [success of operation, readback]
     */

  }, {
    key: "sayTargetHeading",
    value: function sayTargetHeading() {
      var readback = {};

      switch (this._mcp.headingMode) {
        case _modeControlConstants.MCP_MODE.HEADING.HOLD:
          readback.log = "we're assigned heading ".concat(this._mcp.headingInDegrees);
          readback.say = "we're assigned heading ".concat((0, _radioUtilities.radio_heading)(this._mcp.headingInDegrees));
          return [true, readback];

        case _modeControlConstants.MCP_MODE.HEADING.VOR_LOC:
          readback.log = "we're joining a course of ".concat(this._mcp.course);
          readback.say = "we're joining a course of ".concat((0, _radioUtilities.radio_heading)(this._mcp.course));
          return [true, readback];

        case _modeControlConstants.MCP_MODE.HEADING.LNAV:
          {
            var waypoint = this._fms.currentWaypoint;
            var waypointPosition = waypoint.positionModel;
            var bearing = Math.round((0, _unitConverters.radiansToDegrees)(this.positionModel.bearingToPosition(waypointPosition)));
            readback.log = "our on-course heading to ".concat(waypoint.getDisplayName(), " is ").concat(bearing);
            readback.say = "our on-course heading to ".concat(waypoint.getDisplayName(), " is ").concat((0, _radioUtilities.radio_heading)(bearing));
            return [true, readback];
          }

        default:
          readback.log = 'we haven\'t been assigned a heading';
          readback.say = 'we haven\'t been assigned a heading';
          return [true, readback];
      }
    }
    /**
     * Return the speed the aircraft is currently assigned. May be moving toward this speed, or
     * already established at this speed.
     *
     * @for Pilot
     * @method sayTargetedSpeed
     */

  }, {
    key: "sayTargetedSpeed",
    value: function sayTargetedSpeed() {
      // TODO: How do we handle the cases where aircraft are using VNAV speed?
      return [true, this._mcp.speed];
    }
    /**
     * Stop taxiing to the runway and return to the gate
     *
     * @for Pilot
     * @method stopOutboundTaxiAndReturnToGate
     * @return {Array} [success of operation, readback]
     */

  }, {
    key: "stopOutboundTaxiAndReturnToGate",
    value: function stopOutboundTaxiAndReturnToGate() {
      this._fms.flightPhase = _aircraftConstants.FLIGHT_PHASE.APRON; // TODO: What to do with this little number....?
      // aircraft.taxi_start = 0;

      return [true, 'taxiing back to the gate'];
    }
    /**
     * Leave the departure line and return to the gate
     *
     * @for Pilot
     * @method stopWaitingInRunwayQueueAndReturnToGate
     * @return {Array} [success of operation, readback]
     */

  }, {
    key: "stopWaitingInRunwayQueueAndReturnToGate",
    value: function stopWaitingInRunwayQueueAndReturnToGate() {
      // TODO: this will likely need to be called from somewhere other than the `AircraftCommander`
      // TODO: remove aircraft from the runway queue (`Runway.removeAircraftFromQueue()`)
      this._fms.flightPhase = _aircraftConstants.FLIGHT_PHASE.APRON;
      return [true, 'taxiing back to the gate'];
    }
  }]);

  return Pilot;
}();

exports["default"] = Pilot;

},{"../../airport/AirportController":284,"../../constants/aircraftConstants":303,"../../constants/globalConstants":310,"../../math/circle":348,"../../navigationLibrary/NavigationLibrary":361,"../../utilities/radioUtilities":389,"../../utilities/unitConverters":391,"../FlightManagementSystem/Fms":268,"../ModeControl/ModeController":272,"../ModeControl/modeControlConstants":273,"lodash/ceil":179,"lodash/find":191,"lodash/floor":198,"lodash/isNil":219}],275:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _find2 = _interopRequireDefault(require("lodash/find"));

var _without2 = _interopRequireDefault(require("lodash/without"));

var _BaseCollection2 = _interopRequireDefault(require("../../base/BaseCollection"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Collection used to manage `StripViewModel` objects
 *
 * @class StripViewCollection
 * @extends BaseCollection
 */
var StripViewCollection =
/*#__PURE__*/
function (_BaseCollection) {
  _inherits(StripViewCollection, _BaseCollection);

  /**
   *
   * @constructor
   */
  function StripViewCollection() {
    var _this;

    _classCallCheck(this, StripViewCollection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(StripViewCollection).call(this));
    /**
     * Inherited from `BaseCollection`
     *
     * @property _items
     * @type {array<any>}
     * @default []
     * @private
     */

    /**
     * Inherited from `BaseCollection`
     *
     * @property length
     * @type {number}
     */

    return _possibleConstructorReturn(_this, _this._init());
  }
  /**
   * Initialize the instance
   *
   * @for StripViewCollection
   * @method _init
   */


  _createClass(StripViewCollection, [{
    key: "_init",
    value: function _init() {}
    /**
     * Reset the instance
     *
     * @for StripViewCollection
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this._items = [];
    }
    /**
     * Add a `StripViewModel` instance to the collection
     *
     * @for StripViewCollection
     * @method addItem
     */

  }, {
    key: "addItem",
    value: function addItem(stripViewModel) {
      this._items.push(stripViewModel);
    }
    /**
     * Remove a `StripViewModel` instance from the collection
     *
     * @for StripViewCollection
     * @method removeItem
     */

  }, {
    key: "removeItem",
    value: function removeItem(stripViewModel) {
      this._items = (0, _without2["default"])(this._items, stripViewModel);
    }
    /**
     * Find an active `StripViewModel`.
     *
     * Active is defined by the presence of a specific css classname
     *
     * @for StripViewCollection
     * @method findActiveStripViewModel
     * @return {StripViewModel}
     */

  }, {
    key: "findActiveStripViewModel",
    value: function findActiveStripViewModel() {
      return (0, _find2["default"])(this._items, {
        isActive: true
      });
    }
    /**
     * Find a `StripViewModel` in the collection by an `aircraftid`
     *
     * @for StripViewCollection
     * @method findStripByAircraftId
     * @param aircraftId {number}
     * @return {StripViewModel|undefined}
     */

  }, {
    key: "findStripByAircraftId",
    value: function findStripByAircraftId(aircraftId) {
      return (0, _find2["default"])(this._items, {
        aircraftId: aircraftId
      });
    }
  }]);

  return StripViewCollection;
}(_BaseCollection2["default"]);

exports["default"] = StripViewCollection;

},{"../../base/BaseCollection":294,"lodash/find":191,"lodash/without":252}],276:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _random2 = _interopRequireDefault(require("lodash/random"));

var _without2 = _interopRequireDefault(require("lodash/without"));

var _StripViewCollection = _interopRequireDefault(require("./StripViewCollection"));

var _StripViewModel = _interopRequireDefault(require("./StripViewModel"));

var _globalConstants = require("../../constants/globalConstants");

var _selectors = require("../../constants/selectors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * The highest number allowed for a cid value
 *
 * @property CID_UPPER_BOUND
 * @type {number}
 * @final
 */
var CID_UPPER_BOUND = 999;
/**
 * Control modifications of the `$stripViewList` and coordinate
 * management of the `StripViewCollection`. Also responsible for
 * creating new `StripViewModel` instances.
 *
 * @class StripViewController
 */

var StripViewController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   */
  function StripViewController() {
    var _this = this;

    _classCallCheck(this, StripViewController);

    _defineProperty(this, "_onStripListToggle", function (event) {
      _this.$stripView.toggleClass(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_IS_HIDDEN);
    });

    _defineProperty(this, "_onStripListClickOutsideStripViewModel", function (event) {
      return _this.findAndDeselectActiveStripView();
    });

    /**
     * Collection class used to manage instances of `StripViewModel`s
     *
     * @property _collection
     * @type {StripViewCollection}
     * @default null
     * @private
     */
    this._collection = null;
    /**
     * Root list view element
     *
     * @property $stripView
     * @type {JQuery|HTMLElement}
     */

    this.$stripView = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.STRIP_VIEW);
    /**
     * List element containing each `StripViewModel` instance that is an Arrival
     *
     * @property $stripViewListArrivals
     * @type {JQuery|HTMLElement}
     */

    this.$stripViewListArrivals = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.STRIP_VIEW_ARRIVALS_LIST);
    /**
     * List element containing each `StripViewModel` instance that is a Departure
     *
     * @property $stripViewListDepartures
     * @type {JQuery|HTMLElement}
     */

    this.$stripViewListDepartures = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.STRIP_VIEW_DEPARTURES_LIST);
    /**
     * Trigger that toggles visibility of the `$stripView`
     *
     * @property $stripListTrigger
     * @type {JQuery|HTMLElement}
     */

    this.$stripListTrigger = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.STRIP_VIEW_TRIGGER);
    /**
     * @property _cidNumbersInUse
     * @type {array<number>}
     * @private
     */

    this._cidNumbersInUse = [];
    return this._init().enable();
  }
  /**
   * Initialize the instance
   *
   * Should be run only once on instantiation
   *
   * @for StripViewController
   * @method _init
   */


  _createClass(StripViewController, [{
    key: "_init",
    value: function _init() {
      this._collection = new _StripViewCollection["default"]();
      return this;
    }
    /**
     * Enable handlers
     *
     * @for StripViewController
     * @method enable
     * @chainable
     */

  }, {
    key: "enable",
    value: function enable() {
      this.$stripListTrigger.on('click', this._onStripListToggle);
      this.$stripViewListArrivals.on('click', this._onStripListClickOutsideStripViewModel);
      this.$stripViewListDepartures.on('click', this._onStripListClickOutsideStripViewModel);
      return this;
    }
    /**
     * Tear down handlers and destroy the instance
     *
     * @for StripViewController
     * @method destroy
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._collection = null;
    }
    /**
     * Provides a way to check if a `StripViewModel` exists for a given `AircraftModel`
     *
     * @for StripViewController
     * @method hasStripViewModel
     * @param aircraftModel {AircraftModel}
     * @returns {booelan}
     */

  }, {
    key: "hasStripViewModel",
    value: function hasStripViewModel(aircraftModel) {
      var stripViewModel = this._collection.findStripByAircraftId(aircraftModel.id);

      return typeof stripViewModel !== 'undefined';
    }
    /**
     * Update each `StripViewModel` with new aricraft data
     *
     * The `StripViewModel` provides an early out when
     * `StripViewModel.shouldUpdate()` returns false
     *
     * This method is part of the animation loop
     *
     * @for StripViewController
     * @method update
     * @param aircraftList {array<AircraftModel>}
     */

  }, {
    key: "update",
    value: function update(aircraftList) {
      // TODO: this should probably work the other way; loop through list items and find an aircraft.
      // We need a proper `AircraftCollection` for that to work
      for (var i = 0; i < aircraftList.length; i++) {
        var aircraftModel = aircraftList[i];

        if (!aircraftModel.isControllable) {
          continue;
        }

        var stripViewModel = this._collection.findStripByAircraftId(aircraftModel.id);

        if (typeof stripViewModel === 'undefined') {
          stripViewModel = this.createStripView(aircraftModel);
        }

        stripViewModel.update(aircraftModel);
      }
    }
    /**
     * Create a new `StripViewModel` instance and add it to the collection
     *
     * @for StripViewController
     * @method createStripView
     * @param aircraftModel {AircraftModel}
     * @return {StripViewModel}
     */

  }, {
    key: "createStripView",
    value: function createStripView(aircraftModel) {
      var stripViewCid = this._generateCidNumber();

      var stripViewModel = new _StripViewModel["default"](aircraftModel, stripViewCid);

      this._collection.addItem(stripViewModel);

      if (aircraftModel.isDeparture() || aircraftModel.isControllable) {
        this._addViewToStripList(stripViewModel);
      }

      return stripViewModel;
    }
    /**
     * Find a `StripViewModel` and attempt to add an active state
     *
     * @for StripViewController
     * @method selectStripView
     * @param  aircraftModel {AircraftModel}
     */

  }, {
    key: "selectStripView",
    value: function selectStripView(aircraftModel) {
      var stripModel = this._collection.findStripByAircraftId(aircraftModel.id);

      if (!stripModel) {
        throw Error("No StripViewModel found for selected Aircraft: ".concat(aircraftModel.callsign));
      }

      this.findAndDeselectActiveStripView();
      stripModel.addActiveState();
    }
    /**
     * Given a `stripViewModel`, call the `.removeActiveState()` method
     * that will remove the active css classname
     *
     * @for StripViewController
     * @method deselectStripView
     * @param stripViewModel {StripViewModel}
     */

  }, {
    key: "deselectStripView",
    value: function deselectStripView(stripViewModel) {
      if (!(stripViewModel instanceof _StripViewModel["default"])) {
        throw new TypeError("Expected stripViewModel to be an instance of StripViewModel but instead found ".concat(_typeof(stripViewModel)));
      }

      stripViewModel.removeActiveState();
    }
    /**
     * Method used to deselect an active `StripViewModel` when
     * the specific model is not known.
     *
     * This useful for when a click is registered within the
     * `stripViewList`, but not on a specific `StripViewModel`
     * or when an event is triggered to clear the active callsign
     *
     * @for StripViewController
     * @method findAndDeselectActiveStripView
     * @private
     */

  }, {
    key: "findAndDeselectActiveStripView",
    value: function findAndDeselectActiveStripView() {
      var activeStripViewModel = this._collection.findActiveStripViewModel();

      if (!activeStripViewModel) {
        return;
      }

      this.deselectStripView(activeStripViewModel);
    }
    /**
     * Remove a `StripViewModel` from the `$stripViewList`
     *
     * @for StripViewController
     * @method removeStripView
     * @param aircraftModel {AircraftModel}
     */

  }, {
    key: "removeStripView",
    value: function removeStripView(aircraftModel) {
      var stripViewModel = this._collection.findStripByAircraftId(aircraftModel.id);

      if (!stripViewModel) {
        console.warn("Attempted to remove a StripViewModel for ".concat(aircraftModel.callsign, " that does not exist.") + 'This is likely not a fatal problem, but if you are seeing this, please let somebody know.');
        return;
      }

      this._removeCidFromUse(stripViewModel.cid);

      this._collection.removeItem(stripViewModel);

      stripViewModel.destroy();
    }
    /**
     * Add `StripViewModel` to the `$stripViewList`
     *
     * This adds a given `stripViewModel` into the DOM as a
     * child of `$stripViewList`
     *
     * @for StripViewController
     * @method _addViewToStripList
     * @param stripViewModel {StripViewModel}
     * @private
     */

  }, {
    key: "_addViewToStripList",
    value: function _addViewToStripList(stripViewModel) {
      if (!(stripViewModel instanceof _StripViewModel["default"])) {
        throw new TypeError("Expected an instance of StripViewModel but received ".concat(_typeof(stripViewModel)));
      }

      var listView = stripViewModel.isDeparture ? this.$stripViewListDepartures : this.$stripViewListArrivals;
      var scrollPosition = listView.scrollTop();
      listView.prepend(stripViewModel.$element); // shift scroll down one strip's height

      listView.scrollTop(scrollPosition + _StripViewModel["default"].HEIGHT);
    }
    /**
     * Event handler for when a `StripViewModel` instance is clicked
     *
     * @for StripViewController
     * @method _onStripListToggle
     * @param event {JQueryEventObject}
     * @private
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "_generateCidNumber",

    /**
     * Generate a unique number to represent a `CID`
     *
     * Should be displayed with leading zeros, so a `CID` value of `1` should be displayed as `001`
     *
     * @for StripViewController
     * @method _generateCidNumber
     * @return nextCid {number}
     * @private
     */
    value: function _generateCidNumber() {
      var nextCid = (0, _random2["default"])(1, CID_UPPER_BOUND);

      if (this._cidNumbersInUse.indexOf(nextCid) !== _globalConstants.INVALID_INDEX) {
        return this._generateCidNumber();
      }

      this._cidNumbersInUse.push(nextCid);

      return nextCid;
    }
    /**
     * Remove a given `#cid` from use
     *
     * Used when an aircraft has landed or departed controlled airspace
     *
     * @for StripViewController
     * @method _removeCidFromUse
     * @param cid {number}
     * @private
     */

  }, {
    key: "_removeCidFromUse",
    value: function _removeCidFromUse(cid) {
      var cidIndex = this._cidNumbersInUse.indexOf(cid);

      if (cidIndex === _globalConstants.INVALID_INDEX) {
        return;
      }

      this._cidNumbersInUse = (0, _without2["default"])(this._cidNumbersInUse, cid);
    }
  }]);

  return StripViewController;
}();

exports["default"] = StripViewController;

},{"../../constants/globalConstants":310,"../../constants/selectors":316,"./StripViewCollection":275,"./StripViewModel":277,"jquery":1,"lodash/random":237,"lodash/without":252}],277:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _BaseModel2 = _interopRequireDefault(require("../../base/BaseModel"));

var _EventBus = _interopRequireDefault(require("../../lib/EventBus"));

var _stripViewTemplate = require("./stripViewTemplate");

var _eventNames = require("../../constants/eventNames");

var _globalConstants = require("../../constants/globalConstants");

var _selectors = require("../../constants/selectors");

var _generalUtilities = require("../../utilities/generalUtilities");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Encapsulation of data and view elements for a single aircraft progress strip
 *
 * Handles display and updating of an aircraft progress strip
 *
 * @class StripViewModel
 * @extends BaseModel
 */
var StripViewModel =
/*#__PURE__*/
function (_BaseModel) {
  _inherits(StripViewModel, _BaseModel);

  /**
   * Height of the AircraftStrip DOM element in px.
   *
   * @property AIRCRAFT_STRIP_HEIGHT
   * @type {number}
   * @static
   */

  /**
   * @constructor
   * @param aircraftModel {object}
   * @param cidValue {number}
   */
  function StripViewModel(aircraftModel, cidValue) {
    var _this;

    _classCallCheck(this, StripViewModel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(StripViewModel).call(this, 'stripViewModel'));
    /**
     * Model `#_id` inherited from `BaseModel`
     *
     * @property _id
     * @type {string}
     */

    /**
     * Internal reference to `EventBus` class
     *
     * @property _eventBus
     * @type {EventBus}
     * @default EventBus
     * @private
     */

    _this._eventBus = _EventBus["default"];
    /**
     * If an aircraft is a Departure
     *
     * When this is true it means the aircraft is a Departure
     * and if this is false it means the aircraft is an Arrival.
     *
     * @property isDeparture
     * @type {boolean}
     * @default false
     */

    _this.isDeparture = false;
    /**
     * Root HTML Element
     *
     * @property $element
     * @type {JQuery Element}
     * @default null
     */

    _this.$element = null;
    /**
     * Reference to the `AircraftModel#id` property
     *
     * Used only for associating a `StripViewModel` with a
     * specific `aircraftId`
     *
     * @property aircraftId
     * @type {string}
     */

    _this.aircraftId = aircraftModel.id;
    /**
     * If an aircraft inside controlled airspace
     *
     * When this is true it means the aircraft is (or should)
     * be under ATC control and it's progress strip should
     * be visible in the strip list.
     *
     * @property insideCenter
     * @type {boolean}
     * @default false
     */

    _this.insideCenter = false;
    /**
     * CSS classname applied for arrival or departure
     *
     * @property _categoryClassname
     * @type string
     * @default ''
     */

    _this._categoryClassName = ''; // the following properties are arranged in view order
    // this sort will be used throughout this class

    /**
     * Aircraft callsign
     *
     * @property _callsign
     * @type {string}
     * @default ''
     * @private
     */

    _this._callsign = '';
    /**
     * HTML Element that holds the `#_callsign` value
     *
     * @property
     * @type {JQuery Element}
     * @default null
     */

    _this.$callsignView = null;
    /**
     * The aircraft type, with weight prefix and equipment suffix
     *
     * Will be generated by the `AircraftTypeDefinitionModel`,
     * this merely caches that value so it doesn't need to be
     * calculated every time.
     *
     * @property _aircraftType
     * @type {string}
     * @default ''
     * @private
     */

    _this._aircraftType = '';
    /**
     * HTML Element that holds the `#_aircraftType` value
     *
     * @property $aircraftTypeView
     * @type {JQuery Element}
     * @default null
     */

    _this.$aircraftTypeView = null;
    /**
     * This value is generated by the `StripViewController` and is
     * unique to every `StripViewModel`
     *
     * Currently only numeric, but could be made alpha-numberic
     *
     * Padded with leading zeros in `#cidString` for display purposes
     *
     * @property cid
     * @type {number}
     * @default cidValue
     */

    _this.cid = cidValue;
    /**
     * A string version of `#cid` for display purposes
     * Has been padded with leading zeros so that it is always
     * displayed as three digits
     *
     * @property cidString
     * @type {string}
     * @default cidValue
     */

    _this.cidString = (0, _generalUtilities.leftPad)(cidValue, 3);
    /**
     * HTML Element that holds `#_cidValue`
     *
     * @property $cidView
     * @type {JQuery Element}
     * @default null
     */

    _this.$cidView = null;
    /**
     * Aircraft transponder code
     *
     * @property _transponder
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    _this._transponder = _globalConstants.INVALID_NUMBER;
    /**
     * HTML Element that holds the `#_transponderCode` value
     *
     * @property $transponderView
     * @type {JQuery Element}
     * @default null
     */

    _this.$transponderView = null;
    /**
     * Altitude aircraft has been assigned in FL feet
     *
     * @property _assingedAltitude
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    _this._assignedAltitude = _globalConstants.INVALID_NUMBER;
    /**
     * HTML Element that holds the `#_assignedAltitude` value
     *
     * @property $assignedAltitudeView
     * @type {JQuery Element}
     * @default null
     */

    _this.$assignedAltitudeView = null;
    /**
     * Cruise altitude
     *
     * @property _flightPlanAltitude
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    _this._flightPlanAltitude = _globalConstants.INVALID_NUMBER;
    /**
     * HTML Element that holds the `#_flightPlanAltitude` value
     *
     * @property $flightPlanAltitudeView
     * @type {JQuery Element}
     * @default null
     */

    _this.$flightPlanAltitudeView = null;
    /**
     * Arrival airport icao
     *
     * @property _arrivalAirport
     * @type
     * @default
     * @private
     */

    _this._arrivalAirport = '';
    /**
     * HTML Element that hold the `#_arrivalAirport` value
     *
     * @property $arrivalAirportView
     * @type {JQuery Element}
     * @default null
     */

    _this.$arrivalAirportView = null;
    /**
     * Departure airport icao
     *
     * @property _departureAirport
     * @type
     * @default
     * @private
     */

    _this._departureAirport = '';
    /**
     * HTML Element that hold the `#_departureAirport` value
     *
     * @property $departureAirportView
     * @type {JQuery Element}
     * @default null
     */

    _this.$departureAirportView = null;
    /**
     * Alternate airport icao
     *
     * @property _alternateAirport
     * @type
     * @default
     * @private
     */

    _this._alternateAirport = '';
    /**
     * HTML Element that hold the `#_alternateAirport` value
     *
     * @property $alternateAirportView
     * @type {JQuery Element}
     * @default null
     */

    _this.$alternateAirportView = null;
    /**
     * Route string that represents the 'filed' flight plan
     *
     * @property _flightPlan
     * @type {string}
     * @default ''
     * @private
     */

    _this._flightPlan = '';
    /**
     * HTML Element that holds the `#_flightPlan` value
     *
     * @property $flightPlanView
     * @type {JQuery Element}
     * @default null
     */

    _this.$flightPlanView = null;
    /**
     * Value of the remarks field
     *
     * @property _remarks
     * @type {string}
     * @default ''
     * @private
     */

    _this._remarks = '';
    /**
     * HTML Element that holds the `#remarks` value
     *
     * @property $remarks
     * @type {JQuery Element}
     * @default null
     */

    _this.$remarks = null;
    /**
     * The expected or assigned runway
     *
     * @property _runwayInformation
     * @type {object}
     * @default ''
     * @private
     */

    _this._runwayInformation = null;
    /**
     * HTML Element that holds the `#runway` value
     *
     * @property $runway
     * @type {JQuery Element}
     * @default null
     */

    _this.$runway = null;
    return _possibleConstructorReturn(_this, _this._init(aircraftModel)._createChildren()._setupHandlers()._enable()._layout()._redraw());
  }
  /**
   * Does `#$element` currently have the active css classname applied
   *
   * This is useful when trying to find the current active `stripView`
   * by looping through the `StripViewCollection#_items`.
   *
   * @property isActive
   * @type {boolean}
   */


  _createClass(StripViewModel, [{
    key: "_init",

    /**
     * Initialize the instance
     *
     * Should be run once only on instantiation
     *
     * @for StripViewModel
     * @method _init
     * @param aircraftModel {object}
     * @chainable
     */
    value: function _init(aircraftModel) {
      var _aircraftModel$getVie = aircraftModel.getViewModel(),
          insideCenter = _aircraftModel$getVie.insideCenter,
          callsign = _aircraftModel$getVie.callsign,
          icaoWithWeightClass = _aircraftModel$getVie.icaoWithWeightClass,
          transponderCode = _aircraftModel$getVie.transponderCode,
          assignedAltitude = _aircraftModel$getVie.assignedAltitude,
          arrivalAirportId = _aircraftModel$getVie.arrivalAirportId,
          departureAirportId = _aircraftModel$getVie.departureAirportId,
          flightPlanAltitude = _aircraftModel$getVie.flightPlanAltitude,
          flightPlan = _aircraftModel$getVie.flightPlan;

      this.insideCenter = insideCenter;
      this._callsign = callsign;
      this._transponder = transponderCode;
      this._aircraftType = icaoWithWeightClass;
      this._assignedAltitude = assignedAltitude;
      this._flightPlanAltitude = flightPlanAltitude;
      this._arrivalAirport = arrivalAirportId;
      this._departureAirport = departureAirportId;
      this._flightPlan = flightPlan;
      this._categoryClassName = this._buildClassnameForFlightCategory(aircraftModel);
      this.isDeparture = aircraftModel.isDeparture();
      this._runwayInformation = this._buildRunwayInformation(aircraftModel);
      return this;
    }
    /**
     * Set initial element references
     *
     * Should be run once only on instantiation
     *
     * @for StripViewModel
     * @method _createChildren
     * @chainable
     */

  }, {
    key: "_createChildren",
    value: function _createChildren() {
      this.$element = (0, _jquery["default"])(_stripViewTemplate.STRIP_VIEW_TEMPLATE);
      this.$callsignView = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_CALLSIGN);
      this.$aircraftTypeView = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_AIRCRAFT_TYPE);
      this.$cidView = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_CID);
      this.$transponderView = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_TRANSPONDER);
      this.$assignedAltitudeView = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_ASSIGNED_ALTITUDE);
      this.$flightPlanAltitudeView = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_FLIGHT_PLAN_ALTITUDE);
      this.$arrivalAirportView = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_ARRIVAL_AIRPORT_ID);
      this.$departureAirportView = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_DEPARTURE_AIRPORT_ID);
      this.$alternateAirportView = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_ALTERNATE_AIRPORT_ID);
      this.$flightPlanView = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_FLIGHT_PLAN);
      this.$remarks = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_REMARKS);
      this.$runway = this.$element.find(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_RUNWAY);
      return this;
    }
    /**
     * Create event handlers
     *
     * Should be run once only on instantiation
     *
     * @for StripViewModel
     * @method _setupHandlers
     * @chainable
     */

  }, {
    key: "_setupHandlers",
    value: function _setupHandlers() {
      this._onClickHandler = this._onClick.bind(this);
      this._onDoubleClickHandler = this._onDoubleClick.bind(this);
      return this;
    }
    /**
     * Register handlers with events on the `$element`
     *
     * @for StripViewModel
     * @method _enable
     * @private
     */

  }, {
    key: "_enable",
    value: function _enable() {
      this.$element.on('click', this._onClickHandler);
      this.$element.on('dblclick', this._onDoubleClickHandler);
      return this;
    }
    /**
     * Set the layout with the correct data
     *
     * This method will be run on instantiation to set up the view for the first time
     * and will also run on every subsequent re-render.
     *
     * We do not selectively render, if one property has changed
     * (as determined by `_shouldUpdate()`) we re-draw everything in one shot.
     *
     * @for StripViewModel
     * @method _layout
     * @chainable
     */

  }, {
    key: "_layout",
    value: function _layout() {
      this.$element.addClass(this._categoryClassName);
      return this;
    }
    /**
     * Update teh view with new data
     *
     * This method will be run on instantiation to initialize the view with data,
     * and will be run again any time updatable data has changed.
     *
     * After instantiation, this method should only be run after `._shouldUpdate()`
     * has returned true.
     *
     * @for StripViewModel
     * @method _render
     * @chainable
     */

  }, {
    key: "_redraw",
    value: function _redraw() {
      this.$callsignView.text(this._callsign);
      this.$aircraftTypeView.text(this._aircraftType);
      this.$cidView.text(this.cidString);
      this.$transponderView.text(this._transponder);
      this.$assignedAltitudeView.text(this._assignedAltitude);
      this.$flightPlanAltitudeView.text(this._flightPlanAltitude);
      this.$departureAirportView.text(this._departureAirport);
      this.$arrivalAirportView.text(this._arrivalAirport);
      this.$alternateAirportView.text(this._alternateAirport);
      this.$flightPlanView.text(this._flightPlan);
      this.$remarks.text(this._remarks);
      this.$runway.text(this._runwayInformation.name);
      return this;
    }
    /**
     * Disable the instance ane tear down handlers
     *
     * @for StripViewModel
     * @method disable
     */

  }, {
    key: "disable",
    value: function disable() {
      this.$element.off('click', this._onClickHandler);
      this.$element.off('dblclick', this._onDoubleClickHandler);
      return this;
    }
    /**
     * Destroy the instance
     *
     * @for StripViewModel
     * @method destroy
     * @chainable
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.disable();
      this.$element.remove();
      this.id = '';
      this._eventBus = null;
      this.$element = null;
      this.aircraftId = '';
      this.insideCenter = false;
      this._categoryClassName = '';
      this._callsign = '';
      this.$callsignView = null;
      this._aircraftType = '';
      this.$aircraftTypeView = null;
      this.cid = _globalConstants.INVALID_NUMBER;
      this.cidString = '';
      this.$cidView = null;
      this._transponder = 1200;
      this.$transponderView = null;
      this._assignedAltitude = _globalConstants.INVALID_NUMBER;
      this.$assignedAltitudeView = null;
      this._flightPlanAltitude = _globalConstants.INVALID_NUMBER;
      this.$flightPlanAltitudeView = null;
      this._arrivalAirport = '';
      this.$arrivalAirportView = null;
      this._departureAirport = '';
      this.$departureAirportView = null;
      this._alternateAirport = '';
      this.$alternateAirportView = null;
      this._flightPlan = '';
      this.$flightPlanView = null;
      this._remarks = '';
      this.$remarks = null;
      this._runwayInformation = null;
      this.$runway = null;
      return this;
    }
    /**
     * Update the instance with new information or return
     * early if nothing has changed
     *
     * @for StripViewModel
     * @method update
     * @param aircraftModel {AircraftModel}
     */

  }, {
    key: "update",
    value: function update(aircraftModel) {
      if (!this._shouldUpdate(aircraftModel)) {
        return;
      }

      this._updateStripView(aircraftModel);
    }
    /**
     * Add active css classname
     *
     * @for StripViewModel
     * @method addActiveState
     */

  }, {
    key: "addActiveState",
    value: function addActiveState() {
      this.$element.addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
    }
    /**
     * Remove active css classname
     *
     * @for StripViewModel
     * @method removeActiveState
     */

  }, {
    key: "removeActiveState",
    value: function removeActiveState() {
      this.$element.removeClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
    }
    /**
     * Return a classname based on whether an aircraft is a `departure` or an `arrival`
     *
     * @for AircraftStripView
     * @method _buildClassnameForFlightCategory
     * @param aircraftModel {AircraftModel}
     * @return {string}
     */

  }, {
    key: "_buildClassnameForFlightCategory",
    value: function _buildClassnameForFlightCategory(aircraftModel) {
      if (aircraftModel.isDeparture()) {
        return _selectors.SELECTORS.CLASSNAMES.DEPARTURE;
      }

      if (aircraftModel.isOverflight()) {
        return _selectors.SELECTORS.CLASSNAMES.OVERFLIGHT;
      }

      return _selectors.SELECTORS.CLASSNAMES.ARRIVAL;
    }
    /**
     * Returns the runway and if it is expected or assigned based on whether an
     * aircraft is a `departure` or an `arrival`.
     *
     * @for AircraftStripView
     * @method _buildRunwayInformation
     * @param aircraftModel {AircraftModel}
     * @return {object}
     */

  }, {
    key: "_buildRunwayInformation",
    value: function _buildRunwayInformation(aircraftModel) {
      if (aircraftModel.isDeparture() && aircraftModel.isOnGround()) {
        return {
          hasRunwayAssigned: !aircraftModel.isApron(),
          name: aircraftModel.fms.departureRunwayModel.name
        };
      }

      if (aircraftModel.isArrival()) {
        return {
          hasRunwayAssigned: aircraftModel.pilot.hasApproachClearance,
          name: aircraftModel.fms.arrivalRunwayModel.name
        };
      }

      return {
        hasRunwayAssigned: false,
        name: ''
      };
    }
    /**
     * Click handler for a single click on `StripViewModel`
     *
     * This method will prevent event bubbling so a click
     * doesn't cause the `stripView` to close
     *
     * @for AircraftStripView
     * @method _onClick
     * @param event {jquery event}
     * @private
     */

  }, {
    key: "_onClick",
    value: function _onClick(event) {
      event.stopPropagation();

      this._eventBus.trigger(_eventNames.EVENT.STRIP_CLICK, this._callsign);
    }
    /**
     * Handler for a double-click on an AircraftStripView
     *
     * Initiates the process of centering a single aircraft in the middle of the view
     *
     * This method should prevent event bubbling so a click doesn't cause the `stripView` to close
     *
     * @for AircraftStripView
     * @method _onDoubleClick
     * @param  event {Event}
     * @private
     */

  }, {
    key: "_onDoubleClick",
    value: function _onDoubleClick(event) {
      event.stopPropagation();

      this._eventBus.trigger(_eventNames.EVENT.STRIP_DOUBLE_CLICK, this._callsign);
    }
    /**
     * Encapsulation of boolean logic used to determine if the view needs to be updated
     *
     * This method provides an implementation an 'early exit', so if the view doesn't
     * need to be updated it can be skipped.
     *
     * @for StripViewModel
     * @method shouldUpdate
     * @param  aircraftModel {AircraftModel}
     * @return {boolean}
     * @private
     */

  }, {
    key: "_shouldUpdate",
    value: function _shouldUpdate(aircraftModel) {
      var viewModel = aircraftModel.getViewModel();

      var runwayInfo = this._buildRunwayInformation(aircraftModel);

      return this.insideCenter !== viewModel.insideCenter || this._transponder !== viewModel.transponderCode || this._assignedAltitude !== viewModel.assignedAltitude || this._flightPlanAltitude !== viewModel.flightPlanAltitude || this._arrivalAirport !== viewModel.arrivalAirportId || this._departureAirport !== viewModel.departureAirportId || this._flightPlan !== viewModel.flightPlan || this._runwayInformation.hasRunwayAssigned !== runwayInfo.hasRunwayAssigned || this._runwayInformation.name !== runwayInfo.name;
    }
    /**
     * Update instance properties with new values from the `AircraftModel`
     *
     * This method should only be run after `_shouldUpdate()` returns true
     * This method will only update the mutable properties of `StripViewModel`
     *
     * @for StripViewModel
     * @method _updateStripView
     * @param {AircraftModel} aircraftModel
     * @private
     */

  }, {
    key: "_updateStripView",
    value: function _updateStripView(aircraftModel) {
      var _aircraftModel$getVie2 = aircraftModel.getViewModel(),
          insideCenter = _aircraftModel$getVie2.insideCenter,
          transponderCode = _aircraftModel$getVie2.transponderCode,
          assignedAltitude = _aircraftModel$getVie2.assignedAltitude,
          arrivalAirportId = _aircraftModel$getVie2.arrivalAirportId,
          departureAirportId = _aircraftModel$getVie2.departureAirportId,
          flightPlanAltitude = _aircraftModel$getVie2.flightPlanAltitude,
          flightPlan = _aircraftModel$getVie2.flightPlan;

      this.insideCenter = insideCenter;
      this._transponder = transponderCode;
      this._assignedAltitude = assignedAltitude;
      this._flightPlanAltitude = flightPlanAltitude;
      this._arrivalAirport = arrivalAirportId;
      this._departureAirport = departureAirportId;
      this._flightPlan = flightPlan;
      this._runwayInformation = this._buildRunwayInformation(aircraftModel);
      this.$runway.toggleClass(_selectors.SELECTORS.CLASSNAMES.STRIP_VIEW_PREPLANNING, !this._runwayInformation.hasRunwayAssigned);
      return this._redraw();
    }
  }, {
    key: "isActive",
    get: function get() {
      return this.$element.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
    }
  }]);

  return StripViewModel;
}(_BaseModel2["default"]);

exports["default"] = StripViewModel;

_defineProperty(StripViewModel, "HEIGHT", 60);

},{"../../base/BaseModel":295,"../../constants/eventNames":308,"../../constants/globalConstants":310,"../../constants/selectors":316,"../../lib/EventBus":346,"../../utilities/generalUtilities":387,"./stripViewTemplate":278,"jquery":1}],278:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.STRIP_VIEW_TEMPLATE = void 0;

/* eslint-disable max-len */

/**
 * HTML element used for each `StripViewModel`
 *
 * @property STRIP_VIEW_TEMPLATE
 * @type {string|HTMLElement}
 * @final
 */
var STRIP_VIEW_TEMPLATE = '' + '<li class="stripViewItem">' + '   <table class="stripViewItem-table">' + '       <tbody>' + '           <tr class="stripView-table-tr">' + '               <td class="stripView-table-td js-stripView-callsign" title="Callsign"></td>' + '               <td class="stripView-table-td js-stripView-transponder" title="Transponder"></td>' + '               <td class="stripView-table-td js-stripView-departureAirportId" title="Departure Airport Identifier"></td>' + '               <td class="stripView-table-td js-stripView-flightPlan" title="Flight Plan Route" rowspan="2" colspan="2"></td>' + '           </tr>' + '           <tr class="stripView-table-tr">' + '               <td class="stripView-table-td js-stripView-aircraftModel" title="Aircraft Model"></td>' + '               <td class="stripView-table-td mix-stripView-table_borderTop js-stripView-assignedAltitude" title="Assigned Altitude"></td>' + '               <td class="stripView-table-td js-stripView-arrivalAirportId" title="Arrival Airport Identifier"></td>' + '           </tr>' + '           <tr class="stripView-table-tr">' + '               <td class="stripView-table-td">' + '                   <div class="u-float-right js-stripView-flightRules" title="IFR (I) or VFR (V)">I</div>' + '                   <div class="u-float-left js-stripView-cid" title="Computer Identification number"></div>' + '               </td>' + '               <td class="stripView-table-td mix-stripView-table_borderTop js-stripView-flightPlanAltitude" title="Flight Plan Altitude"></td>' + '               <td class="stripView-table-td js-stripView-alternateAirportId" title="Alternate Airport Identifier"></td>' + '               <td class="stripView-table-td js-stripView-remarks" title="Remarks"></td>' + '               <td class="stripView-table-td js-stripView-runway stripView-preplanning" title="Runway"></td>' + '           </tr>' + '       </tbody' + '   </table>' + '</li>';
exports.STRIP_VIEW_TEMPLATE = STRIP_VIEW_TEMPLATE;

},{}],279:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _find2 = _interopRequireDefault(require("lodash/find"));

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _BaseCollection2 = _interopRequireDefault(require("../base/BaseCollection"));

var _AirlineModel = _interopRequireDefault(require("./AirlineModel"));

var _airlineConstants = require("../constants/airlineConstants");

var _globalConstants = require("../constants/globalConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Houses an `AirlineModel` for each possible airline in the app.
 *
 * The contents of `_items` shouldn't ever need to change when an airport changes,
 * though this class does provide methods to reset each `AirlineModel`.
 *
 * @class AirlineCollection
 * @extends BaseCollection
 */
var AirlineCollection =
/*#__PURE__*/
function (_BaseCollection) {
  _inherits(AirlineCollection, _BaseCollection);

  /**
   * @constructor
   * @for AirlineCollection
   * @param airlineList {array}
   */

  /* istanbul ignore next */
  function AirlineCollection(airlineList) {
    var _this;

    _classCallCheck(this, AirlineCollection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AirlineCollection).call(this, airlineList));

    if (!(0, _isArray2["default"])(airlineList)) {
      // eslint-disable-next-line max-len
      throw new TypeError("Invalid parameter. AirlineCollection expected and array but found ".concat(_typeof(airlineList)));
    }

    _this.init(airlineList);

    return _this;
  }
  /**
   * List of all `activeFlightNumbers`
   *
   * Used when generating new flightNumbers to verify a new
   * number isn't already in use
   *
   * @property flightNumbers
   * @return {array<string>}
   */


  _createClass(AirlineCollection, [{
    key: "init",

    /**
     * Lifecycle method. Should be run only once on instantiation
     *
     * Initialize instance properties
     *
     * @for AirlineCollection
     * @method init
     * @param airlineList {array}
     */
    value: function init(airlineList) {
      var _this2 = this;

      (0, _forEach2["default"])(airlineList, function (airlineDefinition) {
        return _this2._buildAirlineModels(airlineDefinition);
      });
    }
    /**
     * Add and `AirlineModel` to the collection
     *
     * @for AirlineCollection
     * @method addItem
     * @param airlineToAdd {AirlineModel}
     */

  }, {
    key: "addItem",
    value: function addItem(airlineToAdd) {
      this._items.push(airlineToAdd);
    }
    /**
     * Find an `AirlineModel` by `id` (also referred to as `icao`).
     *
     * This method accepts airline ids in the shape of:
     * - `aal`
     * - `aal/long`
     *
     * Where a string following the '/' is assumed to be a specific fleet designation.
     * Though this method supports the `name/fleet` shape, the puropse of this method
     * is to find and `AirlineModel` object and not a list of aircraft from a fleet.
     * When a fleet name is encountered it is discarded.
     *
     * If you need to find a specific fleet from an airline, you can use the AirlineModel method:
     * `airlineModel._getRandomAircraftTypeFromFleet(fleetName)`
     *
     * @for AirlineCollection
     * @method findAirlineById
     * @param id {string}
     * @return {AirlineModel|undefined}
     */

  }, {
    key: "findAirlineById",
    value: function findAirlineById(id) {
      var airlineId = id.toLowerCase();

      if (airlineId.indexOf(_airlineConstants.AIRLINE_NAME_FLEET_SEPARATOR) !== _globalConstants.INVALID_INDEX) {
        // this should not get hit in most circumstances. The puropse of this method is to find
        // and `AirlineModel` object and not a list of aircraft from a fleet
        console.warn("Found a specific fleet with airline id ".concat(id, ". This method should be used to find an ") + 'AirlineModel instance and not a fleet within an AirlineModel. If you need to find a ' + 'specific fleet from an airline, you can use the AirlineModel method: ' + 'airlineModel._getRandomAircraftTypeFromFleet(fleetName)');
        airlineId = id.split(_airlineConstants.AIRLINE_NAME_FLEET_SEPARATOR)[0];
      }

      return (0, _find2["default"])(this._items, {
        icao: airlineId
      });
    }
    /**
     * Reset each `AirlineModel` within the collection
     *
     * Used when an airport change has occurred.
     *
     * @for AirlineCollection
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      (0, _forEach2["default"])(this._items, function (airlineModel) {
        airlineModel.reset();
      });
    }
    /**
     * Instantiate a new `AirlineModel` and add the new model to the collection
     *
     * @for airlineCollection
     * @method _buildAirlineModels
     * @param airlineDefinition {object}
     * @private
     */

  }, {
    key: "_buildAirlineModels",
    value: function _buildAirlineModels(airlineDefinition) {
      var airlineToAdd = new _AirlineModel["default"](airlineDefinition);
      this.addItem(airlineToAdd);
    }
  }, {
    key: "flightNumbers",
    get: function get() {
      var flightNumberList = (0, _map2["default"])(this._items, function (airline) {
        return airline.flightNumbers;
      });
      return (0, _flatten2["default"])(flightNumberList);
    }
  }]);

  return AirlineCollection;
}(_BaseCollection2["default"]);

exports["default"] = AirlineCollection;

},{"../base/BaseCollection":294,"../constants/airlineConstants":304,"../constants/globalConstants":310,"./AirlineModel":281,"lodash/find":191,"lodash/flatten":197,"lodash/forEach":199,"lodash/isArray":209,"lodash/map":231}],280:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _AirlineCollection = _interopRequireDefault(require("./AirlineCollection"));

var _AirlineModel = _interopRequireDefault(require("./AirlineModel"));

var _globalConstants = require("../constants/globalConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Controller for all things Airline
 *
 * @class AirlineController
 */
var AirlineController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @for AirlineController
   * @param airlineList {array<object>}
   */
  function AirlineController(airlineList) {
    _classCallCheck(this, AirlineController);

    /**
     * Instance of an `AirlineCollection`
     *
     * @property airlineCollection
     * @type {AirlineCollection}
     */
    this.airlineCollection = new _AirlineCollection["default"](airlineList);
  }
  /**
   * Convenience property that exposes a list of all `flightNumbers` currently in use
   *
   * Useful for determining if a freshly generated `flightNumber` is currently in use.
   *
   * @for AirlineController
   * @method flightNumbers
   * @return {array<string>}
   */


  _createClass(AirlineController, [{
    key: "findAirlineById",

    /**
     * Given an `airlineId` find and return an `AirlineModel`
     *
     * @for AirlineController
     * @method findAirlineById
     * @param airlineId {string}
     * @return {AirlineModel}
     */
    value: function findAirlineById(airlineId) {
      return this.airlineCollection.findAirlineById(airlineId);
    }
    /**
     * Generates a new `flightNumber` using the `flightNumberGeneration` rules of a given `AirlineModel`.
     *
     * This method provides a higher-level view of all the `flightNumbers` in use, and gurantees unique
     * `flightNumbers` across all airlines. Though not as realistic, having unique `flightNumbers` allows
     * for faster processing of aircraft commands by using only a `flightNumber` for a command.
     *
     * @for AirlineController
     * @method generateFlightNumberWithAirlineModel
     * @param airlineModel {AirlineModel}
     * @return flightNumber {string}
     */

  }, {
    key: "generateFlightNumberWithAirlineModel",
    value: function generateFlightNumberWithAirlineModel(airlineModel) {
      if (!(airlineModel instanceof _AirlineModel["default"])) {
        throw new TypeError('Invalid parameter. Expected airlineModel to be an instance of AirlineModel');
      }

      var flightNumber = airlineModel.generateFlightNumber();

      if (this._isActiveFlightNumber(flightNumber)) {
        // `flightNumber` already exists, recurse back through this method and generate a new flight number
        return this.generateFlightNumberWithAirlineModel(airlineModel);
      }

      airlineModel.addFlightNumberToInUse(flightNumber);
      return flightNumber;
    }
    /**
     * Remove a provided flightNumber from an airline's list of `activeFlightNumbers`
     *
     * Used when an aircraft leaves controlled airspace. Removing a flightNumber
     * from the list allows it to be used again by another aircraft
     *
     * @for AirlineCollection
     * @method removeFlightNumberFromList
     * @param airlineId {string}
     * @param flightNumber {string}
     */

  }, {
    key: "removeFlightNumberFromList",
    value: function removeFlightNumberFromList(airlineId, flightNumber) {
      var airlineModel = this.findAirlineById(airlineId);

      if ((0, _isNil2["default"])(airlineModel)) {
        throw new TypeError('Invalid airline passed to removeFlightNumberFromList, no AirlineModel found');
      }

      airlineModel.removeFlightNumber(flightNumber);
    }
    /**
     * Reset session specific instance properties
     *
     * Used when changing airports. Clears activeFlightNumbers and
     * any other properties specific to a current session at a
     * specific airport
     *
     * @for AirlineController
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this.airlineCollection.reset();
    }
    /**
     * Used to determine if a provided `flightNumber` is already in use
     *
     * @for AirlineController
     * @method _isActiveFlightNumber
     * @param flightNumber {string}
     * @returns {boolean}
     */

  }, {
    key: "_isActiveFlightNumber",
    value: function _isActiveFlightNumber(flightNumber) {
      return this.flightNumbers.indexOf(flightNumber) !== _globalConstants.INVALID_INDEX;
    }
  }, {
    key: "flightNumbers",
    get: function get() {
      return this.airlineCollection.flightNumbers;
    }
  }]);

  return AirlineController;
}();

exports["default"] = AirlineController;

},{"../constants/globalConstants":310,"./AirlineCollection":279,"./AirlineModel":281,"lodash/isNil":219}],281:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _get2 = _interopRequireDefault(require("lodash/get"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _head2 = _interopRequireDefault(require("lodash/head"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _random2 = _interopRequireDefault(require("lodash/random"));

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _without2 = _interopRequireDefault(require("lodash/without"));

var _BaseModel2 = _interopRequireDefault(require("../base/BaseModel"));

var _buildFlightNumber = require("./buildFlightNumber");

var _globalConstants = require("../constants/globalConstants");

var _validatorUtilities = require("../utilities/validatorUtilities");

var _airlineConstants = require("../constants/airlineConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * An aircraft operating agency
 *
 * Defines aircraft and fleets used by an airline along with methods
 * and rules for flightNumberGeneration.
 *
 * @class AirlineModel
 * @extends BaseModel
 */
var AirlineModel =
/*#__PURE__*/
function (_BaseModel) {
  _inherits(AirlineModel, _BaseModel);

  /**
   * @constructor
   * @for AirlineModel
   * @param airlineDefinition {object}
   */

  /* istanbul ignore next */
  function AirlineModel(airlineDefinition) {
    var _this;

    _classCallCheck(this, AirlineModel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AirlineModel).call(this));

    if ((0, _validatorUtilities.isEmptyObject)(airlineDefinition)) {
      // eslint-disable-next-line max-len
      throw new TypeError("Invalid airlineDefinition received by AirlineModel. Expected an object but received ".concat(_typeof(airlineDefinition)));
    }
    /**
     * ICAO airline designation
     *
     * @property icao
     * @type {string}
     */


    _this.icao = airlineDefinition.icao;
    /**
     * Agency name
     *
     * @property name
     * @type {string}
     */

    _this.name = (0, _get2["default"])(airlineDefinition, 'name', 'Default airline');
    /**
     * Radio callsign
     *
     * @property radioName
     * @type {string}
     * @default 'Default'
     */

    _this.radioName = 'Default';
    /**
     * Parameters for flight number generation
     *
     * @property flightNumberGeneration
     * @type {Object}
     */

    _this.flightNumberGeneration = {
      /**
       * Array of callsign formats
       *
       * @memberof flightNumberGeneration
       * @property callsignFormats
       * @type {Array}
       * @default ['###']
      */
      callsignFormats: [_airlineConstants.DEFAULT_CALLSIGN_FORMAT]
    };
    /**
     * Named weighted sets of aircraft
     *
     * @property fleets
     * @type {Object}
     */

    _this.fleets = {
      /**
       * @property default
       * @type {array}
       * @default []
       */
      "default": []
    };
    /**
     * List of all flight numbers in use in the app
     *
     * @property activeFlightNumbers
     * @type {array}
     * @default []
     */

    _this.activeFlightNumbers = [];

    _this.init(airlineDefinition);

    return _this;
  }
  /**
   * A unique list of all aircraft in all fleets belonging to this airline
   *
   * @property aircraftList
   * @return {array<string>}
   */


  _createClass(AirlineModel, [{
    key: "init",

    /**
     * Lifecycle method
     *
     * Should run only once on instantiation
     *
     * @for AirlineModel
     * @method init
     * @param airlineDefinition {object}
     */
    value: function init(airlineDefinition) {
      // TODO: these _get() lines are likely redundant and could be removed only after proper testing
      this.icao = (0, _get2["default"])(airlineDefinition, 'icao', this.icao).toLowerCase();
      this.radioName = (0, _get2["default"])(airlineDefinition, 'callsign.name', this.radioName);
      this.flightNumberGeneration.callsignFormats = (0, _get2["default"])(airlineDefinition, 'callsign.callsignFormats', this.flightNumberGeneration.callsignFormats); // eslint-disable-line max-len

      this.fleets = (0, _get2["default"])(airlineDefinition, 'fleets');

      this._transformFleetNamesToLowerCase();
    }
    /**
     * Remove a given flight number from the `activeFlightNumbers` list
     *
     * @for AirlineModel
     * @method removeFlightNumber
     * @param flightNumber {string}
     */

  }, {
    key: "removeFlightNumber",
    value: function removeFlightNumber(flightNumber) {
      this._deactivateFlightNumber(flightNumber);
    }
    /**
     * Resets the current list of `activeFlightNumbers`.
     *
     * This can be used when changing airports and all existing
     * aircraft are removed.
     *
     * @for AirlineModel
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this.activeFlightNumbers = [];
    }
    /**
     * @method getRandomAircraftType
     * @param fleet {string}
     * @return {string}
     */

  }, {
    key: "getRandomAircraftType",
    value: function getRandomAircraftType() {
      var fleet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

      if (fleet === '') {
        return this._getRandomAircraftTypeFromAllFleets();
      }

      return this._getRandomAircraftTypeFromFleet(fleet);
    } // TODO: the logic here can be simplified.

    /**
     * Creates a flight number/identifier
     *
     * This method should only be called from the `AircraftController` so the controller
     * can guarantee unique `flightNumbers` across all `AirlineModels`.
     *
     * @for AirlineModel
     * @method generateFlightNumber
     * @return flightNumber {string}
    */

  }, {
    key: "generateFlightNumber",
    value: function generateFlightNumber() {
      var flightNumber = (0, _buildFlightNumber.buildFlightNumber)(this.flightNumberGeneration.callsignFormats);
      return flightNumber;
    } // TODO: need better name

    /**
     * Add a given `flightNumber` to the `activeFlightNumbers` list.
     *
     * @for AirlineModel
     * @method addFlightNumberToInUse
     * @param flightNumber {string}
     */

  }, {
    key: "addFlightNumberToInUse",
    value: function addFlightNumberToInUse(flightNumber) {
      this.activeFlightNumbers.push(flightNumber);
    }
    /**
     * Returns a random aircraft type from any fleet that belongs to this airline
     *
     * Used when a new aircraft spwans with a defined airline, but no defined aircraft type
     *
     * @for AirlineCollection
     * @method _getRandomAircraftTypeFromAllFleets
     * @return {AirlineModel}
     */

  }, {
    key: "_getRandomAircraftTypeFromAllFleets",
    value: function _getRandomAircraftTypeFromAllFleets() {
      var index = (0, _random2["default"])(0, this.aircraftList.length - 1);
      return this.aircraftList[index];
    } // TODO: this returns a random, and not weighted, result

    /**
     * Return a random aircraft type from within a specific fleet
     *
     * @for AirlineModel
     * @method _getRandomAircraftTypeFromFleet
     * @param fleetName {string}
     * @return {string}
     */

  }, {
    key: "_getRandomAircraftTypeFromFleet",
    value: function _getRandomAircraftTypeFromFleet(fleetName) {
      // if we want to be uber defensive here we would lowercase the `fleetName` param
      if (!this._hasFleet(fleetName)) {
        // eslint-disable-next-line max-len
        throw new Error("Invalid fleetName passed to AirlineModel. ".concat(fleetName, " is not a fleet defined in ").concat(this.icao));
      }

      var fleet = this.fleets[fleetName];
      var index = (0, _random2["default"])(0, fleet.length - 1); // entries in `fleets[fleetName]` are of the shape `[TYPE, WEIGHT]` we only need the type here

      return (0, _head2["default"])(fleet[index]);
    }
    /**
     * Remove flight number from `activeFlightNumbers` list allowing
     * it to be reused by another aircraft some time in the future
     *
     * @for AirlineModel
     * @method _deactivateFlightNumber
     * @param flightNumber {string}
     */

  }, {
    key: "_deactivateFlightNumber",
    value: function _deactivateFlightNumber(flightNumber) {
      if (!this._isActiveFlightNumber(flightNumber)) {
        // TODO: check that the number is there first
        // throw or console.error?
        return;
      }

      this.activeFlightNumbers = (0, _without2["default"])(this.activeFlightNumbers, flightNumber);
    }
    /**
     * Boolean abstraction used to determine if a fleetName is present within
     * this instances `fleets` object.
     *
     * @for AirlineModel
     * @method _hasFleet
     * @param fleetName {string}
     * @return {boolean}
     */

  }, {
    key: "_hasFleet",
    value: function _hasFleet(fleetName) {
      return (0, _has2["default"])(this.fleets, fleetName);
    }
    /**
     *
     *
     * @for AirlineModel
     * @method _isActiveFlightNumber
     * @param flightNumber {string}
     * @return {boolean}
     */

  }, {
    key: "_isActiveFlightNumber",
    value: function _isActiveFlightNumber(flightNumber) {
      return this.activeFlightNumbers.indexOf(flightNumber) !== _globalConstants.INVALID_INDEX;
    }
    /**
     * Loop through each aircraft in each fleet defined in the airline and make sure it
     * is defined in lowercase to ease string matching
     *
     * @for AirlineCollection
     * @method _transformFleetNamesToLowerCase
     * @private
     */

  }, {
    key: "_transformFleetNamesToLowerCase",
    value: function _transformFleetNamesToLowerCase() {
      (0, _forEach2["default"])(this.fleets, function (fleet) {
        (0, _forEach2["default"])(fleet, function (aircraftInFleet) {
          var NAME_INDEX = 0;
          aircraftInFleet[NAME_INDEX] = aircraftInFleet[NAME_INDEX].toLowerCase();
        });
      });
    }
  }, {
    key: "aircraftList",
    get: function get() {
      var aircraft = [];
      (0, _forEach2["default"])(this.fleets, function (fleet) {
        var fleetAircraft = (0, _map2["default"])(fleet, function (aircraft) {
          return (0, _head2["default"])(aircraft);
        });
        aircraft.push.apply(aircraft, _toConsumableArray(fleetAircraft));
      });
      return (0, _uniq2["default"])(aircraft);
    }
    /**
     * List of all `activeFlightNumbers` by this airline
     *
     * Used when generating new `flightNumbers` to verify a new
     * number isn't already in use
     *
     * @property flightNumbers
     * @return {array<string>}
     */

  }, {
    key: "flightNumbers",
    get: function get() {
      return this.activeFlightNumbers;
    }
  }]);

  return AirlineModel;
}(_BaseModel2["default"]);

exports["default"] = AirlineModel;

},{"../base/BaseModel":295,"../constants/airlineConstants":304,"../constants/globalConstants":310,"../utilities/validatorUtilities":392,"./buildFlightNumber":283,"lodash/forEach":199,"lodash/get":200,"lodash/has":201,"lodash/head":203,"lodash/map":231,"lodash/random":237,"lodash/uniq":249,"lodash/without":252}],282:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.airlineNameAndFleetHelper = airlineNameAndFleetHelper;
exports.randomAirlineSelectionHelper = randomAirlineSelectionHelper;

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _toLower2 = _interopRequireDefault(require("lodash/toLower"));

var _airlineConstants = require("../constants/airlineConstants");

var _generalUtilities = require("../utilities/generalUtilities");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// TODO: this file needs to be renamed to something more generalized.

/**
 * Enemeration of an index value of `0`
 *
 * @property FIRST_INDEX
 * @type {number}
 * @final
 */
var FIRST_INDEX = 0;
/**
 * Enemeration of an index value of `1`
 *
 * @property SECOND_INDEX
 * @type {number}
 * @final
 */

var SECOND_INDEX = 1;
/**
 * Accepts a selected airline name, which may or may not contain the `AIRLINE_NAME_FLEET_SEPARATOR`, and
 * returns the `airlineNameAndFleet` object with updated property values.
 *
 * @function _extractNameAndFleetFromCurrentAirline
 * @param selectedAirline {string}
 * @param airlineNameAndFleet {object}
 * @return airlineNameAndFleet {object}
 */

function _extractNameAndFleetFromCurrentAirline(selectedAirline, airlineNameAndFleet) {
  airlineNameAndFleet.name = (0, _toLower2["default"])(selectedAirline);

  if (selectedAirline.indexOf(_airlineConstants.AIRLINE_NAME_FLEET_SEPARATOR) > -1) {
    var nameAndFleet = selectedAirline.split(_airlineConstants.AIRLINE_NAME_FLEET_SEPARATOR);
    airlineNameAndFleet.name = (0, _toLower2["default"])(nameAndFleet[FIRST_INDEX]);
    airlineNameAndFleet.fleet = nameAndFleet[SECOND_INDEX];
  }

  return airlineNameAndFleet;
} // TODO: this method should be able to handle a string value as a parameter

/**
 * Accepts an airline, as defined in an airport json file from the `departures` and `arrivals` sections,
 * and returns a consistent object containing an airline name and fleet classification.
 *
 * example input:
 * ```
 * - 'aal'
 * - 'ual/long'
 * - 'aal/90long'
 * ```
 *
 * @function airlineNameAndFleetHelper
 * @param airline {array<string>}
 * @return airlineNameAndFleet {object}
 */


function airlineNameAndFleetHelper(airline) {
  if (!(0, _isArray2["default"])(airline)) {
    throw new TypeError("Invalid parameter. Expected airline to be an array ' +\n            'but instead received ".concat(_typeof(airline)));
  } // this could be a model object, but the values used here are temporary so we just use a constant
  // and update its key values as needed.


  var airlineNameAndFleet = {
    name: '',
    fleet: 'default'
  };

  if (airline.length === 0) {
    return airlineNameAndFleet;
  } // we're being sneaky here. the `airlineNameAndFleet` object is created within this function. It then
  // gets sent off to the next function to be modified.


  return _extractNameAndFleetFromCurrentAirline(airline[FIRST_INDEX], airlineNameAndFleet);
} // @deprecated

/**
 * Accepts a list of airlines, as defined in an airport json file from the `departures` and `arrivals` sections,
 * and returns a consistent object containing an airline name and fleet classification.
 *
 * @function randomAirlineSelectionHelper
 * @param airlineList {array}
 * @return {object}
 */


function randomAirlineSelectionHelper(airlineList) {
  // TODO: a large portion of this function is duplicated above, refactor
  if (!(0, _isArray2["default"])(airlineList)) {
    throw new TypeError("Invalid parameter. Expected airlineList to be an array ' +\n            'but instead received ".concat(_typeof(airlineList)));
  } // this could be a model object, but the values used here are temporary so we just use a constant
  // and update its key values as needed.


  var airlineNameAndFleet = {
    name: '',
    fleet: ''
  };

  if (airlineList.length === 0) {
    return airlineNameAndFleet;
  }

  var selectedAirline = (0, _generalUtilities.choose_weight)(airlineList);
  return _extractNameAndFleetFromCurrentAirline(selectedAirline, airlineNameAndFleet);
}

},{"../constants/airlineConstants":304,"../utilities/generalUtilities":387,"lodash/isArray":209,"lodash/toLower":246}],283:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildFlightNumber = buildFlightNumber;

var _generalUtilities = require("../utilities/generalUtilities");

var _airlineConstants = require("../constants/airlineConstants");

var ALPHA = 'abcdefghijklmnopqrstuvwxyz';
var NUMERIC = '0123456789';
var defaultCallsignFormats = [_airlineConstants.DEFAULT_CALLSIGN_FORMAT];
/**
 * This picks a random number. If it is the first value within the callsign (ie. i === 0), then it picks a
 * number between 1 and 9. Otherwise, it picks a number between 0 and 9.
 *
 * @function _generateRandomDigit
 * @param i {number}
 * @return NUMERIC {string}
*/

function _generateRandomDigit(i) {
  if (i === 0) {
    return (0, _generalUtilities.choose)(NUMERIC.substr(1));
  }

  return (0, _generalUtilities.choose)(NUMERIC);
}
/**
 * This function picks a random letter and returns it.
 *
 * @function _generateRandomLetter
 * @return ALPHA {string}
*/


function _generateRandomLetter() {
  return (0, _generalUtilities.choose)(ALPHA);
}
/**
 * This function takes a list of callsignFormats, validates them (ie. ensures that no callsignFormat has a leading 0)
 * then returns a list of validated callsignFormats or the default callsignFormat if there are no valid callsignFormats
 *
 * @function _validateCallsignFormats
 * @param callsignFormat {array<string>}
 * @return validatedFormats {array<string>}
*/


function _validateCallsignFormats(callsignFormats) {
  var validatedFormats = [];

  for (var i = 0; i < callsignFormats.length; i++) {
    if (callsignFormats[i].charAt(0) === '0') {
      console.warn("Format ".concat(callsignFormats[i], " is invalid as it has a leading zero!"));
      continue;
    }

    validatedFormats.push(callsignFormats[i]);
  }

  if (validatedFormats.length === 0) {
    return defaultCallsignFormats;
  }

  return validatedFormats;
}
/**
 * Accepts a list of callsign formats, which are defined in the airline files. It randomly selects one of these
 * formats and generates a callsign based off this format.
 *
 * @function buildFlightNumber
 * @param callsignFormats {array<string>}
 * @return {string}
*/


function buildFlightNumber(callsignFormats) {
  var flightNumber = '';

  var validatedFormats = _validateCallsignFormats(callsignFormats);

  var chosenFormat = (0, _generalUtilities.choose)(validatedFormats);

  for (var i = 0; i < chosenFormat.length; i++) {
    switch (chosenFormat[i]) {
      case _airlineConstants.CALLSIGN_RANDOM_DIGIT_CHARACTER:
        flightNumber += _generateRandomDigit(i);
        break;

      case _airlineConstants.CALLSIGN_RANDOM_LETTER_CHARACTER:
        flightNumber += _generateRandomLetter();
        break;

      default:
        flightNumber += chosenFormat[i];
    }
  }

  return flightNumber;
}

},{"../constants/airlineConstants":304,"../utilities/generalUtilities":387}],284:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _has2 = _interopRequireDefault(require("lodash/has"));

var _AirportModel = _interopRequireDefault(require("./AirportModel"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _eventNames = require("../constants/eventNames");

var _storageKeys = require("../constants/storageKeys");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Responsible for maintaining references to all the available airports
 *
 * @class AirportController
 */
var AirportController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   */
  function AirportController() {
    _classCallCheck(this, AirportController);

    /**
     * @property _eventBus
     * @type {EventBus}
     */
    this._eventBus = _EventBus["default"];
    /**
     * Local reference to `window.AIRPORT_LOAD_LIST`
     *
     * This is defined in `assets/airports/airportLoadList.js`
     * This property is the only way the possible list of airports
     * makes its way into the app.
     *
     * @property _airportListToLoad
     * @type {Array<object>}
     * @default []
     */

    this._airportListToLoad = [];
    /**
     * Dictionary of available airports
     *
     * @property airports
     * @type {Object<string, AirportModel>}
     * @default {}
     */

    this.airports = {};
    /**
     * The current airport
     *
     * This is a mutable property that will change based on
     * the currently selected airport
     *
     * @property current
     * @type {AirportModel}
     * @default null
     */

    this.current = null;
  }
  /**
   * Lifecycle method. Should run only once on App initialiazation
   *
   * Load each airport in the `airportLoadList`
   *
   * @for AirportController
   * @method init
   * @param InitialAirportIcao {string}
   * @param initialAirportData {object}
   * @param airportLoadList {array<object>}  List of airports to load
   */


  _createClass(AirportController, [{
    key: "init",
    value: function init(initialAirportIcao, initialAirportData, airportLoadList) {
      this._airportListToLoad = airportLoadList;

      for (var i = 0; i < this._airportListToLoad.length; i++) {
        var airport = this._airportListToLoad[i];
        this.airport_load(airport);
      }

      this.airport_set(initialAirportIcao, initialAirportData);
    }
    /**
     * Create a new `AirportModel` flyweight
     *
     * This will create a minimal `AirportModel` with just enough data to
     * create a valid instance. When switching airports, this model will
     * be filled in with the rest of the airport data if it does
     * not exist already
     *
     * @for AirportController
     * @method airport_load
     * @param icao {string}
     * @param level {string}
     * @param name {string}
     */

  }, {
    key: "airport_load",
    value: function airport_load(_ref) {
      var icao = _ref.icao,
          level = _ref.level,
          name = _ref.name;
      icao = icao.toLowerCase();

      if (this.hasAirport(icao)) {
        console.log("".concat(icao, ": already loaded"));
        return null;
      }

      var airportModel = new _AirportModel["default"]({
        icao: icao,
        level: level,
        name: name
      });
      this.airport_add(airportModel);
    }
    /**
     * Add an airport config to the `#airports` dictionary
     *
     * @for AirportController
     * @method airport_add
     * @param airport {object}
     */

  }, {
    key: "airport_add",
    value: function airport_add(airport) {
      this.airports[airport.icao] = airport;
    }
    /**
     * Reset the instance
     *
     * Placeholder method, currently not in use
     *
     * @for AircraftController
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this._eventBus = _EventBus["default"];
      this._airportListToLoad = [];
      this.airports = {};
      this.current = null;
    }
    /**
     * Set a given `icao` as the `#current` airport
     *
     * @for AirportController
     * @method airport_set
     * @param icao {string}
     * @param airportJson {object} [default=null]
     */

  }, {
    key: "airport_set",
    value: function airport_set(icao) {
      var airportJson = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.hasStoredIcao(icao)) {
        icao = localStorage[_storageKeys.STORAGE_KEY.ATC_LAST_AIRPORT];
      }

      icao = icao.toLowerCase();

      if (!this.airports[icao]) {
        console.warn("".concat(icao, ": no such airport"));
        return;
      }

      var nextAirportModel = this.airports[icao];
      this.current = nextAirportModel; // if loaded is true, we wont need to load any data thus the call to `onAirportChange` within the
      // success callback will never fire so we do that here.

      if (nextAirportModel.loaded) {
        this._eventBus.trigger(_eventNames.EVENT.AIRPORT_CHANGE, nextAirportModel.data);
      }

      nextAirportModel.set(airportJson);
    }
    /**
     * @for AirportController
     * @method getAiracCycle
     * @property airac
     * @return {number}
    */

  }, {
    key: "getAiracCycle",
    value: function getAiracCycle() {
      return this.current.airac;
    }
    /**
     * Retrieve a specific `AirportModel` instance
     *
     * @for AirportController
     * @method airport_get
     * @param icao {string}
     * @return {AirportModel}
     */

  }, {
    key: "airport_get",
    value: function airport_get(icao) {
      if (!icao) {
        return this.current;
      }

      return this.airports[icao.toLowerCase()];
    }
    /**
     * Return the name of the `arrivalRunwayModel`.
     *
     * This should be used only in the `SpawnPatternModel` when determining initial
     * heading for arrival aircraft. We only need the name so we can properly select
     * an exit segment of a STAR.
     *
     * Sometimes route definitions do not contain enough waypoints in the entry and body
     * segments. This gives us a way to guess the runway and grab an exit segment.
     *
     * @for AirportController
     * @method getInitialArrivalRunwayName
     * @return {string}
     */

  }, {
    key: "getInitialArrivalRunwayName",
    value: function getInitialArrivalRunwayName() {
      return this.current.arrivalRunwayModel.name;
    }
    /**
     * Boolean helper used to determine if a given `icao` exists within `localStorage`
     *
     * @for AirportController
     * @method hasStoredIcao
     * @param icao {string}
     * @return {boolean}
     */

  }, {
    key: "hasStoredIcao",
    value: function hasStoredIcao(icao) {
      return !icao && (0, _has2["default"])(localStorage, _storageKeys.STORAGE_KEY.ATC_LAST_AIRPORT);
    }
    /**
     * Boolean helper used to determine if a given `icao` exists within `#airports`
     *
     * @for AirportController
     * @method hasAirport
     * @param icao {string}
     * @return {boolean}
     */

  }, {
    key: "hasAirport",
    value: function hasAirport(icao) {
      return (0, _has2["default"])(this.airports, icao);
    }
    /**
     * Remove an aircraft from the queue of any `AirportModel` `RunwayModel`(s)
     *
     * @for AirportModel
     * @method removeAircraftFromAllRunwayQueues
     * @param  aircraft {AircraftModel}
     */

  }, {
    key: "removeAircraftFromAllRunwayQueues",
    value: function removeAircraftFromAllRunwayQueues(aircraft) {
      this.current.removeAircraftFromAllRunwayQueues(aircraft.id);
    }
  }]);

  return AirportController;
}();

var _default = new AirportController();

exports["default"] = _default;

},{"../constants/eventNames":308,"../constants/storageKeys":318,"../lib/EventBus":346,"./AirportModel":285,"lodash/has":201}],285:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _ceil2 = _interopRequireDefault(require("lodash/ceil"));

var _chunk2 = _interopRequireDefault(require("lodash/chunk"));

var _clamp2 = _interopRequireDefault(require("lodash/clamp"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _AirportController = _interopRequireDefault(require("./AirportController"));

var _AirspaceModel = _interopRequireDefault(require("./AirspaceModel"));

var _DynamicPositionModel = _interopRequireDefault(require("../base/DynamicPositionModel"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _GameController = _interopRequireDefault(require("../game/GameController"));

var _MapCollection = _interopRequireDefault(require("./MapCollection"));

var _RunwayCollection = _interopRequireDefault(require("./runway/RunwayCollection"));

var _StaticPositionModel = _interopRequireDefault(require("../base/StaticPositionModel"));

var _TimeKeeper = _interopRequireDefault(require("../engine/TimeKeeper"));

var _positionModelHelpers = require("../base/positionModelHelpers");

var _unitConverters = require("../utilities/unitConverters");

var _core = require("../math/core");

var _vector = require("../math/vector");

var _aircraftConstants = require("../constants/aircraftConstants");

var _environmentConstants = require("../constants/environmentConstants");

var _eventNames = require("../constants/eventNames");

var _storageKeys = require("../constants/storageKeys");

var _distance = require("../math/distance");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEFAULT_CTR_RADIUS_KM = 80;
var DEFAULT_CTR_CEILING_FT = 10000;
var DEFAULT_INITIAL_ALTITUDE_FT = 5000;
var DEFAULT_RANGE_RINGS = {
  enabled: false,
  radius_nm: 0,
  center: [0, 0]
};
/**
 * @class AirportModel
 */

var AirportModel =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param options {object}
   */
  // istanbul ignore next
  function AirportModel() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AirportModel);

    _defineProperty(this, "onLoadAirportSuccess", function (response) {
      // cache of airport.json data to be used to hydrate other classes on airport change
      _this.data = response;
      _this.loading = false;
      _this.loaded = true;

      _this.init(response);

      _this.eventBus.trigger(_eventNames.EVENT.AIRPORT_CHANGE, _this.data);

      _this.set();
    });

    _defineProperty(this, "onLoadAirportError", function (_ref) {
      var textStatus = _ref.textStatus;
      console.error("Unable to load airport/".concat(_this.icao, ": ").concat(textStatus));
      _this.loading = false;

      _AirportController["default"].current.set();
    });

    /**
     * @property EventBus
     * @type {EventBus}
     */
    this.eventBus = _EventBus["default"];
    /**
     * cache of airport json data
     *
     * used externally when changing airports
     *
     * @property data
     * @type {object}
     * @default {}
     */

    this.data = {};
    /**
     * @property arrivalRunwayModel
     * @type {RunwayModel}
     * @default null
     */

    this.arrivalRunwayModel = null;
    /**
     * @property departureRunwayModel
     * @type {RunwayModel}
     * @default null
     */

    this.departureRunwayModel = null;
    /**
     * Flag for is an airport has been loaded successfully
     *
     * @property loaded
     * @type {boolean}
     * @default false
     */

    this.loaded = false;
    /**
     * Flag for if an airport is in the process of loading
     *
     * @property loading
     * @type {boolean}
     * @default false
     */

    this.loading = false;
    /**
     * Name of the airport
     *
     * @property name
     * @type {string}
     * @default null
     */

    this.name = null;
    /**
     * ICAO identifier of the airport
     *
     * @property icao
     * @type {string}
     * @default null
     */

    this.icao = null;
    /**
     * AIRAC cycle from which data for the airport was taken
     *
     * @property airac
     * @type {number}
     * @default null
    */

    this.airac = null;
    /**
     * @property radio
     * @type
     * @default null
     */

    this.radio = null;
    /**
     * @property level
     * @type
     * @default null
     */

    this.level = null;
    /**
     * @property _positionModel
     * @type {StaticPositionModel}
     * @default null
     */

    this._positionModel = null;
    /**
     * Collection of all airport `RunwayModel` objects
     *
     * @property _runwayCollection
     * @type {RunwayCollection}
     * @default null
     */

    this._runwayCollection = null;
    /**
     * Collection of all `MapModel`s available to be displayed on the scope
     *
     * @property mapCollection
     * @type {MapCollection}
     * @default null
     */

    this.mapCollection = null;
    /**
     * @property restricted_areas
     * @type {array}
     * @default []
     */

    this.restricted_areas = [];
    /**
     * areas under this sector's control. If null, draws circle with diameter of 'ctr_radius'
     *
     * @property airspace
     * @type {object}
     * @default null
     */

    this.airspace = null; // TODO: this should really be its own class possibly separate from the `AirportModel`

    /**
     * Container for airport terrain definition
     *
     * @property terrain
     * @type {object}
     * @default {}
     */

    this.terrain = {};
    /**
     * @property timeout
     * @type {object}
     */

    this.timeout = {
      runway: null,
      departure: null
    };
    /**
     * default wind settings for an airport
     *
     * @property wind
     * @type {object}
     */

    this.wind = {
      speed: 10,
      angle: 0
    };
    /**
     * @for AirportModel
     * @property ctr_radius
     * @type {nunmber}
     */

    this.ctr_radius = null;
    /**
     * @for AirportModel
     * @property ctr_ceiling
     * @type {nunmber}
     */

    this.ctr_ceiling = null;
    /**
     * @for AirportModel
     * @property initial_alt
     * @type {nunmber}
     */

    this.initial_alt = null;
    /**
     * @for AirportModel
     * @property rangeRings
     * @type {object}
     */

    this.rangeRings = null;
    this.init(options);
  }
  /**
   * @property elevation
   * @return {number}
   */


  _createClass(AirportModel, [{
    key: "init",

    /**
     * @for AirportModel
     * @method init
     * @param data {object}
     */
    value: function init(data) {
      this.name = (0, _get2["default"])(data, 'name', this.name);
      this.icao = (0, _get2["default"])(data, 'icao', this.icao).toLowerCase();
      this.level = (0, _get2["default"])(data, 'level', this.level); // exit early if `position` doesn't exist in data. on app initialiazation, we loop through every airport
      // in the `airportLoadList` and instantiate a model for each but wont have the full data set until the
      // airport json file is loaded.

      if (!data.position) {
        return;
      }

      this.setCurrentPosition(data.position, (0, _unitConverters.degreesToRadians)(data.magnetic_north));
      this.airac = (0, _get2["default"])(data, 'airac', this.airac);
      this.radio = (0, _get2["default"])(data, 'radio', this.radio);
      this.has_terrain = (0, _get2["default"])(data, 'has_terrain', false);
      this.ctr_radius = (0, _get2["default"])(data, 'ctr_radius', DEFAULT_CTR_RADIUS_KM);
      this.ctr_ceiling = (0, _get2["default"])(data, 'ctr_ceiling', DEFAULT_CTR_CEILING_FT);
      this.initial_alt = (0, _get2["default"])(data, 'initial_alt', DEFAULT_INITIAL_ALTITUDE_FT);
      this._runwayCollection = new _RunwayCollection["default"](data.runways, this._positionModel);
      this.mapCollection = new _MapCollection["default"](data.maps, data.defaultMaps, this.positionModel, this.magneticNorth);

      this._initRangeRings(data.rangeRings);

      this.loadTerrain();
      this.buildAirspace(data.airspace);
      this.setActiveRunwaysFromNames(data.arrivalRunway, data.departureRunway);
      this.buildRestrictedAreas(data.restricted);
      this.updateCurrentWind(data.wind);
    }
    /**
     * Initialize the range ring position model
     *
     * @for AirportModel
     * @method _initRangeRings
     * @param {object} rangeRingData
     * @private
     */

  }, {
    key: "_initRangeRings",
    value: function _initRangeRings(rangeRingData) {
      if (!rangeRingData) {
        this.rangeRings = DEFAULT_RANGE_RINGS;
      }

      this.rangeRings = {
        enabled: rangeRingData.enabled,
        center: new _DynamicPositionModel["default"](rangeRingData.center, this.positionModel, this.magneticNorth),
        radius_nm: rangeRingData.radius_nm
      };
    }
    /**
     * @for AirportModel
     * @method setCurrentPosition
     * @param gpsCoordinates {array<number>}  [latitude, longitude]
     * @param magneticNorth {number}          magnetic declination (variation), in radians
     */

  }, {
    key: "setCurrentPosition",
    value: function setCurrentPosition(gpsCoordinates, magneticNorth) {
      if (!(0, _positionModelHelpers.isValidGpsCoordinatePair)(gpsCoordinates)) {
        return;
      }

      this._positionModel = new _StaticPositionModel["default"](gpsCoordinates, null, magneticNorth);
    }
    /**
     * create 3d polygonal airspace
     *
     * @for AirportModel
     * @method buildAirspace
     * @param airspace
     */

  }, {
    key: "buildAirspace",
    value: function buildAirspace(airspace) {
      var _this2 = this;

      if (!airspace) {
        return;
      } // for each area


      this.airspace = (0, _map2["default"])(airspace, function (airspaceSection) {
        return new _AirspaceModel["default"](airspaceSection, _this2._positionModel, _this2._positionModel.magneticNorth);
      });
      this.ctr_radius = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.airspace[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var airspaceModel = _step.value;
          this.ctr_radius = Math.max.apply(Math, [this.ctr_radius].concat(_toConsumableArray((0, _map2["default"])(airspaceModel.poly, function (vertexPosition) {
            return (0, _vector.vlen)((0, _vector.vsub)(vertexPosition.relativePosition, _this2.rangeRings.center.relativePosition));
          }))));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * @for AirportModel
     * @method buildRestrictedAreas
     * @param restrictedAreas
     */

  }, {
    key: "buildRestrictedAreas",
    value: function buildRestrictedAreas(restrictedAreas) {
      var _this3 = this;

      if (!restrictedAreas) {
        return;
      }

      (0, _forEach2["default"])(restrictedAreas, function (area) {
        // TODO: find a better name for `obj`
        var obj = {};

        if (area.name) {
          obj.name = area.name;
        }

        obj.height = (0, _unitConverters.parseElevation)(area.height);
        obj.coordinates = (0, _map2["default"])(area.coordinates, function (v) {
          return _DynamicPositionModel["default"].calculateRelativePosition(v, _this3._positionModel, _this3.magneticNorth);
        });
        var coords_max = obj.coordinates[0];
        var coords_min = obj.coordinates[0];
        (0, _forEach2["default"])(obj.coordinates, function (v) {
          coords_max = [Math.max(v[0], coords_max[0]), Math.max(v[1], coords_max[1])];
          coords_min = [Math.min(v[0], coords_min[0]), Math.min(v[1], coords_min[1])];
        });
        obj.center = (0, _vector.vscale)((0, _vector.vadd)(coords_max, coords_min), 0.5);

        _this3.restricted_areas.push(obj);
      });
    }
    /**
     * Return an altitude clamped within the min/max assignable altitudes for this airport
     *
     * @for AirportModel
     * @method clampWithinAssignableAltitudes
     * @param altitude
     * @return {number}
     */

  }, {
    key: "clampWithinAssignableAltitudes",
    value: function clampWithinAssignableAltitudes(altitude) {
      return (0, _clamp2["default"])(altitude, this.minAssignableAltitude, this.maxAssignableAltitude);
    }
    /**
     * @for AirportModel
     * @method updateCurrentWind
     * @param currentWind
     */

  }, {
    key: "updateCurrentWind",
    value: function updateCurrentWind(currentWind) {
      if (!currentWind) {
        return;
      }

      this.wind.speed = currentWind.speed;
      this.wind.angle = (0, _unitConverters.degreesToRadians)(currentWind.angle);
    }
    /**
     * @for AirportModel
     * @method set
     * @param airportJson {object}
     */

  }, {
    key: "set",
    value: function set(airportJson) {
      if (!this.loaded) {
        this.load(airportJson);
        return;
      }

      localStorage[_storageKeys.STORAGE_KEY.ATC_LAST_AIRPORT] = this.icao; // TODO: this should live elsewhere and be called by a higher level controller

      _GameController["default"].game_reset_score_and_events();

      this.start = _TimeKeeper["default"].accumulatedDeltaTime;
      this.eventBus.trigger(_eventNames.EVENT.PAUSE_UPDATE_LOOP, true);
    }
    /**
     * Get the wind at the specified altitude.
     * When the altitude is not specified, the airport's surface wind is given.
     *
     * @for AirportModel
     * @method getWindAtAltitude
     * @param {number} altitude
     * @returns {object<angle, speed>}
     */

  }, {
    key: "getWindAtAltitude",
    value: function getWindAtAltitude() {
      var altitude = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.elevation;
      var windTravelSpeedAtSurface = this.wind.speed;
      var altitudeAboveSurface = altitude - this.elevation;
      var windIncreaseFactor = altitudeAboveSurface * _environmentConstants.ENVIRONMENT.WIND_INCREASE_FACTOR_PER_FT;
      var windTravelSpeedAtAltitude = windTravelSpeedAtSurface * (1 + windIncreaseFactor);
      var wind = {
        angle: this.wind.angle,
        speed: windTravelSpeedAtAltitude
      };
      return wind;
    }
    /**
     * @for AirportModel
     * @method getWindForRunway
     * @param runway {runwayModel}
     * @return {object} headwind and crosswind
     */

  }, {
    key: "getWindForRunway",
    value: function getWindForRunway(runway) {
      var crosswindAngle = runway.calculateCrosswindAngleForRunway(this.wind.angle);
      return {
        cross: (0, _core.sin)(crosswindAngle) * this.wind.speed,
        head: (0, _core.cos)(crosswindAngle) * this.wind.speed
      };
    }
    /**
     * Generates a vector representation of the wind at a given altitude.
     * When the altitude is not specified, the airport elevation is used as the assumed altitude.
     *
     * @for AirportModel
     * @method getWindVectorAtAltitude
     * @param {number} altitude
     * @returns {array<number, number>}
     */

  }, {
    key: "getWindVectorAtAltitude",
    value: function getWindVectorAtAltitude(altitude) {
      var _this$getWindAtAltitu = this.getWindAtAltitude(altitude),
          angle = _this$getWindAtAltitu.angle,
          speed = _this$getWindAtAltitu.speed;

      var windTravelDirection = angle + Math.PI;
      var windVector = (0, _vector.vscale)((0, _vector.vectorize2dFromRadians)(windTravelDirection), speed);
      return windVector;
    }
    /**
     * Set active arrival/departure runways from the runway names
     *
     * @for AirportModel
     * @method setActiveRunwaysFromNames
     * @param arrivalRunwayName {string}
     * @param departureRunwayName {string}
     */

  }, {
    key: "setActiveRunwaysFromNames",
    value: function setActiveRunwaysFromNames(arrivalRunwayName, departureRunwayName) {
      var arrivalRunwayModel = this.getRunway(arrivalRunwayName);
      var departureRunwayModel = this.getRunway(departureRunwayName);
      this.setArrivalRunway(arrivalRunwayModel);
      this.setDepartureRunway(departureRunwayModel);
    }
    /**
     * Set the airport's active arrival runway
     *
     * @for AirportModel
     * @method setArrivalRunway
     * @param runwayModel {RunwayModel}
     */

  }, {
    key: "setArrivalRunway",
    value: function setArrivalRunway(runwayModel) {
      this.arrivalRunwayModel = runwayModel;
    }
    /**
     * Set the airport's active departure runway
     *
     * @for AirportModel
     * @method setDepartureRunway
     * @param runwayModel {RunwayModel}
     */

  }, {
    key: "setDepartureRunway",
    value: function setDepartureRunway(runwayModel) {
      this.departureRunwayModel = runwayModel;
    }
    /**
     * Get RunwayModel in use for 'arrival' or 'departure', as specified in call
     *
     * @for AirportModel
     * @method getActiveRunwayForCategory
     * @param category {string} whether the arrival or departure runway is being queried
     * @return {RunwayModel}
     */

  }, {
    key: "getActiveRunwayForCategory",
    value: function getActiveRunwayForCategory(category) {
      if (category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL) {
        return this.arrivalRunwayModel;
      }

      if (category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
        return this.departureRunwayModel;
      }

      if (category === _aircraftConstants.FLIGHT_CATEGORY.OVERFLIGHT) {
        return;
      }

      console.warn('Did not expect a query for runway that applies to aircraft of category ' + "'".concat(category, "'! Returning the arrival runway (").concat(this.arrivalRunwayModel.name, ")"));
      return this.arrivalRunwayModel;
    }
    /**
     * Return a `RunwayRelationshipModel` given two runway names
     *
     * @for AirportModel
     * @method getRunwayRelationshipForRunwayNames
     * @param  primaryRunwayName {string}
     * @param  comparatorRunwayName {string}
     * @return {RunwayRelationshipModel|undefined}
     */

  }, {
    key: "getRunwayRelationshipForRunwayNames",
    value: function getRunwayRelationshipForRunwayNames(primaryRunwayName, comparatorRunwayName) {
      return this._runwayCollection.getRunwayRelationshipForRunwayNames(primaryRunwayName, comparatorRunwayName);
    } // TODO: Implement changing winds, then bring this method back to life

    /**
     * @for AirportModel
     * @method updateRunway
     */

  }, {
    key: "updateRunway",
    value: function updateRunway() {} // const bestRunwayForWind = this._runwayCollection.findBestRunwayForWind(this.getWind);
    //
    // this.setArrivalRunway(bestRunwayForWind);
    // this.setDepartureRunway(bestRunwayForWind);
    // TODO: leaving this here for when we implement variable winds
    // /**
    //  * @for AirportModel
    //  * @method setRunwayTimeout
    //  */
    // setRunwayTimeout() {
    //     this.timeout.runway = GameController.game_timeout(this.updateRunway, Math.random() * 30, this);
    // }

    /**
     * Return a `RunwayModel` for the provided name
     *
     * @for AirportModel
     * @method getRunway
     * @param name {string} name of the runway, eg '28R'
     * @return {RunwayModel|null}
     */

  }, {
    key: "getRunway",
    value: function getRunway(name) {
      return this._runwayCollection.findRunwayModelByName(name);
    }
    /**
     * Remove an aircraft from all runway queues
     *
     * @for AirportModel
     * @method removeAircraftFromAllRunwayQueues
     * @param  aircraft {AircraftModel}
     */

  }, {
    key: "removeAircraftFromAllRunwayQueues",
    value: function removeAircraftFromAllRunwayQueues(aircraftId) {
      return this._runwayCollection.removeAircraftFromAllRunwayQueues(aircraftId);
    }
    /**
     * @for AirportModel
     * @method parseTerrain
     * @param  data {object}
     */

  }, {
    key: "parseTerrain",
    value: function parseTerrain(data) {
      var GEOMETRY_TYPE = {
        LINE_STRING: 'LineString',
        POLYGON: 'Polygon'
      }; // reassigning `this` to maintain correct scope wen working in multiple nested `_forEach()` and `_map()` loops

      var apt = this;
      apt.terrain = {};
      (0, _forEach2["default"])(data.features, function (f) {
        // const f = data.features[i];
        // m => ft, rounded to 1K (but not divided)
        var ele = (0, _core.round)(f.properties.elevation / 0.3048, 1000);

        if (!apt.terrain[ele]) {
          apt.terrain[ele] = [];
        }

        var multipoly = f.geometry.coordinates;

        if (f.geometry.type === GEOMETRY_TYPE.LINE_STRING) {
          multipoly = [[multipoly]];
        }

        if (f.geometry.type === GEOMETRY_TYPE.POLYGON) {
          multipoly = [multipoly];
        }

        (0, _forEach2["default"])(multipoly, function (poly) {
          // multipoly contains several polys
          // each poly has 1st outer ring and other rings are holes
          var terrainAtElevation = (0, _map2["default"])(poly, function (line_string) {
            return (0, _map2["default"])(line_string, function (point) {
              // `StaticPositionModel` requires [lat,lon] order
              var latLongPoint = point.slice().reverse();
              var pos = new _StaticPositionModel["default"](latLongPoint, apt.positionModel, apt.magneticNorth);
              return pos.relativePosition;
            });
          });
          apt.terrain[ele].push(terrainAtElevation);
        });
      });
    }
    /**
     * @for AirportModel
     * @method loadTerrain
     */

  }, {
    key: "loadTerrain",
    value: function loadTerrain() {
      var _this4 = this;

      if (!this.has_terrain) {
        return;
      } // eslint-disable-next-line no-undef


      zlsa.atc.loadAsset({
        url: "assets/airports/terrain/".concat(this.icao.toLowerCase(), ".geojson"),
        immediate: true
      }).done(function (data) {
        // TODO: change to onSuccess and onError handler abstractions
        try {
          // eslint-disable-next-line no-undef
          _this4.parseTerrain(data);
        } catch (e) {
          throw new Error(e.message);
        }
      }).fail(function (jqXHR, textStatus, errorThrown) {
        console.error("Unable to load airport/terrain/".concat(_this4.icao, ": ").concat(textStatus));
        _this4.loading = false;

        _AirportController["default"].current.set();
      });
    }
    /**
     * Stop the game loop and Load airport json asyncronously
     *
     * @for AirportModel
     * @method load
     * @param airportJson {object}
     */

  }, {
    key: "load",
    value: function load() {
      var _this5 = this;

      var airportJson = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (this.loaded) {
        return;
      }

      this.loading = true;
      this.eventBus.trigger(_eventNames.EVENT.PAUSE_UPDATE_LOOP, false);

      if (airportJson && airportJson.icao.toLowerCase() === this.icao) {
        this.onLoadIntialAirportFromJson(airportJson);
        return;
      } // eslint-disable-next-line no-undef


      zlsa.atc.loadAsset({
        url: "assets/airports/".concat(this.icao.toLowerCase(), ".json"),
        immediate: true
      }).done(function (response) {
        return _this5.onLoadAirportSuccess(response);
      }).fail(function () {
        return _this5.onLoadAirportError.apply(_this5, arguments);
      });
    }
    /**
     * @method onLoadAirportSuccess
     * @param response {object}
     */

  }, {
    key: "onLoadIntialAirportFromJson",

    /**
     * Provides a way to get data into the instance with passed in
     * data and without running `.load()`
     *
     * Data received here is identical to data that would be received
     * when changing airports.
     *
     * @for AirportModel
     * @method onLoadIntialAirportFromJson
     * @param response {object}
     */
    value: function onLoadIntialAirportFromJson(response) {
      // TODO: this is extremely similar to `onLoadAirportSuccess()`, consolidate these two methods
      // cache of airport.json data to be used to hydrate other classes on airport change
      this.data = response;
      this.loading = false;
      this.loaded = true;
      this.init(response);
      this.set();
    }
    /**
     * Returns whether or not the provided point (at the specified altitude) is within any
     * airspace area belonging to this airport
     *
     * @for AirportModel
     * @function isPointWithinAirspace
     * @param point {array} x,y
     * @param altitude {number}
     * @return {boolean}
     */

  }, {
    key: "isPointWithinAirspace",
    value: function isPointWithinAirspace(point, altitude) {
      for (var i = 0; i < this.airspace.length; i++) {
        var airspace = this.airspace[i];

        if (airspace.isPointInside(point, altitude)) {
          return true;
        }
      }

      return false;
    }
    /**
     *
     * @for AirportModel
     * @function distance2d
     * @param point {array} x,y
     * @return {number} distance in km
     */

  }, {
    key: "distance2d",
    value: function distance2d(point) {
      return (0, _distance.distance2d)(point, this.relativePosition);
    }
  }, {
    key: "elevation",
    get: function get() {
      return this._positionModel.elevation;
    }
    /**
     * Provide read-only public access to this._positionModel
     *
     * @for SpawnPatternModel
     * @property position
     * @type {StaticPositionModel}
     */

  }, {
    key: "positionModel",
    get: function get() {
      return this._positionModel;
    }
    /**
     * Fascade to access relative position
     *
     * @for AirportModel
     * @property relativePosition
     * @type {array<number>} [kilometersNorth, kilometersEast]
     */

  }, {
    key: "relativePosition",
    get: function get() {
      return this._positionModel.relativePosition;
    }
    /**
     * Fascade to access the airport's position's magnetic declination value
     *
     * @for AirportModel
     * @property magneticNorth
     * @return {number}
     */

  }, {
    key: "magneticNorth",
    get: function get() {
      return this._positionModel.magneticNorth;
    }
    /**
     * Minimum altitude an aircraft can be assigned to.
     *
     * @property minAssignableAltitude
     * @return {number}
     */

  }, {
    key: "minAssignableAltitude",
    get: function get() {
      return (0, _ceil2["default"])(this.elevation + 1000, -2);
    }
    /**
     * This will return an array of two-value arrays containing a `RunwayModel`
     * for each end of a runway.
     *
     * This should only be used by the `CanvasController` for drawing runways.
     * This returns data in this shape in an effort to maintain a previous api.
     *
     * @property runways
     * @return {array<array<RunwayModel>>}
     */

  }, {
    key: "runways",
    get: function get() {
      return (0, _chunk2["default"])(this._runwayCollection.runways, 2);
    }
    /**
     * Minimum descent altitude of an instrument approach
     *
     * This is 200 feet AGL but every airport is at a different elevation
     * This provides easy access to the correct value from within an aircraft
     *
     * @property minDescentAltitude
     * @return {number}
     */

  }, {
    key: "minDescentAltitude",
    get: function get() {
      return Math.floor(this.elevation + _aircraftConstants.PERFORMANCE.INSTRUMENT_APPROACH_MINIMUM_DESCENT_ALTITUDE);
    }
    /**
     * Maximum altitude an aircraft can be assigned to.
     *
     * @property maxAssignableAltitude
     * @return {number}
     */

  }, {
    key: "maxAssignableAltitude",
    get: function get() {
      return this.ctr_ceiling;
    }
  }]);

  return AirportModel;
}();

exports["default"] = AirportModel;

},{"../base/DynamicPositionModel":296,"../base/StaticPositionModel":297,"../base/positionModelHelpers":298,"../constants/aircraftConstants":303,"../constants/environmentConstants":307,"../constants/eventNames":308,"../constants/storageKeys":318,"../engine/TimeKeeper":338,"../game/GameController":339,"../lib/EventBus":346,"../math/core":349,"../math/distance":350,"../math/vector":352,"../utilities/unitConverters":391,"./AirportController":284,"./AirspaceModel":286,"./MapCollection":287,"./runway/RunwayCollection":289,"lodash/ceil":179,"lodash/chunk":180,"lodash/clamp":181,"lodash/forEach":199,"lodash/get":200,"lodash/map":231}],286:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _BaseModel2 = _interopRequireDefault(require("../base/BaseModel"));

var _StaticPositionModel = _interopRequireDefault(require("../base/StaticPositionModel"));

var _globalConstants = require("../constants/globalConstants");

var _unitConverters = require("../utilities/unitConverters");

var _vector = require("../math/vector");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * An enclosed region defined by a series of Position objects and an altitude range
 *
 * @class AirspaceModel
 */
var AirspaceModel =
/*#__PURE__*/
function (_BaseModel) {
  _inherits(AirspaceModel, _BaseModel);

  /**
   * @for AirspaceModel
   * @constructor
   * @param data {object}
   * @param airportPosition {StaticPositionModel}
   * @param magneticNorth {number}
   */
  function AirspaceModel(data, airportPosition, magneticNorth) {
    var _this;

    _classCallCheck(this, AirspaceModel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AirspaceModel).call(this));

    if (!data || !airportPosition || !(0, _isNumber2["default"])(magneticNorth)) {
      // eslint-disable-next-line max-len
      throw new TypeError('Invalid parameter, expected airspace, airportPosition and magneticNorth to be defined');
    }
    /**
     * List of lat/long coordinates that outline the shape of the area
     *
     * DO NOT repeat the origin to 'close' the shape, this happens programatically
     *
     * @for AirspaceModel
     * @property poly
     * @type {array}
     * @default []
     */


    _this.poly = [];
    /**
     * A transformed version of this.poly
     *
     * @for AirspaceModel
     * @property relativePoly
     * @type {array}
     * @default []
     */

    _this.relativePoly = [];
    /**
     * Altitude at bottom of area, in hundreds of feet
     *
     * @for AirspaceModel
     * @property floor
     * @type {number}
     * @default INVALID_NUMBER
     */

    _this.floor = _globalConstants.INVALID_NUMBER;
    /**
     * Altitude of top of area, in hundreds of feet
     *
     * @for AirspaceModel
     * @property ceiling
     * @type {number}
     * @default INVALID_NUMBER
     */

    _this.ceiling = _globalConstants.INVALID_NUMBER;
    /**
     * FAA airspace classification (A,B,C,D,E,G)
     *
     * @for AirspaceModel
     * @property airspace_class
     * @type {string}
     * @default ''
     */

    _this.airspace_class = '';
    /**
     * Position of the label of the airspace on the screen
     *
     * @for AirspaceModel
     * @property labelPositions
     * @type {object} x,y in km
     * @default null
     */

    _this.labelPositions = [];
    return _possibleConstructorReturn(_this, _this._init(data, airportPosition, magneticNorth));
  }
  /**
   * Initialize the model
   *
   * @for AirspaceModel
   * @method _init
   * @param data {array}
   * @param airportPosition {StaticPositionModel}
   * @param magneticNorth {number}
   * @chainable
   * @private
   */


  _createClass(AirspaceModel, [{
    key: "_init",
    value: function _init(data, airportPosition, magneticNorth) {
      this.floor = (0, _unitConverters.convertToThousands)(data.floor);
      this.ceiling = (0, _unitConverters.convertToThousands)(data.ceiling);
      this.airspace_class = data.airspace_class;
      this.poly = (0, _vector.buildPolyPositionModels)(data.poly, airportPosition, magneticNorth);
      this.relativePoly = (0, _map2["default"])(this.poly, function (v) {
        return v.relativePosition;
      });

      this._initLabelPositions(data, airportPosition, magneticNorth);

      return this;
    }
  }, {
    key: "_initLabelPositions",
    value: function _initLabelPositions(data, airportPosition, magneticNorth) {
      if (!data.labelPositions) {
        this.labelPositions = [this._calculateLabelPosition()];
        return;
      }

      this.labelPositions = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data.labelPositions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var position = _step.value;
          var labelPositionModel = new _StaticPositionModel["default"](position, airportPosition, magneticNorth);
          this.labelPositions.push(labelPositionModel.relativePosition);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * Calculates the center of the airspace
     *
     * @for _calculateLabelPosition
     * @method _calculateLabelPosition
     * @returns {object} {x,y} coordinates in km
     * @private
     */

  }, {
    key: "_calculateLabelPosition",
    value: function _calculateLabelPosition() {
      var _this$relativePoly$ = _slicedToArray(this.relativePoly[0], 2),
          minX = _this$relativePoly$[0],
          minY = _this$relativePoly$[1];

      var _this$relativePoly$2 = _slicedToArray(this.relativePoly[0], 2),
          maxX = _this$relativePoly$2[0],
          maxY = _this$relativePoly$2[1]; // iterate through all points in the polygon to find the extreme X/Y coordinates


      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.relativePoly[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var point = _step2.value;
          minX = Math.min(minX, point[0]);
          maxX = Math.max(maxX, point[0]);
          minY = Math.min(minY, point[1]);
          maxY = Math.max(maxY, point[1]);
        } // calculate the center point as the middle of the extremes

      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return [(minX + maxX) / 2, (minY + maxY) / 2];
    }
    /**
     * @for AirspaceModel
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this.poly = [];
      this.floor = _globalConstants.INVALID_NUMBER;
      this.ceiling = _globalConstants.INVALID_NUMBER;
      this.airspace_class = '';
    }
    /**
     * Checks if a point (2D position and altitude) is within this airspace
     *
     * @for AirspaceModel
     * @method isPointInside
     * @param point {array} x,y
     * @param altitude {number}
     * @return {boolean}
     */

  }, {
    key: "isPointInside",
    value: function isPointInside(point, altitude) {
      if (!this.isPointInside2D(point)) {
        return false;
      }

      return this.floor <= altitude && altitude <= this.ceiling;
    }
    /**
     * Checks if a 2D point is within the 2D projection of the airspace
     *
     * @for AirspaceModel
     * @method isPointInside
     * @param point {array} x,y
     * @return {boolean}
     */

  }, {
    key: "isPointInside2D",
    value: function isPointInside2D(point) {
      return (0, _vector.point_in_poly)(point, this.relativePoly);
    }
    /**
     * calculates the distance to the airspace in nm
     *
     * @for AirspaceModel
     * @method distanceToBoundary
     * @param point {array} x,y
     * @return {number} in nm
     */

  }, {
    key: "distanceToBoundary",
    value: function distanceToBoundary(point) {
      return (0, _unitConverters.nm)((0, _vector.distance_to_poly)(point, this.relativePoly));
    }
  }]);

  return AirspaceModel;
}(_BaseModel2["default"]);

exports["default"] = AirspaceModel;

},{"../base/BaseModel":295,"../base/StaticPositionModel":297,"../constants/globalConstants":310,"../math/vector":352,"../utilities/unitConverters":391,"lodash/isNumber":220,"lodash/map":231}],287:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _MapModel = _interopRequireDefault(require("./MapModel"));

var _BaseCollection2 = _interopRequireDefault(require("../base/BaseCollection"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Collection of `MapModel`s available to be displayed on the scope
 *
 * Provides methods to create `MapModel`s, used by `AirportModel`
 * and to extract video map line data to be rendered by the
 * `CanvasController`
 *
 * @class MapCollection
 * @extends BaseCollection
 */
var MapCollection =
/*#__PURE__*/
function (_BaseCollection) {
  _inherits(MapCollection, _BaseCollection);

  /**
   * @constructor
   * @param mapJson {object}
   * @param defaultMaps {array<string>}
   * @param airportPositionModel {StaticPositionModel}
   * @param magneticNorth {number}
   */
  function MapCollection(mapJson, defaultMaps, airportPositionModel, magneticNorth) {
    var _this;

    _classCallCheck(this, MapCollection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MapCollection).call(this));

    if (!(0, _isArray2["default"])(mapJson)) {
      throw new TypeError("Invalid mapJson parameter passed to MapCollection. Expected an array but found ".concat(_typeof(mapJson)));
    } else if (!(0, _isArray2["default"])(defaultMaps)) {
      throw new TypeError("Invalid defaultMaps parameter passed to MapCollection. Expected an array but found ".concat(_typeof(defaultMaps)));
    } else if (defaultMaps.length === 0) {
      throw new TypeError('Invalid defaultMaps parameter passed to MapCollection. Expected an array with at least one element');
    } else if (mapJson.length === 0) {
      throw new TypeError('Invalid mapJson parameter passed to MapCollection. Expected an array with at least one element');
    }
    /**
     * @inherited
     * @memberof BaseCollection
     * @property _items
     * @type {array<MapModel>}
     * @default []
     */

    /**
     * @inherited
     * @memberof BaseCollection
     * @property length
     * @type {number}
     * @default #_items.length
     */


    _this._init(mapJson, defaultMaps, airportPositionModel, magneticNorth);

    return _this;
  }
  /**
   * A flag indicating whether the `MapCollection` has any visible maps.
   *
   * @for MapCollection
   * @property hasVisibleMaps
   * @return {boolean}
   */


  _createClass(MapCollection, [{
    key: "_init",
    // ------------------------------ LIFECYCLE ------------------------------

    /**
     * Initialize the instance
     *
     * @for MapCollection
     * @method _init
     * @param mapJson {object}
     * @param defaultMaps {array<string>}
     * @param airportPositionModel {StaticPositionModel}
     * @param magneticNorth {number}
     */
    value: function _init(mapJson, defaultMaps, airportPositionModel, magneticNorth) {
      this._items = this._buildMapModels(mapJson, defaultMaps, airportPositionModel, magneticNorth);
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * A list of all the map lines for the visible maps in the `MapCollection`
     *
     * @for MapCollection
     * @method getVisibleMapLines
     * @return {array<object>}
     */

  }, {
    key: "getVisibleMapLines",
    value: function getVisibleMapLines() {
      return this._items.reduce(function (sum, map) {
        if (map.isHidden) {
          return sum;
        }

        return [].concat(_toConsumableArray(map.lines), _toConsumableArray(sum));
      }, []);
    }
    /**
     * A list of names of all the visible maps in the `MapCollection`
     *
     * @for MapCollection
     * @method getVisibleMapNames
     * @return {array<object>}
     */

  }, {
    key: "getVisibleMapNames",
    value: function getVisibleMapNames() {
      return this._items.reduce(function (sum, map) {
        if (map.isHidden) {
          return sum;
        }

        return [].concat(_toConsumableArray(sum), [map.name]);
      }, []);
    }
    /**
     * A list of all the `MapModel` names in the `MapCollection`
     *
     * @for MapCollection
     * @method getMapNames
     * @returns {array<string>}
     */

  }, {
    key: "getMapNames",
    value: function getMapNames() {
      return this._items.map(function (map) {
        return map.name;
      });
    }
    /**
     * Sets which maps should be rendered on the `CanvasController`
     *
     * @for MapCollection
     * @method setVisibleMaps
     * @param names {array<string>}
     */

  }, {
    key: "setVisibleMaps",
    value: function setVisibleMaps(names) {
      this._items.forEach(function (map) {
        map.isHidden = !names.includes(map.name);
      });
    } // ------------------------------ PRIVATE ------------------------------

    /**
     * @for MapCollection
     * @method _buildMapModels
     * @param mapJson {object}
     * @param defaultMaps {array<string>}
     * @param airportPositionModel {StaticPositionModel}
     * @param magneticNorth {number}
     * @returns {array<MapModel>}
     */

  }, {
    key: "_buildMapModels",
    value: function _buildMapModels(mapJson, defaultMaps, airportPositionModel, magneticNorth) {
      return mapJson.map(function (item) {
        var map = new _MapModel["default"](item, airportPositionModel, magneticNorth);
        map.isHidden = !defaultMaps.includes(map.name);
        return map;
      });
    }
  }, {
    key: "hasVisibleMaps",
    get: function get() {
      return this._items.some(function (map) {
        return !map.isHidden;
      });
    }
    /**
     * Public fascade for `#_items`
     *
     * @for MapCollection
     * @property maps
     * @return {array<MapModel>}
     */

  }, {
    key: "maps",
    get: function get() {
      return this._items;
    }
  }]);

  return MapCollection;
}(_BaseCollection2["default"]);

exports["default"] = MapCollection;

},{"../base/BaseCollection":294,"./MapModel":288,"lodash/isArray":209}],288:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _BaseModel2 = _interopRequireDefault(require("../base/BaseModel"));

var _DynamicPositionModel = _interopRequireDefault(require("../base/DynamicPositionModel"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * A video map item, containing a collection of map lines
 *
 * Defines a vide omap layer referenced by an `AirportModel` that
 * contains the map lines to be drawn by the `CanvasController`,
 * as well as a name describing the map contents and a flag
 * allowing rendering of the layer to be suppressed.
 *
 * @class MapModel
 */
var MapModel =
/*#__PURE__*/
function (_BaseModel) {
  _inherits(MapModel, _BaseModel);

  /**
   * @for MapModel
   * @constructor
   * @param map {object}
   * @param airportPosition {StaticPositionModel}
   * @param magneticNorth {number}
   */
  function MapModel(map, airportPosition, magneticNorth) {
    var _this;

    _classCallCheck(this, MapModel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MapModel).call(this));

    if (!map || !airportPosition || !(0, _isNumber2["default"])(magneticNorth)) {
      throw new TypeError('Invalid parameter, expected map, airportPosition and magneticNorth to be defined');
    } else if (!(0, _isArray2["default"])(map.lines) || map.lines.length === 0) {
      throw new TypeError('Invalid parameter, map.lines must be an array with at least one element');
    } else if (!(0, _isString2["default"])(map.name)) {
      throw new TypeError("Invalid parameter, map.name must be a string, but found ".concat(_typeof(map.name)));
    }
    /**
     * A flag indicating whether the layer should be hidden
     *
     * @for MapModel
     * @property isHidden
     * @type {boolean}
     * @default false
     */


    _this.isHidden = false;
    /**
     * List of lat/long coordinates pairs that define a line
     *
     * @for MapModel
     * @property lines
     * @type {array}
     * @default []
     */

    _this.lines = [];
    /**
     * Name of the map layer.
     *
     * @for MapModel
     * @property name
     * @type {string}
     * @default ''
     */

    _this.name = '';
    return _possibleConstructorReturn(_this, _this._init(map, airportPosition, magneticNorth));
  } // ------------------------------ LIFECYCLE ------------------------------

  /**
   * Initialize the model
   *
   * @for MapModel
   * @method _init
   * @param map {object}
   * @param airportPosition {StaticPositionModel}
   * @param magneticNorth {number}
   * @private
   */


  _createClass(MapModel, [{
    key: "_init",
    value: function _init(map, airportPosition, magneticNorth) {
      this.isHidden = map.isHidden === true;
      this.name = map.name;

      this._buildMapLines(map.lines, airportPosition, magneticNorth);

      return this;
    }
    /**
     * @for MapModel
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this.isHidden = false;
      this.lines = [];
      this.name = '';
    } // ------------------------------ PUBLIC ------------------------------
    // ------------------------------ PRIVATE ------------------------------

    /**
     * Create the array of map lines
     *
     * @for MapModel
     * @method _buildMapLines
     * @param map {object}
     * @param airportPosition {StaticPositionModel}
     * @param magneticNorth {number}
     * @private
     */

  }, {
    key: "_buildMapLines",
    value: function _buildMapLines(lines, airportPosition, magneticNorth) {
      this.lines = lines.map(function (line) {
        var airportPositionAndDeclination = [airportPosition, magneticNorth];
        var lineStartCoordinates = [line[0], line[1]];
        var lineEndCoordinates = [line[2], line[3]];

        var startPosition = _DynamicPositionModel["default"].calculateRelativePosition.apply(_DynamicPositionModel["default"], [lineStartCoordinates].concat(airportPositionAndDeclination));

        var endPosition = _DynamicPositionModel["default"].calculateRelativePosition.apply(_DynamicPositionModel["default"], [lineEndCoordinates].concat(airportPositionAndDeclination));

        return [].concat(_toConsumableArray(startPosition), _toConsumableArray(endPosition));
      });
    }
  }]);

  return MapModel;
}(_BaseModel2["default"]);

exports["default"] = MapModel;

},{"../base/BaseModel":295,"../base/DynamicPositionModel":296,"lodash/isArray":209,"lodash/isNumber":220,"lodash/isString":224}],289:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _find2 = _interopRequireDefault(require("lodash/find"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _BaseCollection2 = _interopRequireDefault(require("../../base/BaseCollection"));

var _RunwayModel = _interopRequireDefault(require("./RunwayModel"));

var _RunwayRelationshipModel = _interopRequireDefault(require("./RunwayRelationshipModel"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Collection of `RunwayModel`s
 *
 * Provides methods to reason about the various `RunwayModel`s belonging to an airport
 *
 * @class RunwayCollection
 * @extends BaseCollection
 */
var RunwayCollection =
/*#__PURE__*/
function (_BaseCollection) {
  _inherits(RunwayCollection, _BaseCollection);

  /**
   * @constructor
   * @param runwayJson {array<object>}
   * @param airportPositionModel {StaticPositionModel}
   */
  function RunwayCollection(runwayJson, airportPositionModel) {
    var _this;

    _classCallCheck(this, RunwayCollection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RunwayCollection).call(this));

    if (!(0, _isArray2["default"])(runwayJson)) {
      throw new TypeError("Invalid parameter passed to RunwayCollection. Expected an array but found ".concat(_typeof(runwayJson)));
    }
    /**
     * @inherited
     * @memberof BaseCollection
     * @property _items
     * @type {array<RunwayModel>}
     * @default []
     */

    /**
     * @inherited
     * @memberof BaseCollection
     * @property length
     * @type {number}
     * @default #_items.length
     */

    /**
     * @property _airportPositionModel
     * @type {StaticPositionModel}
     * @default null
     * @private
     */


    _this._airportPositionModel = null;
    /**
     * Dictionary of all airport runways, organized by runway name, that
     * contains a `RunwayRelationshipModel` for each runway
     *
     * @property _runwayRelationships
     * @type object
     * @default {}
     * @private
     */

    _this._runwayRelationships = {};

    _this._init(runwayJson, airportPositionModel);

    return _this;
  }
  /**
   * Public fascade for `#_items`
   *
   * @property runways
   * @return {array<RunwayModel>}
   */


  _createClass(RunwayCollection, [{
    key: "_init",

    /**
     * Initialize the instance
     *
     * @for RunwayCollection
     * @method _init
     * @param runwayJson {array<object>}
     * @param airportPositionModel {StaticPositionModel}
     */
    value: function _init(runwayJson, airportPositionModel) {
      this._airportPositionModel = airportPositionModel;

      this._buildRunwayModels(runwayJson);

      this._buildRunwayRelationships();
    }
    /**
     * Tear down the instance and destroy any instance property values
     *
     * @for RunwayCollection
     * @method destroy
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._airportPositionModel = null;
      this._runwayRelationships = {};
    }
    /**
     * Based on the current wind, find the most appropriate runway for use
     *
     * Used to find a default runway
     *
     * @for findBestRunwayForWind
     * @method findBestRunwayForWind
     * @param getCurrentWindProps {function<object>}
     * @return bestRunway {string}
     */

  }, {
    key: "findBestRunwayForWind",
    value: function findBestRunwayForWind(getCurrentWindProps) {
      var bestRunway = '';
      var bestRunwayHeadwind = -Infinity;
      var headwind = {};
      var wind = getCurrentWindProps();

      for (var i = 0; i < this._items.length; i++) {
        var runway = this._items[i];
        headwind[runway.name] = Math.cos(runway.angle - wind.angle) * wind.speed;
      }

      for (var _runway in headwind) {
        if (headwind[_runway] > bestRunwayHeadwind) {
          bestRunway = _runway;
          bestRunwayHeadwind = headwind[_runway];
        }
      }

      return bestRunway;
    }
    /**
     * Loop through all the `RunwayModel`s in the collection and
     * call the `.removeAircraftFromQueue()` method on each.
     *
     * This is a catchall method used for cleanup
     *
     * This method is overkill and can likely be removed in
     * the near future
     *
     * @for RunwayCollection
     * @method removeAircraftFromAllRunwayQueues
     */

  }, {
    key: "removeAircraftFromAllRunwayQueues",
    value: function removeAircraftFromAllRunwayQueues(aircraftId) {
      for (var i = 0; i < this.length; i++) {
        var runwayModel = this._items[i];
        runwayModel.removeAircraftFromQueue(aircraftId);
      }
    }
    /**
     * @for RunwayCollection
     * @method findRunwayModelByName
     * @param
     * @return {RunwayModel|null}
     */

  }, {
    key: "findRunwayModelByName",
    value: function findRunwayModelByName() {
      var runwayName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return (0, _find2["default"])(this._items, {
        name: runwayName.toUpperCase()
      }) || null;
    }
    /**
     * @for RunwayCollection
     * @method getRunwayRelationshipForRunwayNames
     * @param  primaryRunwayName {string}
     * @param  comparatorRunwayName {string}
     * @return {boolean}
     */

  }, {
    key: "getRunwayRelationshipForRunwayNames",
    value: function getRunwayRelationshipForRunwayNames(primaryRunwayName, comparatorRunwayName) {
      return this._runwayRelationships[primaryRunwayName.toUpperCase()][comparatorRunwayName.toUpperCase()];
    }
    /**
     * Given two runway names, find if the runways are parallel
     *
     * @for RunwayCollection
     * @method areRunwaysParallel
     * @param  primaryRunwayName {string}
     * @param  comparatorRunwayName {string}
     * @return {boolean}
     */

  }, {
    key: "areRunwaysParallel",
    value: function areRunwaysParallel(primaryRunwayName, comparatorRunwayName) {
      var runwayRelationship = this.getRunwayRelationshipForRunwayNames(primaryRunwayName, comparatorRunwayName);
      return runwayRelationship.parallel;
    }
    /**
     * @for RunwayCollection
     * @method _buildRunwayModels
     * @param runwayJson {array<object>}
     */

  }, {
    key: "_buildRunwayModels",
    value: function _buildRunwayModels(runwayJson) {
      var _this2 = this;

      (0, _forEach2["default"])(runwayJson, function (runway) {
        _this2._addRunwayToCollection(new _RunwayModel["default"](runway, 0, _this2._airportPositionModel));

        _this2._addRunwayToCollection(new _RunwayModel["default"](runway, 1, _this2._airportPositionModel));
      });
    }
    /**
     * @for RunwayCollection
     * @method _addRunwayToCollection
     * @param runwayModel {RunwayModel}
     */

  }, {
    key: "_addRunwayToCollection",
    value: function _addRunwayToCollection(runwayModel) {
      this._items.push(runwayModel);
    }
    /**
     * Build the `#_runwayRelationships` dictionary
     *
     * This method mutates `#_runwayRelationships`
     *
     * @for RunwayCollection
     * @method _buildRunwayRelationships
     */

  }, {
    key: "_buildRunwayRelationships",
    value: function _buildRunwayRelationships() {
      for (var i = 0; i < this.length; i++) {
        var primaryRunway = this._items[i]; // create subobject with primaryRunway name as the key

        this._runwayRelationships[primaryRunway.name] = {};

        this._buildRunwayRelationshipsForRunway(primaryRunway);
      }
    }
    /**
     * Create a `RunwayRelationshipModel` for each `runwayModel`.
     *
     * This method mutates `#_runwayRelationships`
     *
     * @method _buildRunwayRelationshipsForRunway
     * @param runwayModel {runwayModel}
     */

  }, {
    key: "_buildRunwayRelationshipsForRunway",
    value: function _buildRunwayRelationshipsForRunway(runwayModel) {
      for (var i = 0; i < this.length; i++) {
        var comparatorRunway = this._items[i];

        if (runwayModel.name !== comparatorRunway.name) {
          this._runwayRelationships[runwayModel.name][comparatorRunway.name] = new _RunwayRelationshipModel["default"](runwayModel, comparatorRunway);
        }
      }
    }
  }, {
    key: "runways",
    get: function get() {
      return this._items;
    }
  }]);

  return RunwayCollection;
}(_BaseCollection2["default"]);

exports["default"] = RunwayCollection;

},{"../../base/BaseCollection":294,"./RunwayModel":290,"./RunwayRelationshipModel":291,"lodash/find":191,"lodash/forEach":199,"lodash/isArray":209}],290:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _ceil2 = _interopRequireDefault(require("lodash/ceil"));

var _without2 = _interopRequireDefault(require("lodash/without"));

var _BaseModel2 = _interopRequireDefault(require("../../base/BaseModel"));

var _StaticPositionModel = _interopRequireDefault(require("../../base/StaticPositionModel"));

var _aircraftConstants = require("../../constants/aircraftConstants");

var _airportConstants = require("../../constants/airportConstants");

var _globalConstants = require("../../constants/globalConstants");

var _circle = require("../../math/circle");

var _core = require("../../math/core");

var _flightMath = require("../../math/flightMath");

var _radioUtilities = require("../../utilities/radioUtilities");

var _unitConverters = require("../../utilities/unitConverters");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Describes a single runway at an airport
 *
 * @class RunwayModel
 * @extends BaseModel
 */
var RunwayModel =
/*#__PURE__*/
function (_BaseModel) {
  _inherits(RunwayModel, _BaseModel);

  /**
   * @for RunwayModel
   * @constructor
   * @param options {object}
   * @param end {number}
   * @param airportPositionModel {StaticPositionModel}
   */
  // istanbul ignore next
  function RunwayModel() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var end = arguments.length > 1 ? arguments[1] : undefined;
    var airportPositionModel = arguments.length > 2 ? arguments[2] : undefined;

    _classCallCheck(this, RunwayModel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RunwayModel).call(this));
    /**
     * @property airportPositionModel
     * @type {StaticPositionModel|null}
     * @default null
     */

    _this.airportPositionModel = null;
    /**
     * @property _positionModel
     * @type {StaticPositionModel|null}
     * @default null
     * @private
     */

    _this._positionModel = null;
    /**
     * Name of the runway
     *
     * @property name
     * @type {string}
     * @default ''
     */

    _this.name = '';
    /**
     * Runway magnetic heading (from landing end to liftoff end), in radians
     *
     * @property angle
     * @type {number}
     * @default null
     */

    _this.angle = -999;
    /**
     * @property delay
     * @type {number}
     * @default 2
     */

    _this.delay = 2;
    /**
     * @property ils
     * @type {object}
     */

    _this.ils = {
      enabled: true,
      loc_maxDist: (0, _unitConverters.km)(25),
      // gs_maxHeight: 9999,
      glideslopeGradient: (0, _unitConverters.degreesToRadians)(3)
    };
    /**
     * @property length
     * @type
     * @default
     */

    _this.length = null;
    /**
     * @property sepFromAdjacent
     * @type {number}
     */

    _this.sepFromAdjacent = (0, _unitConverters.km)(3);
    /**
     * Aircraft queue
     *
     * A list of aircraft that have taxied to the end of
     * the runway and are waiting to takeoff
     *
     * @property queue
     * @type {array<string>}
     * @default []
     */

    _this.queue = [];
    /**
     * The flight number of the last aircraft that used the runway for takeoff.
     *
     * @property lastDepartedAircraftCallsign
     * @type {string}
     * @default null
     */

    _this.lastDepartedAircraftCallsign = null;

    _this._init(options, end, airportPositionModel);

    return _this;
  }
  /**
   * Fascade to access relative position
   *
   * @for RunwayModel
   * @property relativePosition
   * @type {array<number>} [kilometersNorth, kilometersEast]
   */


  _createClass(RunwayModel, [{
    key: "_init",

    /**
     * @for RunwayModel
     * @method _init
     * @param data
     * @param end
     * @param airportPositionModel {AirportModel}
     */
    value: function _init(data, end, airportPositionModel) {
      this.airportPositionModel = airportPositionModel;
      this.name = data.name[end]; // TODO: deprecate

      if (data.delay) {
        this.delay = data.delay[end];
      }

      if (data.end) {
        var farSideIndex = end === 0 ? 1 : 0;
        var thisSide = new _StaticPositionModel["default"](data.end[end], this.airportPositionModel, this.airportPositionModel.magneticNorth);
        var farSide = new _StaticPositionModel["default"](data.end[farSideIndex], this.airportPositionModel, this.airportPositionModel.magneticNorth); // relative position, based on center of map

        this._positionModel = thisSide;
        this.length = (0, _unitConverters.km)(thisSide.distanceToPosition(farSide));
        this.angle = thisSide.bearingToPosition(farSide);
      }

      if (data.ils) {
        this.ils.enabled = data.ils[end];
      }

      if (data.ils_distance) {
        this.ils.loc_maxDist = (0, _unitConverters.km)(data.ils_distance[end]);
      }

      if (data.glideslope) {
        this.ils.glideslopeGradient = (0, _unitConverters.degreesToRadians)(data.glideslope[end]);
      } // TODO: neither property is defined in any airport json files
      // if (data.ils_gs_maxHeight) {
      //     this.ils.gs_maxHeight = data.ils_gs_maxHeight[end];
      // }
      //
      // if (data.sepFromAdjacent) {
      //     this.sepFromAdjacent = km(data.sepFromAdjacent[end]);
      // }

    }
    /**
    * Calculate the height of the glideslope for a runway's ILS at a given distance on final
    *
    * @for RunwayModel
    * @method getGlideslopeAltitude
    * @param distance {number}                       distance from the runway threshold, in kilometers
    * @param glideslopeGradient {number} [optional]  gradient of the glideslope in radians
    *                                                (typically equivalent to 3.0 degrees)
    * @return {number}
    */

  }, {
    key: "getGlideslopeAltitude",
    value: function getGlideslopeAltitude(distance, glideslopeGradient) {
      if (!glideslopeGradient) {
        glideslopeGradient = this.ils.glideslopeGradient;
      }

      distance = Math.max(0, distance);
      var rise = (0, _core.tan)((0, _core.abs)(glideslopeGradient)); // TODO: this logic could be abstracted to a helper.

      return this.elevation + rise * (0, _unitConverters.km_ft)(distance);
    }
    /**
     * Calculate the height of the glideslope at (or abeam) the final approach fix
     *
     * @for RunwayModel
     * @method getGlideslopeAltitudeAtFinalApproachFix
     * @return {number} glideslope altitude in ft MSL
     */

  }, {
    key: "getGlideslopeAltitudeAtFinalApproachFix",
    value: function getGlideslopeAltitudeAtFinalApproachFix() {
      return this.getGlideslopeAltitude((0, _unitConverters.km)(_airportConstants.AIRPORT_CONSTANTS.FINAL_APPROACH_FIX_DISTANCE_NM));
    }
    /**
     * Calculate the height of the lowest 100-ft-increment altitude which is along the glideslope and beyond the FAF
     *
     * @for RunwayModel
     * @method getMinimumGlideslopeInterceptAltitude
     * @return {number} glideslope altitude in ft MSL
     */

  }, {
    key: "getMinimumGlideslopeInterceptAltitude",
    value: function getMinimumGlideslopeInterceptAltitude() {
      var altitudeAtFinalApproachFix = this.getGlideslopeAltitudeAtFinalApproachFix();
      var minimumInterceptAltitude = (0, _ceil2["default"])(altitudeAtFinalApproachFix, -2);
      return minimumInterceptAltitude;
    }
    /**
     * Return the spoken name of the runway, spelled out into words
     *
     * Ex: "two six left"
     *
     * @for RunwayModel
     * @method getRadioName
     * @return {string}
     */

  }, {
    key: "getRadioName",
    value: function getRadioName() {
      return (0, _radioUtilities.radio_runway)(this.name);
    }
    /**
     * Adds the specified aircraft to the runway queue
     *
     * @for RunwayModel
     * @method addAircraftToQueue
     * @param aircraftId {string}
     */

  }, {
    key: "addAircraftToQueue",
    value: function addAircraftToQueue(aircraftId) {
      this.queue.push(aircraftId);
    }
    /**
     * Remove the specified aircraft from the runway queue
     *
     * @for RunwayModel
     * @method removeAircraftFromQueue
     * @param aircraftId {string}
     */

  }, {
    key: "removeAircraftFromQueue",
    value: function removeAircraftFromQueue(aircraftId) {
      this.queue = (0, _without2["default"])(this.queue, aircraftId);
    }
    /**
     * Boolean helper used to determine if a specific aircraft instance is currently in the queue
     *
     * @for RunwayModel
     * @method isAircraftInQueue
     * @param aircraftId {string}
     * @return {boolean}
     */

  }, {
    key: "isAircraftInQueue",
    value: function isAircraftInQueue(aircraftId) {
      return this.getAircraftQueuePosition(aircraftId) !== _globalConstants.INVALID_NUMBER;
    }
    /**
     * Returns whether the specified aircraft is the first still waiting for takeoff clearance
     *
     * @for RunwayModel
     * @method isAircraftNextInQueue
     * @param  aircraftId {string}
     * @return {boolean}
     */

  }, {
    key: "isAircraftNextInQueue",
    value: function isAircraftNextInQueue(aircraftId) {
      return this.getAircraftQueuePosition(aircraftId) === 0;
    }
    /**
     * Returns the position of a specified aircraft in the runway's queue
     *
     * @for RunwayModel
     * @method getAircraftQueuePosition
     * @param  aircraftId {string}
     * @return {number}
     */

  }, {
    key: "getAircraftQueuePosition",
    value: function getAircraftQueuePosition(aircraftId) {
      return this.queue.indexOf(aircraftId);
    }
    /**
     * Wrapper for `calculateCrosswindAngleForRunway()` where an implementor needs only the `windAngle`
     * to calculate the crosswind angle
     *
     * @for RunwayModel
     * @method calculateCrosswindAngleForRunway
     * @param windAngle {number}
     * @return {number}  in radians
     */

  }, {
    key: "calculateCrosswindAngleForRunway",
    value: function calculateCrosswindAngleForRunway(windAngle) {
      return (0, _flightMath.calculateCrosswindAngle)(this.angle, windAngle);
    }
    /**
     * Boolean helper used to determine if an aircraftModel is on an approach course
     *
     * @for RunwayModel
     * @method isOnApproachCourse
     * @return {boolean}
     */

  }, {
    key: "isOnApproachCourse",
    value: function isOnApproachCourse(aircraftModel) {
      var approachOffset = (0, _flightMath.getOffset)(aircraftModel, this.relativePosition, this.angle);
      var lateralDistanceFromCourse_nm = (0, _core.abs)((0, _unitConverters.nm)(approachOffset[0]));
      var isAlignedWithCourse = lateralDistanceFromCourse_nm <= _aircraftConstants.PERFORMANCE.MAXIMUM_DISTANCE_CONSIDERED_ESTABLISHED_ON_APPROACH_COURSE_NM;
      var isNotPastRunwayThreshold = approachOffset[1] > 0;
      return isAlignedWithCourse && isNotPastRunwayThreshold;
    }
    /**
     * Boolean helper used to determine if an aircraftModel is on the correct approach heading.
     *
     * @for RunwayModel
     * @method isOnCorrectApproachGroundTrack
     * @param  aircraftGroundTrack {number}
     * @return {boolean}
     */

  }, {
    key: "isOnCorrectApproachGroundTrack",
    value: function isOnCorrectApproachGroundTrack(aircraftGroundTrack) {
      var angle_diff = (0, _core.abs)((0, _circle.angle_offset)(aircraftGroundTrack, this.angle));
      return angle_diff < _aircraftConstants.PERFORMANCE.MAXIMUM_ANGLE_CONSIDERED_ESTABLISHED_ON_APPROACH_COURSE;
    }
  }, {
    key: "relativePosition",
    get: function get() {
      return this._positionModel.relativePosition;
    }
    /**
     * Provide read-only public access to this._positionModel
     *
     * @for SpawnPatternModel
     * @property positionModel
     * @type {StaticPositionModel}
     */

  }, {
    key: "positionModel",
    get: function get() {
      return this._positionModel;
    }
    /**
     * Provide gps coordinates for the runway
     *
     * @for RunwayModel
     * @property gps
     * @type {array<number>} gps coordinates of the runway
     */

  }, {
    key: "gps",
    get: function get() {
      return this._positionModel.gps;
    }
    /**
     * @for RunwayModel
     * @property elevation
     * @type {number}
     */

  }, {
    key: "elevation",
    get: function get() {
      return this._positionModel.elevation || this.airportPositionModel.elevation;
    }
    /**
     * Reverse of runway magnetic heading, in radians
     *
     * @for RunwayModel
     * @property oppositeAngle
     * @type {number}
     */

  }, {
    key: "oppositeAngle",
    get: function get() {
      return (0, _circle.radians_normalize)(this.angle + Math.PI);
    }
  }]);

  return RunwayModel;
}(_BaseModel2["default"]);

exports["default"] = RunwayModel;

},{"../../base/BaseModel":295,"../../base/StaticPositionModel":297,"../../constants/aircraftConstants":303,"../../constants/airportConstants":305,"../../constants/globalConstants":310,"../../math/circle":348,"../../math/core":349,"../../math/flightMath":351,"../../utilities/radioUtilities":389,"../../utilities/unitConverters":391,"lodash/ceil":179,"lodash/without":252}],291:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _uniqueId2 = _interopRequireDefault(require("lodash/uniqueId"));

var _unitConverters = require("../../utilities/unitConverters");

var _core = require("../../math/core");

var _circle = require("../../math/circle");

var _flightMath = require("../../math/flightMath");

var _vector = require("../../math/vector");

var _aircraftConstants = require("../../constants/aircraftConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Describes a relationship between two `RunwayModel`s
 *
 * @class RunwayRelationshipModel
 */
var RunwayRelationshipModel =
/*#__PURE__*/
function () {
  /**
   *
   * @constructor
   * @param primaryRunway {RuwnayModel}
   * @param comparatorRunway {RunwayModel}
   */
  function RunwayRelationshipModel(primaryRunway, comparatorRunway) {
    _classCallCheck(this, RunwayRelationshipModel);

    if (!primaryRunway || !comparatorRunway) {
      throw new TypeError('Invalid parameters. RunwayRelationshipModel requires two RunwayModel instances');
    }
    /**
     * @property _id
     * @type {string}
     * @private
     */


    this._id = (0, _uniqueId2["default"])('runwayRelationshipModel-');
    /**
     * @property lateral_dist
     * @type {number}
     * @default -999
     */

    this.lateral_dist = -999;
    /**
     * @property straight_dist
     * @type {number}
     * @default -999
     */

    this.straight_dist = -999;
    /**
     * @property converging
     * @type {boolean}
     * @default false
     */

    this.converging = false;
    /**
     * @property parallel
     * @type {boolean}
     * @default false
     */

    this.parallel = false;
    /**
     * @property separationMinimum
     * @type {number}
     * @default -999
     */

    this.separationMinimum = -999;
    this.calculateRelationshipValues(primaryRunway, comparatorRunway);
  }
  /**
   * Calculate relationship values for each runway pair
   *
   * @for RunwayRelationshipModel
   * @method calculateRelationshipValues
   * @param primaryRunway {RuwnayModel}
   * @param comparatorRunway {RunwayModel}
   */


  _createClass(RunwayRelationshipModel, [{
    key: "calculateRelationshipValues",
    value: function calculateRelationshipValues(primaryRunway, comparatorRunway) {
      var offset = (0, _flightMath.getOffset)(primaryRunway, comparatorRunway.relativePosition, primaryRunway.angle);
      this.lateral_dist = (0, _core.abs)(offset[0]);
      this.straight_dist = (0, _core.abs)(offset[2]);
      this.converging = (0, _vector.raysIntersect)(primaryRunway.relativePosition, primaryRunway.angle, comparatorRunway.relativePosition, comparatorRunway.angle);
      this.parallel = (0, _core.abs)((0, _circle.angle_offset)(primaryRunway.angle, comparatorRunway.angle)) < (0, _unitConverters.degreesToRadians)(10);
      this.separationMinimum = this.calculateSeparationMinimums();
    }
    /**
     * Determine applicable lateral separation minima for conducting
     * parallel simultaneous dependent approaches on these runways:
     *
     * Note: This does not take into account the (more complicated)
     * rules for dual/triple simultaneous parallel dependent approaches as
     * outlined by FAA JO 7110.65, para 5-9-7. Users playing at any of our
     * airports that have triple parallels may be able to "get away with"
     * the less restrictive rules, whilst their traffic may not be 100%
     * legal. It's just complicated and not currently worthwhile to add
     * rules for running trips at this point... maybe later. -@erikquinn
     * Reference: FAA JO 7110.65, section 5-9-6
     *
     * @for RunwayRelationshipModel
     * @method calculateSeparationMinimums
     * @return applicableLatSepMin {number}
     */

  }, {
    key: "calculateSeparationMinimums",
    value: function calculateSeparationMinimums() {
      var applicableLatSepMin = _aircraftConstants.SEPARATION.STANDARD_LATERAL_KM; // 3.0nm

      var runwaySeparationDistanceFeet = (0, _unitConverters.km_ft)(this.lateral_dist);

      if (runwaySeparationDistanceFeet >= 2500 && runwaySeparationDistanceFeet <= 3600) {
        // 2500'-3600'
        applicableLatSepMin = (0, _unitConverters.km)(1); // 1.852km
      } else if (runwaySeparationDistanceFeet > 3600 && runwaySeparationDistanceFeet <= 4300) {
        // 3600'-4300'
        applicableLatSepMin = (0, _unitConverters.km)(1.5); // 2.778km
      } else if (runwaySeparationDistanceFeet > 4300 && runwaySeparationDistanceFeet <= 9000) {
        // 4300'-9000'
        applicableLatSepMin = (0, _unitConverters.km)(2); // 3.704km
      }

      return applicableLatSepMin;
    }
    /**
     * @for RunwayRelationshipModel
     * @method destroy
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.lateral_dist = -999;
      this.straight_dist = -999;
      this.converging = false;
      this.parallel = false;
      this.separationMinimum = -999;
    }
  }]);

  return RunwayRelationshipModel;
}();

exports["default"] = RunwayRelationshipModel;

},{"../../constants/aircraftConstants":303,"../../math/circle":348,"../../math/core":349,"../../math/flightMath":351,"../../math/vector":352,"../../utilities/unitConverters":391,"lodash/uniqueId":250}],292:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _selectors = require("../constants/selectors");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Display information about the active airport
 *
 * Part of the build includes copying and converting source
 * documents to html. This is retrieved via ajax request and
 * stored in memory until needed
 *
 * _Original documentation can be found in `documentation/airport-guides`_
 *
 * @class AirportGuideView
 */
var AirportGuideView =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {JQuery|HTMLElement} $element
   * @param {string} data  html string generated from airport-guide markdown
   */
  function AirportGuideView($element, data) {
    _classCallCheck(this, AirportGuideView);

    /**
     * Local instance of the airport guide data
     *
     * @property _airportGuideMarkup
     * @type {string}
     * @private
     */
    this._airportGuideMarkup = data;
    /**
     * The HTML containing the data itself
     *
     * @property _$airportGuideView
     * @type {JQuery|HTMLElement}
     * @private
     */

    this._$airportGuideView = null;
    /**
     * The HTML view container of the data (formatted)
     *
     * @property _$element
     * @type {JQuery|HTMLElement}
     * @default null
     * @private
     */

    this._$element = null;
    return this.init($element);
  } // ------------------------------ LIFECYCLE ------------------------------

  /**
   * Initialize the instance
   *
   * @for AirportGuideView
   * @method init
   * @chainable
   */


  _createClass(AirportGuideView, [{
    key: "init",
    value: function init($element) {
      this._createChildren($element);

      this.update(this._airportGuideMarkup);
      return this;
    }
    /**
     * Reset the instance
     *
     * @for AirportGuideView
     * @method reset
     * @chainable
     */

  }, {
    key: "reset",
    value: function reset() {
      this._airportGuideMarkup = null;
      this._$airportGuideView = null;
      this._$element = null;
      return this;
    }
    /**
     * Create child elements
     *
     * Should be run only once on instantiation
     *
     * @for AirportGuideView
     * @method _createChildren
     * @param {JQuery|HTMLElement} $element
     * @private
     * @chainable
     */

  }, {
    key: "_createChildren",
    value: function _createChildren($element) {
      this._$element = $element.find(_selectors.SELECTORS.DOM_SELECTORS.AIRPORT_GUIDE_CONTAINER);
      this._$airportGuideView = this._$element.find(_selectors.SELECTORS.DOM_SELECTORS.AIRPORT_GUIDE_VIEW);
      return this;
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Updates the text in the view.
     * Should be run by the controller on airport change.
     *
     * @for AirportGuideView
     * @method update
     * @param {string} nextAirportMarkup
     */

  }, {
    key: "update",
    value: function update(nextAirportMarkup) {
      this._airportGuideMarkup = nextAirportMarkup;

      this._$airportGuideView.html(this._airportGuideMarkup);
    }
    /**
     * Toggles visibility of the airport guide modal
     *
     * This method should only be called by the `AirportGuideController`
     *
     * @for AirportGuideView
     * @method toggleView
     */

  }, {
    key: "toggleView",
    value: function toggleView() {
      this._$element.toggleClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
    }
  }]);

  return AirportGuideView;
}();

exports["default"] = AirportGuideView;

},{"../constants/selectors":316}],293:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _has2 = _interopRequireDefault(require("lodash/has"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _AirportGuideView = _interopRequireDefault(require("./AirportGuideView"));

var _eventNames = require("../constants/eventNames");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Controls airportGuide view
 *
 * Responsible for maintaining a dictionary of `{[icao: string] html string}`
 * where each key is an airport icao with an html string as a value.
 * This markup is generated during the build from source markdown files
 *
 * @class AirportGuideViewController
 */
var AirportGuideViewController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {JQuery|HTMLElement} $element
   * @param {object} airportGuideData  dictionary of airport icao and html string
   * @param {string} initialIcao  airport used during startup of the app
   */
  function AirportGuideViewController($element, airportGuideData, initialIcao) {
    _classCallCheck(this, AirportGuideViewController);

    /**
     * View instance model
     *
     * Used to show, hide, update the airportGuide view
     *
     * @property _airportGuideView
     * @type {AirportGuideView}
     * @default null
     * @private
     */
    this._airportGuideView = null;
    /**
     * Root DOM element
     *
     * @property _$element
     * @type {JQuery|HTMLElement}
     * @default null
     * @private
     */

    this._$element = null;
    /**
     * Local reference to the EventBus
     *
     * @property _eventBus
     * @type {EventBus}
     * @private
     */

    this._eventBus = null;
    /**
     * Contains an object with keys of icao idents and values
     * of the airport guides from the documentation folder.
     *
     * @property _guideData
     * @type {object<string, string>}
     * @private
     */

    this._guideData = airportGuideData;
    /**
     * The ICAO of the initial airport.
     *
     * @property _initialIcao
     * @type {string}
     * @private
     */

    this._initialIcao = initialIcao.toLowerCase();
    return this.init($element);
  } // ------------------------------ LIFECYCLE ------------------------------

  /**
   * Enable handlers
   *
   * @for airportGuideViewController
   * @method enable
   * @chainable
   */


  _createClass(AirportGuideViewController, [{
    key: "enable",
    value: function enable() {
      this._eventBus.on(_eventNames.EVENT.AIRPORT_CHANGE, this._onAirportChangeHandler);

      this._eventBus.on(_eventNames.EVENT.TOGGLE_AIRPORT_GUIDE, this._onToggleViewHandler);

      return this;
    }
    /**
     * Disable handlers
     *
     * @for airportGuideViewController
     * @method disable
     * @chainable
     */

  }, {
    key: "disable",
    value: function disable() {
      this._eventBus.off(_eventNames.EVENT.AIRPORT_CHANGE, this._onAirportChangeHandler);

      this._eventBus.off(_eventNames.EVENT.TOGGLE_AIRPORT_GUIDE, this._onToggleViewHandler);

      return this;
    }
    /**
     * Initialize the instance
     *
     * Should only be run once on instantiation
     *
     * @for airportGuideViewController
     * @method init
     * @chainable
     */

  }, {
    key: "init",
    value: function init($element) {
      this._eventBus = _EventBus["default"];

      this._initAirportGuideView($element);

      this._setupHandlers();

      this.enable();
      return this;
    }
    /**
     * Reset the instance
     *
     * @for airportGuideViewController
     * @method reset
     * @chainable
     */

  }, {
    key: "reset",
    value: function reset() {
      this._resetHandlers();

      this._eventBus = null;
      this._$element = null;
      this._initialIcao = null;
      this._airportGuideView = null;
      this._guideData = null;
      return this;
    }
    /**
     * Initialize the `AirportGuideView` instance
     *
     * @for AirportGuideViewController
     * @method _initAirportGuideView
     * @param {Jquery Element} $element
     * @chainable
     * @private
     */

  }, {
    key: "_initAirportGuideView",
    value: function _initAirportGuideView($element) {
      var activeAirportGuide = this.getAirportGuide(this._initialIcao);
      this._airportGuideView = new _AirportGuideView["default"]($element, activeAirportGuide);
      return this;
    }
    /**
     * Bind method handlers
     *
     * Should only be run once on instantiation
     *
     * @for airportGuideViewController
     * @method _setupHandlers
     * @chainable
     */

  }, {
    key: "_setupHandlers",
    value: function _setupHandlers() {
      this._onAirportChangeHandler = this._onAirportChange.bind(this);
      this._onToggleViewHandler = this._onToggleView.bind(this);
      return this;
    }
    /**
     * Reset method handlers
     *
     * Should only be run once on instantiation
     *
     * @for airportGuideViewController
     * @method _resetHandlers
     * @chainable
     */

  }, {
    key: "_resetHandlers",
    value: function _resetHandlers() {
      this._onAirportChangeHandler = null;
      this._onToggleViewHandler = null;
      return this;
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Main getter method for an airport guide, identified by ICAO
     *
     * @for AirportGuideViewController
     * @method getAirportGuide
     * @param {string} nextIcao
     * @returns {string} - the requested guide
     */

  }, {
    key: "getAirportGuide",
    value: function getAirportGuide(nextIcao) {
      var guideExists = this.hasAirportGuide(nextIcao);

      if (!guideExists) {
        nextIcao = 'not_found';
      }

      return this._guideData[nextIcao];
    }
    /**
     * Returns whether or not an airport guide
     * exists for the given airport
     *
     * @for AirportGuideViewController
     * @method hasAirportGuide
     * @param {string} icao
     * @returns {Boolean} whether a guide was found
     */

  }, {
    key: "hasAirportGuide",
    value: function hasAirportGuide(icao) {
      return (0, _has2["default"])(this._guideData, icao);
    } // ------------------------------ PRIVATE ------------------------------

    /**
     * Event handler for when an airport is changed.
     *
     * @for AirportGuideViewController
     * @method _onAirportChange
     * @param {object} nextAirportJson
     * @private
     */

  }, {
    key: "_onAirportChange",
    value: function _onAirportChange(nextAirportJson) {
      var nextIcao = nextAirportJson.icao.toLowerCase();
      var airportGuideMarkupString = this.getAirportGuide(nextIcao);

      this._airportGuideView.update(airportGuideMarkupString);
    }
    /**
     * Event handler for toggling visibility of the airport guide view
     *
     * @for airportGuideViewController
     * @method _onToggleView
     * @param event {JQueryEventObject}
     * @private
     */

  }, {
    key: "_onToggleView",
    value: function _onToggleView() {
      this._airportGuideView.toggleView();
    }
  }]);

  return AirportGuideViewController;
}();

exports["default"] = AirportGuideViewController;

},{"../constants/eventNames":308,"../lib/EventBus":346,"./AirportGuideView":292,"lodash/has":201}],294:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _uniqueId2 = _interopRequireDefault(require("lodash/uniqueId"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Base class from which a collection type class can inherit from.
 *
 * This class is meant to be extended and should never be used directly.
 *
 * @class BaseCollection
 */
var BaseCollection =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @for BaseCollection
   */
  function BaseCollection() {
    _classCallCheck(this, BaseCollection);

    /**
     * Unigue string id that can be used to differentiate this model instance from another.
     *
     * @property _id
     * @type {string}
     * @private
     */
    this._id = (0, _uniqueId2["default"])();
    /**
     * @property _items
     * @type {array}
     * @default []
     * @private
     */

    this._items = [];
  }
  /**
   * Current length of the collection
   *
   * @property length
   * @return {number}
   */


  _createClass(BaseCollection, [{
    key: "_init",

    /**
     * Initialize the model properties. Should be run on instantiation and, though not desired,
     * could be run multiple times after instantiation.
     *
     * This method may be called by the constructor or from a public fascade.
     *
     * @for BaseCollection
     * @method _init
     * @private
     */
    value: function _init() {
      throw new TypeError('BaseCollection#_init has not been implemented by the extending class');
    }
    /**
     * Destory the current instance.
     *
     * When implemented by the inheriting class, this method should un-set all instance properties
     * and remove any handlers.
     *
     * @for BaseCollection
     * @method destroy
     */

  }, {
    key: "destroy",
    value: function destroy() {
      throw new TypeError('BaseCollection#destroy has not been implemented by the extending class');
    } // TODO: add additional common collection method
    // reset()
    // addItems()
    // addItem()
    // removeItem()

  }, {
    key: "length",
    get: function get() {
      return this._items.length;
    }
  }]);

  return BaseCollection;
}();

exports["default"] = BaseCollection;

},{"lodash/uniqueId":250}],295:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _uniqueId2 = _interopRequireDefault(require("lodash/uniqueId"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Base class for all Model objects to inherit from.
 *
 * This class is meant to be extended and should never be used directly.
 *
 * @class BaseModel
 */
var BaseModel =
/*#__PURE__*/
function () {
  function BaseModel() {
    var modelName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'BaseModel';

    _classCallCheck(this, BaseModel);

    var optionalIdPrefix = this._buildIdPrefix(modelName);
    /**
     * Unigue string id that can be used to differentiate this model instance from another.
     *
     * @property _id
     * @type {string}
     * @private
     */


    this._id = (0, _uniqueId2["default"])(optionalIdPrefix);
  }
  /**
   * Initialize the model properties. Should be run on instantiation and, though not desired,
   * could be run multiple times after instantiation.
   *
   * This method may be called by the constructor or from a public fascade.
   *
   * @for BaseModel
   * @method _init
   * @private
   */


  _createClass(BaseModel, [{
    key: "_init",
    value: function _init() {
      throw new TypeError('BaseModel#_init method must be implemented by the class extending BaseModel');
    }
    /**
     * Destory the current instance.
     *
     * When implemented by the inheriting class, this method should un-set all instance properties
     * and remove any handlers.
     *
     * @for BaseModel
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      throw new TypeError('BaseModel#reset method must be implemented by the class extending BaseModel');
    }
    /**
     * This will verify if the given argument is a string otherwise it will return 'Base Model'
     *
     * @for BaseModel
     * @method veriftyModelName
     * @param {string}
     * @private
     */

  }, {
    key: "_buildIdPrefix",
    value: function _buildIdPrefix(modelName) {
      if (!(0, _isString2["default"])(modelName)) {
        throw new TypeError('BaseModel#constructor expects a string for its first parameter but a string was not given');
      } // Default option since it is an optional parameter


      return "".concat(modelName, "-");
    }
  }]);

  return BaseModel;
}();

exports["default"] = BaseModel;

},{"lodash/isString":224,"lodash/uniqueId":250}],296:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));

var _uniqueId2 = _interopRequireDefault(require("lodash/uniqueId"));

var _positionModelHelpers = require("./positionModelHelpers");

var _circle = require("../math/circle");

var _unitConverters = require("../utilities/unitConverters");

var _globalConstants = require("../constants/globalConstants");

var _positionConstants = require("../constants/positionConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @class Position
 */
var DynamicPositionModel =
/*#__PURE__*/
function () {
  /**
   * Coordinates may contain an optional elevation as a third element.
   * It must be suffixed by either 'ft' or 'm' to indicate the units.
   *
   * Latitude and Longitude numbers may be one of the following forms:
   *   Decimal degrees - `47.112388112`
   *   Decimal degrees - `'N47.112388112'`
   *   Decimal minutes - `'N38d38.109808'`
   *   Decimal seconds - `'N58d27m12.138'`
   *
   * @for DynamicPositionModel
   * @constructor
   * @param coordinates {array<string|number>}    array in shape of [latitude, longitude]
   * @param reference {StaticPositionModel}       position to use for calculating relative position
   * @param magnetic_north {number}               magnetic declination (variation), in radians east
   */
  function DynamicPositionModel() {
    var coordinates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var reference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var magnetic_north = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, DynamicPositionModel);

    if (!(0, _positionModelHelpers.isValidGpsCoordinatePair)(coordinates)) {
      throw new TypeError('Invalid coordinates passed to DynamicPositionModel. Expected shape of ' + "\"[latitude, longitude]\" but received \"".concat(coordinates, "\""));
    }
    /**
     * @property _id
     * @type {string}
     */


    this._id = (0, _uniqueId2["default"])('position-model-');
    /**
     * Latitudinal coordinate, in degrees
     *
     * @property latitude
     * @type {number}
     * @default 0
     */

    this.latitude = 0;
    /**
     * Longitudinal coordinate, in degrees
     *
     * @property longitude
     * @type {number}
     * @default 0
     */

    this.longitude = 0;
    /**
     * Altitude of this position, above MSL (mean sea level), in feet
     *
     * @property elevation
     * @type {number}
     * @default 0
     */

    this.elevation = 0;
    /**
     * PositionModel this position is magnetically rotated in reference to
     *
     * @property _referencePosition
     * @type {DynamicPositionModel|null}
     */

    this._referencePosition = reference;
    /**
     * Magnetic declination, in radians east
     *
     * @property _magneticNorth
     * @type {number}
     */

    this._magneticNorth = magnetic_north;
    this.init(coordinates);
  }
  /**
   * GPS coordinates in [latitude, longitude] order
   * For reverse order, see `DynamicPositionModel.gpsXY`
   *
   * @property gps
   * @return {array}
   */


  _createClass(DynamicPositionModel, [{
    key: "init",

    /**
     * @for DynamicPositionModel
     * @method init
     */
    value: function init(coordinates) {
      this.latitude = (0, _unitConverters.parseCoordinate)(coordinates[_positionConstants.GPS_COORDINATE_INDEX.LATITUDE]);
      this.longitude = (0, _unitConverters.parseCoordinate)(coordinates[_positionConstants.GPS_COORDINATE_INDEX.LONGITUDE]); // TODO: this is using coersion and shoudld be updated to be more explicit

      if (coordinates[_positionConstants.GPS_COORDINATE_INDEX.ELEVATION] != null) {
        this.elevation = (0, _unitConverters.parseElevation)(coordinates[_positionConstants.GPS_COORDINATE_INDEX.ELEVATION]);
      }
    }
    /**
     * Calculate the initial magnetic bearing from a given position to the position of `this`
     *
     * @for DynamicPositionModel
     * @method bearingFromPosition
     * @param position {DynamicPositionModel|StaticPositionModel} position we're comparing against
     * @return {Number} magnetic bearing from `position` to `this`, in radians
     */

  }, {
    key: "bearingFromPosition",
    value: function bearingFromPosition(position) {
      return position.bearingToPosition(this);
    }
    /**
     * Calculate the initial magnetic bearing to a given position from the position of `this`
     * Note: This method uses great circle math to determine the bearing. It is very accurate, but
     * also a very expensive operation. If the precision is not needed, a vradial(vsub()) of the
     * x/y positions is a more "quick and dirty" option.
     *
     * Source: Chris Veness, Movable Type Scripts
     * Subject: "Bearing"
     * Link: http://www.movable-type.co.uk/scripts/latlong.html
     *
     * @for DynamicPositionModel
     * @method bearingToPosition
     * @param position {DynamicPositionModel|StaticPositionModel} position we're comparing against
     * @return {Number} magnetic bearing from `this` to `position`, in radians
     */

  }, {
    key: "bearingToPosition",
    value: function bearingToPosition(position) {
      var φ1 = (0, _unitConverters.degreesToRadians)(this.latitude);
      var φ2 = (0, _unitConverters.degreesToRadians)(position.latitude);
      var Δλ = (0, _unitConverters.degreesToRadians)(position.longitude - this.longitude);
      var y = Math.sin(Δλ) * Math.cos(φ2);
      var x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
      var θ = Math.atan2(y, x);
      return (0, _circle.radians_normalize)(θ - this._magneticNorth);
    }
    /**
     * Get the distance from `this` to a given position
     *
     * @for DynamicPositionModel
     * @method distanceToPosition
     * @param position {DynamicPositionModel|StaticPositionModel} position we're comparing against
     * @return {number} distance to `position`, in nautical miles
     */

  }, {
    key: "distanceToPosition",
    value: function distanceToPosition(position) {
      var R = _globalConstants.PHYSICS_CONSTANTS.EARTH_RADIUS_NM;
      var φ1 = (0, _unitConverters.degreesToRadians)(this.latitude);
      var φ2 = (0, _unitConverters.degreesToRadians)(position.latitude);
      var Δφ = (0, _unitConverters.degreesToRadians)(position.latitude - this.latitude);
      var Δλ = (0, _unitConverters.degreesToRadians)(position.longitude - this.longitude);
      var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      var d = R * c;
      return d;
    }
    /**
     * Returns a new `DynamicPositionModel` a given magnetic bearing/distance from `this`
     *
     * @for DynamicPositionModel
     * @method generateDynamicPositionFromBearingAndDistance
     * @param bearing {number} magnetic bearing, in radians
     * @param distance {number} distance, in nautical miles
     * @return {DynamicPositionModel}
     */

  }, {
    key: "generateDynamicPositionFromBearingAndDistance",
    value: function generateDynamicPositionFromBearingAndDistance(bearing, distance) {
      var _this$generateCoordin = this.generateCoordinatesFromBearingAndDistance(bearing, distance),
          _this$generateCoordin2 = _slicedToArray(_this$generateCoordin, 2),
          lat = _this$generateCoordin2[0],
          lon = _this$generateCoordin2[1];

      var dynamicPositionModel = new DynamicPositionModel([lat, lon], this._referencePosition, this._magneticNorth);
      return dynamicPositionModel;
    }
    /**
     * Returns the GPS coordinate pair a given magnetic bearing/distance from `this`
     *
     * Source: Chris Veness, Movable Type Scripts
     * Subject: "Destination point given distance and bearing from start point"
     * Link: http://www.movable-type.co.uk/scripts/latlong.html
     *
     * @for DynamicPositionModel
     * @method generateDynamicPositionFromBearingAndDistance
     * @param bearing {number} magnetic bearing, in radians
     * @param distance {number} distance, in nautical miles
     * @return {array} [latitude, longitude]
     */

  }, {
    key: "generateCoordinatesFromBearingAndDistance",
    value: function generateCoordinatesFromBearingAndDistance(bearing, distance) {
      var R = _globalConstants.PHYSICS_CONSTANTS.EARTH_RADIUS_NM;
      var θ = bearing + this._magneticNorth; // true bearing, in radians

      var d = distance;
      var δ = d / R; // angular distance, in earth laps

      var φ1 = (0, _unitConverters.degreesToRadians)(this.latitude);
      var λ1 = (0, _unitConverters.degreesToRadians)(this.longitude);
      var φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ));
      var λ2 = λ1 + Math.atan2(Math.sin(θ) * Math.sin(δ) * Math.cos(φ1), Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));
      var lat = (0, _unitConverters.radiansToDegrees)(φ2);
      var lon = (0, _unitConverters.radiansToDegrees)(λ2);
      return [lat, lon];
    }
    /**
     * Change the lat/lon coordinates of `this`
     *
     * @for DynamicPositionModel
     * @method setCoordinates
     * @param gpsCoordinates {Array<number>} [latitude, longitude]
     */

  }, {
    key: "setCoordinates",
    value: function setCoordinates(gpsCoordinates) {
      if (!(0, _positionModelHelpers.isValidGpsCoordinatePair)(gpsCoordinates)) {
        return new TypeError('Expected valid GPS coordinates to be passed to Position.setCoordinates, ' + "but received ".concat(gpsCoordinates));
      }

      this.latitude = gpsCoordinates[_positionConstants.GPS_COORDINATE_INDEX.LATITUDE];
      this.longitude = gpsCoordinates[_positionConstants.GPS_COORDINATE_INDEX.LONGITUDE];
    }
    /**
     * Change the lat/lon coordinates of `this` by providing the distance to move along a given magnetic heading
     *
     * @for DynamicPositionModel
     * @method setCoordinates
     * @param bearing {number} magnetic bearing, in radians
     * @param distance {number} distance, in nautical miles
     */

  }, {
    key: "setCoordinatesByBearingAndDistance",
    value: function setCoordinatesByBearingAndDistance(bearing, distance) {
      var nextCoordinates = this.generateCoordinatesFromBearingAndDistance(bearing, distance);
      this.setCoordinates(nextCoordinates);
    }
    /**
     * Determine the `x` and `y` values of the `DynamicPositionModel`, used for drawing on the canvas
     *
     * @for DynamicPositionModel
     * @method _calculateRelativePosition
     * @return {array<number>}
     * @private
     */

  }, {
    key: "_calculateRelativePosition",
    value: function _calculateRelativePosition() {
      if (!this._hasReferencePosition()) {
        return _positionConstants.DEFAULT_SCREEN_POSITION;
      }

      return DynamicPositionModel.calculateRelativePosition(this.gps, this._referencePosition, this._magneticNorth);
    }
    /**
     * Checks whether or not this `DynamicPositionModel` has a reference `DynamicPositionModel`
     * Without the reference position, the rotation due to magnetic variation will not be applied
     *
     * @for DynamicPositionModel
     * @method _hasReferencePosition
     * @return {Boolean} whether this position is based on a reference position
     * @private
     */

  }, {
    key: "_hasReferencePosition",
    value: function _hasReferencePosition() {
      return this._referencePosition !== null;
    }
  }, {
    key: "gps",
    get: function get() {
      return [this.latitude, this.longitude];
    }
    /**
     * GPS coordinates in [x,y] order
     * For reverse order, see `DynamicPositionModel.gps`
     *
     * @property gpsXY
     * @return {array}
     */

  }, {
    key: "gpsXY",
    get: function get() {
      return [this.longitude, this.latitude];
    }
    /**
     * @for DynamicPositionModel
     * @property magneticNorth
     * @return {number}
     */

  }, {
    key: "magneticNorth",
    get: function get() {
      return this._magneticNorth;
    }
    /**
     * Relative position, in km offset from the airport
     *
     * @property relativePosition
     * @return {array}
     */

  }, {
    key: "relativePosition",
    get: function get() {
      return this._calculateRelativePosition();
    }
    /**
     * Kilometers east (magnetic) of the reference position
     *
     * @for DynamicPositionModel
     * @property x
     * @type {number}
     */

  }, {
    key: "x",
    get: function get() {
      return this.relativePosition[_positionConstants.RELATIVE_POSITION_OFFSET_INDEX.LONGITUDINAL];
    }
    /**
     * Kilometers north (magnetic) of the reference position
     *
     * @for DynamicPositionModel
     * @property y
     * @type {number}
     */

  }, {
    key: "y",
    get: function get() {
      return this.relativePosition[_positionConstants.RELATIVE_POSITION_OFFSET_INDEX.LATITUDINAL];
    }
  }]);

  return DynamicPositionModel;
}();
/**
 * Calculate x/y position from latitude and longitude and a referencePosition
 *
 * Provides a static method to calculate position without instantiating a `DynamicPositionModel` class.
 *
 * @function getPosition
 * @param coordinates {array<string>}
 * @param referencePosition {DynamicPositionModel|StaticPositionModel|null}
 * @param magneticNorth {number}
 * @return {array}
 * @static
 */


exports["default"] = DynamicPositionModel;

DynamicPositionModel.calculateRelativePosition = function (coordinates, referencePosition, magneticNorth) {
  if (!coordinates || !referencePosition || !(0, _isNumber2["default"])(magneticNorth)) {
    throw new TypeError('Invalid parameter. DynamicPositionModel.calculateRelativePosition() requires ' + 'coordinates, referencePosition and magneticNorth as parameters');
  }

  var latitude = (0, _unitConverters.parseCoordinate)(coordinates[_positionConstants.GPS_COORDINATE_INDEX.LATITUDE]);
  var longitude = (0, _unitConverters.parseCoordinate)(coordinates[_positionConstants.GPS_COORDINATE_INDEX.LONGITUDE]);
  var canvasPositionX = (0, _positionModelHelpers.calculateDistanceToPointForX)(referencePosition, referencePosition.latitude, longitude);
  var canvasPositionY = (0, _positionModelHelpers.calculateDistanceToPointForY)(referencePosition, latitude, referencePosition.longitude);

  var _adjustForMagneticNor = (0, _positionModelHelpers.adjustForMagneticNorth)(canvasPositionX, canvasPositionY, magneticNorth),
      x = _adjustForMagneticNor.x,
      y = _adjustForMagneticNor.y;

  return [x, y];
};

},{"../constants/globalConstants":310,"../constants/positionConstants":313,"../math/circle":348,"../utilities/unitConverters":391,"./positionModelHelpers":298,"lodash/isNumber":220,"lodash/uniqueId":250}],297:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _DynamicPositionModel2 = _interopRequireDefault(require("./DynamicPositionModel"));

var _positionConstants = require("../constants/positionConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Like a DynamicPositionModel, but calculates once and PERMANANTLY stores the relative position [x, y] as a property
 *
 * @class StaticPositionModel
 * @extends DynamicPositionModel
 */
var StaticPositionModel =
/*#__PURE__*/
function (_DynamicPositionModel) {
  _inherits(StaticPositionModel, _DynamicPositionModel);

  /**
   * Coordinates may contain an optional elevation as a third element.
   * It must be suffixed by either 'ft' or 'm' to indicate the units.
   *
   * Latitude and Longitude numbers may be one of the following forms:
   *   Decimal degrees - `47.112388112`
   *   Decimal degrees - `'N47.112388112'`
   *   Decimal minutes - `'N38d38.109808'`
   *   Decimal seconds - `'N58d27m12.138'`
   *
   * @for StaticPositionModel
   * @constructor
   * @param coordinates {array<string|number>}    array in shape of [latitude, longitude]
   * @param reference {StaticPositionModel}       position to use for calculating relative position
   * @param magnetic_north {number}               magnetic declination (variation), in radians east
   */
  function StaticPositionModel() {
    var _this;

    var coordinates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var reference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var magnetic_north = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, StaticPositionModel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(StaticPositionModel).call(this, coordinates, reference, magnetic_north));
    /**
     * Description of a location, expressed in 'kilometers' north and east of a given
     * reference position on the screen (which is almost always the airport). Note that
     * this location is offset from the reference position not in alignment with TRUE
     * north, but rather MAGNETIC north (which is the alignment of the scope).
     *
     * @for StaticPositionModel
     * @property _relativePosition
     * @type {array<number>} [kilometersNorth, kilometersEast]
     * @private
     */

    _this._relativePosition = _positionConstants.DEFAULT_SCREEN_POSITION;

    _this._initializeRelativePosition();

    return _this;
  }
  /**
   * @for StaticPositionModel
   * @property referencePosition
   * @return {array<number>} [kilometersNorth, kilometersEast]
   */


  _createClass(StaticPositionModel, [{
    key: "setCoordinates",

    /**
     * Dummy method to overwrite that of `DynamicPositionModel` in order to disallow the making of
     * any modifications to the `StaticPositionModel`.
     *
     * @for StaticPositionModel
     * @method setCoordinates
     */
    value: function setCoordinates() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      console.warn("Unexpected attempt to modify a StaticPositionModel, via .setCoordinates(".concat(args, ");")); // do nothing, because `StaticPositionModel`s cannot be changed
    }
    /**
     * Calculate the relative position and store it in the property
     *
     * @for DynamicPositionModel
     * @method _initializeRelativePosition
     */

  }, {
    key: "_initializeRelativePosition",
    value: function _initializeRelativePosition() {
      if (!this._hasReferencePosition()) {
        return _positionConstants.DEFAULT_SCREEN_POSITION;
      }

      this._relativePosition = _DynamicPositionModel2["default"].calculateRelativePosition(this.gps, this._referencePosition, this._magneticNorth);
    }
  }, {
    key: "referencePosition",
    get: function get() {
      return this._referencePosition;
    }
    /**
     * Relative position, in km offset from the airport
     *
     * @for StaticPositionModel
     * @property relativePosition
     * @return {array<number>} [kilometersNorth, kilometersEast]
     */

  }, {
    key: "relativePosition",
    get: function get() {
      return this._relativePosition;
    }
    /**
     * Kilometers east (magnetic) of the reference position
     *
     * @for StaticPositionModel
     * @property x
     * @type {number}
     */

  }, {
    key: "x",
    get: function get() {
      return this._relativePosition[_positionConstants.RELATIVE_POSITION_OFFSET_INDEX.LONGITUDINAL];
    }
    /**
     * Kilometers north (magnetic) of the reference position
     *
     * @for StaticPositionModel
     * @property y
     * @type {number}
     */

  }, {
    key: "y",
    get: function get() {
      return this._relativePosition[_positionConstants.RELATIVE_POSITION_OFFSET_INDEX.LATITUDINAL];
    }
  }]);

  return StaticPositionModel;
}(_DynamicPositionModel2["default"]);

exports["default"] = StaticPositionModel;

},{"../constants/positionConstants":313,"./DynamicPositionModel":296}],298:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isValidGpsCoordinatePair = exports.adjustForMagneticNorth = exports.calculateDistanceToPointForY = exports.calculateDistanceToPointForX = exports.hasCardinalDirectionInCoordinate = void 0;

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _globalConstants = require("../constants/globalConstants");

var _circle = require("../math/circle");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * @function hasCardinalDirectionInCoordinate
 * @param coordinate {string}
 * @return {boolean}
 */
var hasCardinalDirectionInCoordinate = function hasCardinalDirectionInCoordinate(coordinate) {
  return _globalConstants.REGEX.COMPASS_DIRECTION.test(coordinate);
}; // TODO: Are these two functions really needed to be separate?

/**
 * @function calculateDistanceToPointForX
 * @param referencePosition {StaticPositionModel}
 * @param latitude {number}
 * @param longitude {number}
 * @return x {number}
 */


exports.hasCardinalDirectionInCoordinate = hasCardinalDirectionInCoordinate;

var calculateDistanceToPointForX = function calculateDistanceToPointForX(referencePosition, latitude, longitude) {
  var x = (0, _circle.distanceToPoint)(referencePosition.latitude, referencePosition.longitude, latitude, longitude);

  if (referencePosition.longitude > longitude) {
    x *= -1;
  }

  return x;
}; // TODO: Are these two functions really needed to be separate?

/**
 *
 *
 * @function calculateDistanceToPointForY
 * @param referencePosition {StaticPositionModel}
 * @param latitude {number}
 * @param longitude {number}
 * @return y {number}
 */


exports.calculateDistanceToPointForX = calculateDistanceToPointForX;

var calculateDistanceToPointForY = function calculateDistanceToPointForY(referencePosition, latitude, longitude) {
  var y = (0, _circle.distanceToPoint)(referencePosition.latitude, referencePosition.longitude, latitude, longitude);

  if (referencePosition.latitude > latitude) {
    y *= -1;
  }

  return y;
};
/**
 * Adjust to use magnetic north instead of true north
 *
 * @function adjustForMagneticNorth
 * @param originalX {string}
 * @param originalY {string}
 * @param magneticNorth {number}
 * @return {object}
 */


exports.calculateDistanceToPointForY = calculateDistanceToPointForY;

var adjustForMagneticNorth = function adjustForMagneticNorth(originalX, originalY, magneticNorth) {
  var t = Math.atan2(originalY, originalX) + magneticNorth;
  var r = Math.sqrt(originalX * originalX + originalY * originalY);
  var x = r * Math.cos(t);
  var y = r * Math.sin(t);
  return {
    x: x,
    y: y
  };
};
/**
 * Returns whether provided GPS coordinate pair is valid
 *
 * @function isValidGpsCoordinatePair
 * @param  gpsCoordinates {array<number>} in the shape of [latitude, longitude]
 * @return {Boolean}
 */


exports.adjustForMagneticNorth = adjustForMagneticNorth;

var isValidGpsCoordinatePair = function isValidGpsCoordinatePair(gpsCoordinates) {
  var hasContent = !(0, _isNil2["default"])(gpsCoordinates);
  var hasTwoOrThreeElements = gpsCoordinates.length === 2 || gpsCoordinates.length === 3;

  var firstTwoElementsHaveSameType = _typeof(gpsCoordinates[0]) === _typeof(gpsCoordinates[1]);

  if (!hasContent || !hasTwoOrThreeElements || !firstTwoElementsHaveSameType) {
    return false;
  }

  var latitude = gpsCoordinates[0];
  var longitude = gpsCoordinates[1];

  if (typeof latitude === 'number') {
    return true;
  } else if (typeof latitude === 'string') {
    var latFirstCharIsNorthOrSouth = ['N', 'S'].indexOf(latitude[0].toUpperCase()) !== _globalConstants.INVALID_INDEX;

    var lonFirstCharIsEastOrWest = ['E', 'W'].indexOf(longitude[0].toUpperCase()) !== _globalConstants.INVALID_INDEX;

    return latFirstCharIsNorthOrSouth && lonFirstCharIsEastOrWest;
  }

  return false;
};

exports.isValidGpsCoordinatePair = isValidGpsCoordinatePair;

},{"../constants/globalConstants":310,"../math/circle":348,"lodash/isNil":219}],299:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertStaticPositionToDynamic = void 0;

var _DynamicPositionModel = _interopRequireDefault(require("./DynamicPositionModel"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Accepts a `StaticPositionModel` and returns a `DynamicPositionModel` with the same location
 *
 * @function convertStaticPositionToDynamic
 * @param staticPositionModel {StaticPositionModel}
 * @return {DynamicPositionModel}
 */
var convertStaticPositionToDynamic = function convertStaticPositionToDynamic(staticPositionModel) {
  return new _DynamicPositionModel["default"](staticPositionModel.gps, staticPositionModel.referencePosition, staticPositionModel.magneticNorth);
};

exports.convertStaticPositionToDynamic = convertStaticPositionToDynamic;

},{"./DynamicPositionModel":296}],300:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _filter2 = _interopRequireDefault(require("lodash/filter"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _inRange2 = _interopRequireDefault(require("lodash/inRange"));

var _AirportController = _interopRequireDefault(require("../airport/AirportController"));

var _CanvasStageModel = _interopRequireDefault(require("./CanvasStageModel"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _GameController = _interopRequireDefault(require("../game/GameController"));

var _MeasureTool = _interopRequireDefault(require("../measurement/MeasureTool"));

var _NavigationLibrary = _interopRequireDefault(require("../navigationLibrary/NavigationLibrary"));

var _TimeKeeper = _interopRequireDefault(require("../engine/TimeKeeper"));

var _circle = require("../math/circle");

var _core = require("../math/core");

var _vector = require("../math/vector");

var _aircraftConstants = require("../constants/aircraftConstants");

var _canvasConstants = require("../constants/canvasConstants");

var _themes = require("../constants/themes");

var _eventNames = require("../constants/eventNames");

var _globalConstants = require("../constants/globalConstants");

var _gameOptionConstants = require("../constants/gameOptionConstants");

var _routeConstants = require("../constants/routeConstants");

var _generalUtilities = require("../utilities/generalUtilities");

var _unitConverters = require("../utilities/unitConverters");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @class CanvasController
 */
var CanvasController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param $element {JQuery|HTML Element}
   * @param aircraftController {AircraftController}
   * @param scopeModel {ScopeModel}
   */
  function CanvasController($element, aircraftController, scopeModel) {
    _classCallCheck(this, CanvasController);

    /**
     * Reference to the `window` object
     *
     * @property $window
     * @type {JQuery|HTML Element}
     */
    this.$window = (0, _jquery["default"])(window);
    /**
     * Reference to the `#canvases` tag which acts as the container
     * element for all the `<canvas />` elements
     *
     * @property $element
     * @type $element {JQuery|HTML Element}
     * @default $element
     */

    this.$element = $element;
    /**
     * @property _aircraftController
     * @type {AircraftController}
     * @private
     */

    this._aircraftController = aircraftController;
    /**
     * @property _scopeModel
     * @type {ScopeModel}
     * @private
     */

    this._scopeModel = scopeModel;
    /**
     * @property _eventBus
     * @type {EventBus}
     * @private
     */

    this._eventBus = _EventBus["default"];
    /**
     * @property _context
     * @type {object<string, HTMLCanvasContext>}
     * @private
     */

    this._context = {};
    /**
     * Flag used to determine if the canvas dimensions should be resized
     *
     * @property _shouldResize
     * @type {boolean}
     * @default true
     * @private
     */

    this._shouldResize = true;
    /**
     * Flag used to determine if the Aircraft canvas should be updated
     *
     * @property _shouldShallowRender
     * @type {boolean}
     * @default true
     */

    this._shouldShallowRender = true;
    /**
     * Flag used to determine if _all_ canvases should be updated
     *
     * When this is true, the non-updating canvases like terrain, fix labels,
     * video map, etc will be recalculated and re-drawn.
     *
     * This should only be true when the view changes via zoom/pan or airport change
     *
     * @property _shouldDeepRender
     * @type {boolean}
     * @default true
     */

    this._shouldDeepRender = true;
    /**
     * Flag used to determine if airspace polygons should be displayed and labeled
     *
     * @property _shouldDrawAirspace
     * @type {boolean}
     * @default false
     */

    this._shouldDrawAirspace = false;
    /**
     * Flag used to determine if fix labels should be displayed
     *
     * @property _shouldDrawFixLabels
     * @type {boolean}
     * @default false
     */

    this._shouldDrawFixLabels = false;
    /**
     * Flag used to determine if restricted areas should be displayed
     *
     * @property _shouldDrawRestrictedAreas
     * @type {boolean}
     * @default false
     */

    this._shouldDrawRestrictedAreas = false;
    /**
     * Flag used to determine if the sid map should be displayed
     *
     * @property _shouldDrawSidMap
     * @type {boolean}
     * @default false
     */

    this._shouldDrawSidMap = false;
    /**
     * Flag used to determine if the star map should be displayed
     *
     * @property _shouldDrawStarMap
     * @type {boolean}
     * @default false
     */

    this._shouldDrawStarMap = false;
    /**
     * Flag used to determine if terrain should be displayed
     *
     * @property _shouldDrawTerrain
     * @type {boolean}
     * @default true
     */

    this._shouldDrawTerrain = true;
    /**
     * Flag used to determine if the video map should be displayed
     *
     * @property _shouldDrawVideoMap
     * @type {boolean}
     * @default true
     */

    this._shouldDrawVideoMap = true;
    /**
     * has a console.warn been output for terrain?
     *
     * This is meant for airport contributors designing new airports
     *
     * @property _hasSeenTerrainWarning
     * @type {boolean}
     * @default false
     */

    this._hasSeenTerrainWarning = false;
    /**
     * container property for the current canvas theme
     *
     * @property theme
     * @type {object}
     * @default null
     */

    this.theme = null;
    return this._init()._setupHandlers().enable();
  }
  /**
   * @for CanvasController
   * @method _init
   * @private
   * @chainable
   */


  _createClass(CanvasController, [{
    key: "_init",
    value: function _init() {
      this._setTheme(_GameController["default"].getGameOption(_gameOptionConstants.GAME_OPTION_NAMES.THEME));

      return this;
    }
    /**
     * @for CanvasController
     * @method _setupHandlers
     * @chainable
     * @private
     */

  }, {
    key: "_setupHandlers",
    value: function _setupHandlers() {
      this._onSelectAircraftHandler = this._onSelectAircraft.bind(this);
      this._onDeselectAircraftHandler = this._onDeselectAircraft.bind(this);
      this._onCenterPointInViewHandler = this._onCenterPointInView.bind(this);
      this._onChangeViewportPanHandler = this._onChangeViewportPan.bind(this);
      this._onChangeViewportZoomHandler = this._onChangeViewportZoom.bind(this);
      this._onMarkDirtyCanvasHandler = this._onMarkDirtyCanvas.bind(this);
      this._onToggleAirspaceHandler = this._onToggleAirspace.bind(this);
      this._onToggleLabelsHandler = this._onToggleLabels.bind(this);
      this._onToggleRestrictedAreasHandler = this._onToggleRestrictedAreas.bind(this);
      this._onToggleSidMapHandler = this._onToggleSidMap.bind(this);
      this._onToggleStarMapHandler = this._onToggleStarMap.bind(this);
      this._onAirportChangeHandler = this._onAirportChange.bind(this);
      this._onToggleTerrainHandler = this._onToggleTerrain.bind(this);
      this._onToggleVideoMapHandler = this._onToggleVideoMap.bind(this);
      this._onRangeRingsChangeHandler = this._onRangeRingsChange.bind(this);
      this._onResizeHandler = this.canvas_resize.bind(this);
      this._setThemeHandler = this._setTheme.bind(this);
      return this;
    }
    /**
     * @for CanvasController
     * @method enable
     * @chainable
     */

  }, {
    key: "enable",
    value: function enable() {
      this._eventBus.on(_eventNames.EVENT.SELECT_AIRCRAFT, this._onSelectAircraftHandler);

      this._eventBus.on(_eventNames.EVENT.DESELECT_AIRCRAFT, this._onDeselectAircraftHandler);

      this._eventBus.on(_eventNames.EVENT.REQUEST_TO_CENTER_POINT_IN_VIEW, this._onCenterPointInViewHandler);

      this._eventBus.on(_eventNames.EVENT.PAN_VIEWPORT, this._onChangeViewportPanHandler);

      this._eventBus.on(_eventNames.EVENT.ZOOM_VIEWPORT, this._onChangeViewportZoomHandler);

      this._eventBus.on(_eventNames.EVENT.MARK_SHALLOW_RENDER, this._onMarkDirtyCanvasHandler);

      this._eventBus.on(_eventNames.EVENT.TOGGLE_AIRSPACE, this._onToggleAirspaceHandler);

      this._eventBus.on(_eventNames.EVENT.TOGGLE_LABELS, this._onToggleLabelsHandler);

      this._eventBus.on(_eventNames.EVENT.TOGGLE_RESTRICTED_AREAS, this._onToggleRestrictedAreasHandler);

      this._eventBus.on(_eventNames.EVENT.TOGGLE_SID_MAP, this._onToggleSidMapHandler);

      this._eventBus.on(_eventNames.EVENT.TOGGLE_STAR_MAP, this._onToggleStarMapHandler);

      this._eventBus.on(_eventNames.EVENT.TOGGLE_TERRAIN, this._onToggleTerrainHandler);

      this._eventBus.on(_eventNames.EVENT.TOGGLE_VIDEO_MAP, this._onToggleVideoMapHandler);

      this._eventBus.on(_eventNames.EVENT.RANGE_RINGS_CHANGE, this._onRangeRingsChangeHandler);

      this._eventBus.on(_eventNames.EVENT.AIRPORT_CHANGE, this._onAirportChangeHandler);

      this._eventBus.on(_eventNames.EVENT.SET_THEME, this._setThemeHandler);

      window.addEventListener('resize', this._onResizeHandler);
      this.$element.addClass(this.theme.CLASSNAME);
      return this;
    }
    /**
     * @for CanvasController
     * @method disable
     */

  }, {
    key: "disable",
    value: function disable() {
      this._eventBus.off(_eventNames.EVENT.SELECT_AIRCRAFT, this._onSelectAircraftHandler);

      this._eventBus.off(_eventNames.EVENT.DESELECT_AIRCRAFT, this._onDeselectAircraftHandler);

      this._eventBus.off(_eventNames.EVENT.REQUEST_TO_CENTER_POINT_IN_VIEW, this._onCenterPointInView);

      this._eventBus.off(_eventNames.EVENT.PAN_VIEWPORT, this._onChangeViewportPan);

      this._eventBus.off(_eventNames.EVENT.ZOOM_VIEWPORT, this._onChangeViewportZoom);

      this._eventBus.off(_eventNames.EVENT.MARK_SHALLOW_RENDER, this._onMarkDirtyCanvas);

      this._eventBus.off(_eventNames.EVENT.TOGGLE_AIRSPACE, this._onToggleAirspaceHandler);

      this._eventBus.off(_eventNames.EVENT.TOGGLE_LABELS, this._onToggleLabels);

      this._eventBus.off(_eventNames.EVENT.TOGGLE_RESTRICTED_AREAS, this._onToggleRestrictedAreas);

      this._eventBus.off(_eventNames.EVENT.TOGGLE_SID_MAP, this._onToggleSidMap);

      this._eventBus.off(_eventNames.EVENT.TOGGLE_STAR_MAP, this._onToggleStarMap);

      this._eventBus.off(_eventNames.EVENT.TOGGLE_TERRAIN, this._onToggleTerrain);

      this._eventBus.off(_eventNames.EVENT.TOGGLE_VIDEO_MAP, this._onToggleVideoMapHandler);

      this._eventBus.off(_eventNames.EVENT.RANGE_RINGS_CHANGE, this._onRangeRingsChangeHandler);

      this._eventBus.off(_eventNames.EVENT.AIRPORT_CHANGE, this._onAirportChangeHandler);

      this._eventBus.off(_eventNames.EVENT.SET_THEME, this._setTheme);

      window.removeEventListener('resize', this._onResizeHandler);
      return this.destroy();
    }
    /**
     * @for CanvasController
     * @method destroy
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.$window = null;
      this.$element = null;
      this._context = {};
      this._shouldResize = true;
      this._shouldShallowRender = true;
      this._shouldDeepRender = true;
      this._shouldDrawFixLabels = false;
      this._shouldDrawRestrictedAreas = false;
      this._shouldDrawSidMap = false;
      this._shouldDrawStarMap = false;
      this._shouldDrawTerrain = true;
      return this;
    }
    /**
     * Called by `AppController.init()`
     *
     * Creates canvas elements and stores context
     *
     * @for CanvasController
     * @method canvas_init
     */

  }, {
    key: "canvas_init",
    value: function canvas_init() {
      this._addCanvas(_canvasConstants.CANVAS_NAME.STATIC);

      this._addCanvas(_canvasConstants.CANVAS_NAME.DYNAMIC);
    }
    /**
     * Called by `AppController.complete()`
     *
     * @for CanvasController
     * @method
     */

  }, {
    key: "canvas_complete",
    value: function canvas_complete() {
      var _this = this;

      // TODO: not sure what the rationale is here. this should be removed/reworked if possible
      setTimeout(function () {
        _this._markDeepRender();
      }, 500);
    }
    /**
     * A `resize` event was captured by the `AppController`
     *
     * Here we re-calculate the canvas dimensions
     *
     * @for CanvasController
     * @method canvas_resize
     */

  }, {
    key: "canvas_resize",
    value: function canvas_resize() {
      if (this._shouldResize) {
        _CanvasStageModel["default"].updateHeightAndWidth(this.$window.height(), this.$window.width());
      }

      for (var canvasName in this._context) {
        var context = this._context[canvasName];
        context.canvas.height = _CanvasStageModel["default"].height;
        context.canvas.width = _CanvasStageModel["default"].width;

        this._adjustHidpi(canvasName);
      }

      this._markDeepRender();
    }
    /**
     * Main update method called by `AppController.update_post()` within the game loop
     *
     * All methods called from this function should accept a canvas context argument.
     * The rationale here is that each method sets up and tears down any origin or state
     * transformations themselves. This way the methods can be organized or moved any
     * way we choose without having to worry about what the current state of the `context`
     *
     * It is important for code in this method, or called by this method, to be as
     * performant as possible so as not to degrade performance.
     *
     * @for CanvasController
     * @method canvasUpdatePost
     */

  }, {
    key: "canvasUpdatePost",
    value: function canvasUpdatePost() {
      if (!this._shouldShallowRender && !_TimeKeeper["default"].shouldUpdate()) {
        return;
      }

      if (this._shouldDeepRender) {
        // we should only ever enter this block as a result of a change in the view
        // or an airport change. these methods involve much more complicated drawing
        // and can degrade performance if called too frequently.
        var staticCanvasCtx = this._getCanvasContextByName(_canvasConstants.CANVAS_NAME.STATIC);

        this._clearCanvasContext(staticCanvasCtx);

        this._drawVideoMap(staticCanvasCtx);

        this._drawTerrain(staticCanvasCtx);

        this._drawRestrictedAirspace(staticCanvasCtx);

        this._drawRunways(staticCanvasCtx);

        this._drawAirportFixesAndLabels(staticCanvasCtx);

        this._drawSids(staticCanvasCtx);

        this._drawStars(staticCanvasCtx);

        this._drawAirspaceAndRangeRings(staticCanvasCtx);

        this._drawAirspaceShelvesAndLabels(staticCanvasCtx);

        this._drawRunwayLabels(staticCanvasCtx);

        this._drawCurrentScale(staticCanvasCtx);
      }

      var dynamicCanvasCtx = this._getCanvasContextByName(_canvasConstants.CANVAS_NAME.DYNAMIC);

      this._clearCanvasContext(dynamicCanvasCtx);

      this._drawSelectedAircraftCompass(dynamicCanvasCtx);

      this._drawRadarTargetList(dynamicCanvasCtx);

      this._drawAircraftDataBlocks(dynamicCanvasCtx);

      this._drawMeasureTool(dynamicCanvasCtx);

      this._shouldShallowRender = false;
      this._shouldDeepRender = false;
    }
    /**
     * Used primarily for the data block
     *
     * This provides a way to know when to show the primary
     * dataBlock or the secondary dataBlock
     *
     * @method shouldShowSecondaryDataBlock
     * @returns {boolean}
     */

  }, {
    key: "shouldShowSecondaryDataBlock",
    value: function shouldShowSecondaryDataBlock() {
      return (0, _inRange2["default"])(_TimeKeeper["default"].gameTimeMilliseconds % 3000, 2000, 3000);
    }
    /**
     * Add a `canvas` element to the DOM
     *
     * @for CanvasController
     * @method _addCanvas
     * @param name {CANVAS_NAME|string}
     * @private
     */

  }, {
    key: "_addCanvas",
    value: function _addCanvas(name) {
      var canvasTemplate = "<canvas id='".concat(name, "-canvas'></canvas>");
      this.$element.append(canvasTemplate);
      this._context[name] = (0, _jquery["default"])("#".concat(name, "-canvas")).get(0).getContext('2d');
    }
    /**
     * @for CanvasController
     * @method _adjustHidpi
     * @private
     */

  }, {
    key: "_adjustHidpi",
    value: function _adjustHidpi(canvasName) {
      var devicePixelRatio = window.devicePixelRatio || 1;
      var canvasContext = this._context[canvasName];

      if (devicePixelRatio <= 1) {
        return;
      }

      var $canvasElement = (0, _jquery["default"])("#".concat(canvasContext.canvas.id)).get(0);
      (0, _jquery["default"])($canvasElement).attr('height', _CanvasStageModel["default"].height * devicePixelRatio);
      (0, _jquery["default"])($canvasElement).css('height', _CanvasStageModel["default"].height);
      (0, _jquery["default"])($canvasElement).attr('width', _CanvasStageModel["default"].width * devicePixelRatio);
      (0, _jquery["default"])($canvasElement).css('width', _CanvasStageModel["default"].width);
      canvasContext.scale(devicePixelRatio, devicePixelRatio);
    }
    /**
     * Clear the current canvas context
     *
     * @for CanvasController
     * @method _clearCanvasContext
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_clearCanvasContext",
    value: function _clearCanvasContext(cc) {
      cc.clearRect(0, 0, _CanvasStageModel["default"].width, _CanvasStageModel["default"].height);
    }
    /**
     * @for CanvasController
     * @method _drawSingleRunway
     * @param cc {HTMLCanvasContext}
     * @param runwayModel {RunwayModel}
     * @param mode {boolean}               flag to switch between drawing a runway or just a runway centerline
     * @private
     */

  }, {
    key: "_drawSingleRunway",
    value: function _drawSingleRunway(cc, runwayModel, mode) {
      var runwayLength = (0, _core.round)(_CanvasStageModel["default"].translateKilometersToPixels(runwayModel.length / 2)) * -2;
      var angle = runwayModel.angle;

      var runwayPosition = _CanvasStageModel["default"].translatePostionModelToRoundedCanvasPosition(runwayModel.relativePosition);

      cc.save();
      cc.translate(runwayPosition.x, runwayPosition.y);
      cc.rotate(angle); // runway body

      if (!mode) {
        cc.strokeStyle = '#899';
        cc.lineWidth = 2.8;
        cc.beginPath();
        cc.moveTo(0, 0);
        cc.lineTo(0, runwayLength);
        cc.stroke();
      } else {
        // extended centerlines
        if (!runwayModel.ils.enabled) {
          cc.restore();
          return;
        }

        cc.strokeStyle = this.theme.SCOPE.RUNWAY_EXTENDED_CENTERLINE;
        cc.lineWidth = 1;
        cc.beginPath();
        cc.moveTo(0, 0);
        cc.lineTo(0, _CanvasStageModel["default"].translateKilometersToPixels(runwayModel.ils.loc_maxDist));
        cc.stroke();
      }

      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawRunwayLabel
     * @param cc {HTMLCanvasContext}
     * @param runway {RunwayModel}
     * @private
     */

  }, {
    key: "_drawRunwayLabel",
    value: function _drawRunwayLabel(cc, runwayModel) {
      var length2 = (0, _core.round)(_CanvasStageModel["default"].translateKilometersToPixels(runwayModel.length / 2)) + 0.5;

      var runwayPosition = _CanvasStageModel["default"].translatePostionModelToRoundedCanvasPosition(runwayModel.relativePosition);

      var angle = runwayModel.angle;
      var textHeight = 14;
      cc.save();
      cc.textAlign = 'center';
      cc.textBaseline = 'middle';
      cc.translate(runwayPosition.x, runwayPosition.y);
      cc.rotate(angle);
      cc.translate(0, length2 + textHeight);
      cc.rotate(-angle);
      cc.fillText(runwayModel.name, 0, 0);
      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawRunways
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawRunways",
    value: function _drawRunways(cc) {
      if (!this._shouldDrawFixLabels) {
        return;
      }

      cc.save();
      cc.translate(_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight);
      cc.font = '11px monoOne, monospace';
      cc.strokeStyle = this.theme.SCOPE.RUNWAY;
      cc.fillStyle = this.theme.SCOPE.RUNWAY;
      cc.lineWidth = 4;

      var airportModel = _AirportController["default"].airport_get(); // TODO: we should try to consolidate this so we aren't looping over the runway collection multiple times
      // Extended Centerlines


      for (var i = 0; i < airportModel.runways.length; i++) {
        this._drawSingleRunway(cc, airportModel.runways[i][0], true);

        this._drawSingleRunway(cc, airportModel.runways[i][1], true);
      } // Runways


      for (var _i = 0; _i < airportModel.runways.length; _i++) {
        this._drawSingleRunway(cc, airportModel.runways[_i][0], false);
      }

      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawRunwayLabels
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawRunwayLabels",
    value: function _drawRunwayLabels(cc) {
      if (!this._shouldDrawFixLabels) {
        return;
      }

      var airportModel = _AirportController["default"].airport_get();

      cc.save();
      cc.translate(_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight);
      cc.fillStyle = this.theme.SCOPE.RUNWAY_LABELS;

      for (var i = 0; i < airportModel.runways.length; i++) {
        this._drawRunwayLabel(cc, airportModel.runways[i][0]);

        this._drawRunwayLabel(cc, airportModel.runways[i][1]);
      }

      cc.restore();
    }
    /**
     * Draw scale in the top right corner of the scope
     *
     * @for CanvasController
     * @method _drawCurrentScale
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawCurrentScale",
    value: function _drawCurrentScale(cc) {
      cc.save();
      var offsetX = 35;
      var offsetY = 10;
      var height = 5;
      var length = (0, _core.round)(1 / _CanvasStageModel["default"].scale * 50);
      var px_length = (0, _core.round)(_CanvasStageModel["default"].translateKilometersToPixels(length));
      var widthLessOffset = _CanvasStageModel["default"].width - offsetX;
      cc.font = '10px monoOne, monospace';
      cc.fillStyle = this.theme.SCOPE.TOP_ROW_TEXT;
      cc.strokeStyle = this.theme.SCOPE.TOP_ROW_TEXT;
      cc.translate(0.5, 0.5);
      cc.lineWidth = 1;
      cc.textAlign = 'center';
      cc.beginPath();
      cc.moveTo(widthLessOffset, offsetY);
      cc.lineTo(widthLessOffset, offsetY + height);
      cc.lineTo(widthLessOffset - px_length, offsetY + height);
      cc.lineTo(widthLessOffset - px_length, offsetY);
      cc.stroke();
      cc.translate(-0.5, -0.5);
      cc.fillText("".concat(length, " km"), widthLessOffset - px_length * 0.5, offsetY + height + 17);
      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawSingleFixAndLabel
     * @param cc {HTMLCanvasContext}
     * @param fixName {string}              name of a fix
     * @param fixPosition {array<number>}   x, y canvas position of fix
     * @private
     */

  }, {
    key: "_drawSingleFixAndLabel",
    value: function _drawSingleFixAndLabel(cc, fixModel) {
      var fixPosition = _CanvasStageModel["default"].translatePostionModelToRoundedCanvasPosition(fixModel.relativePosition);

      cc.save();
      cc.translate(fixPosition.x, fixPosition.y);
      cc.fillStyle = this.theme.SCOPE.FIX_FILL;
      cc.globalCompositeOperation = 'source-over';
      cc.lineWidth = 1;
      cc.beginPath();
      cc.moveTo(0, -5);
      cc.lineTo(4, 3);
      cc.lineTo(-4, 3);
      cc.closePath();
      cc.fill();
      cc.fillStyle = this.theme.SCOPE.FIX_TEXT;
      cc.textAlign = 'center';
      cc.textBaseline = 'top';
      cc.fillText(fixModel.name, 0, 6);
      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawAirportFixesAndLabels
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawAirportFixesAndLabels",
    value: function _drawAirportFixesAndLabels(cc) {
      if (!this._shouldDrawFixLabels) {
        return;
      }

      cc.save();
      cc.translate(_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight);
      cc.lineJoin = 'round';
      cc.font = _canvasConstants.BASE_CANVAS_FONT;

      for (var i = 0; i < _NavigationLibrary["default"].realFixes.length; i++) {
        var fixModel = _NavigationLibrary["default"].realFixes[i];

        this._drawSingleFixAndLabel(cc, fixModel);
      }

      cc.restore();
    } // TODO: break this method up into smaller chunks

    /**
     * @for CanvasController
     * @method _drawSids
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawSids",
    value: function _drawSids(cc) {
      if (!this._shouldDrawSidMap) {
        return;
      }

      var textAtFix = [];

      var sidLines = _NavigationLibrary["default"].getProcedureLines(_routeConstants.PROCEDURE_TYPE.SID);

      cc.save();
      cc.translate(_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight);
      cc.strokeStyle = this.theme.SCOPE.SID;
      cc.fillStyle = this.theme.SCOPE.SID;
      cc.setLineDash([1, 10]);
      cc.font = 'italic 14px monoOne, monospace';

      for (var i = 0; i < sidLines.length; i++) {
        var sid = sidLines[i];
        var shouldDrawProcedureName = true;

        for (var j = 0; j < sid.lines.length; j++) {
          this._drawLine(cc, sid.lines[j]);
        }

        for (var _j = 0; _j < sid.exits.length; _j++) {
          var exitName = sid.exits[_j];

          if (!(exitName in textAtFix)) {
            textAtFix[exitName] = [];
          }

          textAtFix[exitName].push("".concat(sid.identifier, ".").concat(exitName));
          shouldDrawProcedureName = false;
        }

        if (shouldDrawProcedureName) {
          var lastFixName = sid.lastFixName;

          if (!(lastFixName in textAtFix)) {
            textAtFix[lastFixName] = [];
          }

          textAtFix[lastFixName].push(sid.identifier);
        }
      } // draw labels


      for (var fix in textAtFix) {
        var textItemsToPrint = textAtFix[fix];

        var fixPosition = _NavigationLibrary["default"].getFixRelativePosition(fix);

        this._drawText(cc, fixPosition, textItemsToPrint);
      }

      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawStars
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawStars",
    value: function _drawStars(cc) {
      if (!this._shouldDrawStarMap) {
        return;
      }

      var starLines = _NavigationLibrary["default"].getProcedureLines(_routeConstants.PROCEDURE_TYPE.STAR);

      var textAtFix = [];
      cc.save();
      cc.translate(_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight);
      cc.strokeStyle = this.theme.SCOPE.STAR;
      cc.fillStyle = this.theme.SCOPE.STAR;
      cc.setLineDash([1, 10]);
      cc.font = 'italic 14px monoOne, monospace';
      cc.textAlign = 'right';

      for (var i = 0; i < starLines.length; i++) {
        var star = starLines[i];

        for (var j = 0; j < star.lines.length; j++) {
          this._drawLine(cc, star.lines[j]);
        }

        var firstFixName = star.firstFixName;

        if (!(firstFixName in textAtFix)) {
          textAtFix[firstFixName] = [];
        }

        textAtFix[firstFixName].push(star.identifier);
      } // draw labels


      for (var fix in textAtFix) {
        var textItemsToPrint = textAtFix[fix];

        var fixPosition = _NavigationLibrary["default"].getFixRelativePosition(fix);

        this._drawText(cc, fixPosition, textItemsToPrint);
      }

      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawLine
     * @param cc {HTMLCanvasContext}
     * @param points {array of array<number, number>} position coordinates (in km)
     * @private
     */

  }, {
    key: "_drawLine",
    value: function _drawLine(cc, points) {
      if (points.length < 2) {
        return;
      }

      var lineStartPosition = _CanvasStageModel["default"].translatePostionModelToRoundedCanvasPosition(points[0]);

      cc.beginPath();
      cc.moveTo(lineStartPosition.x, lineStartPosition.y);

      for (var k = 0; k < points.length; k++) {
        var position = points[k];

        var positionInPx = _CanvasStageModel["default"].translatePostionModelToRoundedCanvasPosition(position);

        cc.lineTo(positionInPx.x, positionInPx.y);
      }

      cc.stroke();
    } // TODO: This method requires that we translate the canvas to the center, WITHOUT correcting for pan.
    // This is the opposite of what _drawPoly does, and there is real advantage to the differing strategies.
    // They should both be made to behave in the same way, probably by translating to center, and adjusting
    // for pan within _drawPoly or _drawText itself, to make the usage in _drawFixes etc more intuitive.

    /**
     * @for CanvasController
     * @method _drawText
     * @param cc {HTMLCanvasContext}
     * @param position {array<number, number>} position coordinates (in km)
     * @param labels {array}
     * @param lineHeight {number} in pixel
     * @private
     */

  }, {
    key: "_drawText",
    value: function _drawText(cc, position, labels) {
      var lineHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 15;

      var positionInPx = _CanvasStageModel["default"].translatePostionModelToRoundedCanvasPosition(position);

      var dx = cc.textAlign === 'right' ? -10 : 10;

      if (cc.textAlign === 'center') {
        dx = 0;
      }

      for (var k = 0; k < labels.length; k++) {
        var textItem = labels[k];
        var positionX = positionInPx.x + dx;
        var positionY = positionInPx.y + lineHeight * k;
        cc.fillText(textItem, positionX, positionY);
      }
    }
    /**
     * Draw a trailing indicator 2.5 NM (4.6km) behind landing aircraft to help with traffic spacing
     *
     * @for CanvasController
     * @method _drawSeparationIndicator
     * @param cc {HTMLCanvasContext}
     * @param aircraftModel {AircraftModel}
     * @private
     */

  }, {
    key: "_drawSeparationIndicator",
    value: function _drawSeparationIndicator(cc, aircraftModel) {
      if (!_GameController["default"].shouldUseTrailingSeparationIndicator(aircraftModel)) {
        return;
      }

      var runway = aircraftModel.fms.arrivalRunwayModel;
      var oppositeOfRunwayHeading = runway.oppositeAngle;

      var aircraftCanvasPosition = _CanvasStageModel["default"].translatePostionModelToRoundedCanvasPosition(aircraftModel.relativePosition);

      cc.strokeStyle = this.theme.RADAR_TARGET.TRAILING_SEPARATION_INDICATOR;
      cc.lineWidth = 3;
      cc.translate(aircraftCanvasPosition.x, aircraftCanvasPosition.y);
      cc.rotate(oppositeOfRunwayHeading);
      cc.beginPath(); // TODO: this should use constants

      cc.moveTo(-5, -_CanvasStageModel["default"].translateKilometersToPixels(5.556)); // 5.556km = 3.0nm

      cc.lineTo(+5, -_CanvasStageModel["default"].translateKilometersToPixels(5.556)); // 5.556km = 3.0nm

      cc.stroke();
    }
    /**
     * Draws circle around aircraft that are in (or soon to be in) conflict with another aircraft
     *
     * These rings are drawn independently of user-set halos
     *
     * @for CanvasController
     * @method _drawAircraftConflictRings
     * @param cc {HTMLCanvasContext}
     * @param radarTargetModel {RadarTargetModel}
     * @private
     */

  }, {
    key: "_drawAircraftConflictRings",
    value: function _drawAircraftConflictRings(cc, radarTargetModel) {
      var aircraftModel = radarTargetModel.aircraftModel;
      var aircraftAlerts = aircraftModel.getAlerts();
      var radiusNm = 3;

      if (!aircraftAlerts[0]) {
        return;
      }

      var strokeStyle = this.theme.RADAR_TARGET.RING_CONFLICT;

      if (aircraftAlerts[1]) {
        strokeStyle = this.theme.RADAR_TARGET.RING_VIOLATION;
      }

      cc.strokeStyle = strokeStyle;
      cc.beginPath();
      cc.arc(0, 0, _CanvasStageModel["default"].translateKilometersToPixels((0, _unitConverters.km)(radiusNm)), 0, (0, _circle.tau)());
      cc.stroke();
    }
    /**
     * Draws circle around aircraft with radius as requested by the user
     *
     * @for CanvasController
     * @method _drawAircraftHalo
     * @param cc {HTMLCanvasContext}
     * @param radarTargetModel {RadarTargetModel}
     */

  }, {
    key: "_drawAircraftHalo",
    value: function _drawAircraftHalo(cc, radarTargetModel) {
      if (!radarTargetModel.hasHalo) {
        return;
      }

      var radiusNm = radarTargetModel.haloRadius;
      cc.strokeStyle = this.theme.RADAR_TARGET.HALO;
      cc.beginPath();
      cc.arc(0, 0, _CanvasStageModel["default"].translateKilometersToPixels((0, _unitConverters.km)(radiusNm)), 0, (0, _circle.tau)());
      cc.stroke();
    }
    /**
     * Draw the RADAR RETURN AND HISTORY DOTS ONLY of the specified radar target model
     *
     * @for CanvasController
     * @method _drawSingleRadarTarget
     * @param cc {HTMLCanvasContext}
     * @param radarTargetModel {RadarTargetModel}
     * @private
     */

  }, {
    key: "_drawSingleRadarTarget",
    value: function _drawSingleRadarTarget(cc, radarTargetModel) {
      var aircraftModel = radarTargetModel.aircraftModel; // TODO: death to the `prop`!!!

      var match = prop.input.callsign.length > 0 && aircraftModel.matchCallsign(prop.input.callsign);
      var fillStyle = this.theme.RADAR_TARGET.HISTORY_DOT_OUTSIDE_RANGE;

      if (!aircraftModel.isVisible()) {
        return;
      }

      cc.save();

      if (aircraftModel.isControllable) {
        fillStyle = this.theme.RADAR_TARGET.HISTORY_DOT_INSIDE_RANGE;
      }

      cc.fillStyle = fillStyle;
      var positionHistory = aircraftModel.relativePositionHistory;

      for (var i = 0; i < positionHistory.length; i++) {
        var position = aircraftModel.relativePositionHistory[i];

        var canvasPosition = _CanvasStageModel["default"].translatePostionModelToPreciseCanvasPosition(position);

        cc.beginPath();
        cc.arc(canvasPosition.x, canvasPosition.y, _CanvasStageModel["default"].translateKilometersToPixels(this.theme.RADAR_TARGET.HISTORY_DOT_RADIUS_KM), 0, (0, _circle.tau)());
        cc.closePath();
        cc.fill();
      }

      cc.restore();

      if (positionHistory.length > this.theme.RADAR_TARGET.HISTORY_LENGTH) {
        // TODO: This slice is being reassigned to the aircraft, which doesn't really
        // make sense as a canvas controller job. This should be done elsewhere.
        aircraftModel.relativePositionHistory = positionHistory.slice(positionHistory.length - this.theme.RADAR_TARGET.HISTORY_LENGTH, positionHistory.length);
      }

      if (aircraftModel.isEstablishedOnCourse()) {
        cc.save();

        this._drawSeparationIndicator(cc, aircraftModel);

        cc.restore();
      } // Draw the future path


      switch (_GameController["default"].game.option.getOptionByName('drawProjectedPaths')) {
        case 'always':
          this._drawAircraftFuturePath(cc, aircraftModel);

          break;

        case 'selected':
          if (match) {
            this._drawAircraftFuturePath(cc, aircraftModel);
          }

          break;

        default:
          break;
      }

      var aircraftCanvasPosition = _CanvasStageModel["default"].translatePostionModelToPreciseCanvasPosition(aircraftModel.relativePosition);

      cc.translate(aircraftCanvasPosition.x, aircraftCanvasPosition.y);

      this._drawAircraftVectorLines(cc, aircraftModel);

      this._drawAircraftHalo(cc, radarTargetModel);

      this._drawAircraftConflictRings(cc, radarTargetModel);

      var radarTargetRadiusKm = this.theme.RADAR_TARGET.RADIUS_KM; // Draw bigger circle around radar target when the aircraftModel is selected

      if (match) {
        radarTargetRadiusKm = this.theme.RADAR_TARGET.RADIUS_SELECTED_KM;
      } // Draw the radar target (aka aircraft position dot)


      cc.fillStyle = this.theme.RADAR_TARGET.RADAR_TARGET;
      cc.beginPath();
      cc.arc(0, 0, _CanvasStageModel["default"].translateKilometersToPixels(radarTargetRadiusKm), 0, (0, _circle.tau)());
      cc.fill();
    }
    /**
     * Draw aircraft vector lines (projected track lines or PTL)
     *
     * Note: These extend in front of aircraft a definable number of minutes
     *
     * @for CanvasController
     * @method _drawAircraftVectorLines
     * @param cc {HTMLCanvasContext}
     * @param aircraft {AircraftModel}
     * @private
     */

  }, {
    key: "_drawAircraftVectorLines",
    value: function _drawAircraftVectorLines(cc, aircraft) {
      if (aircraft.hit) {
        return;
      }

      cc.save();
      cc.fillStyle = this.theme.RADAR_TARGET.PROJECTED_TRACK_LINES;
      cc.strokeStyle = this.theme.RADAR_TARGET.PROJECTED_TRACK_LINES;
      var lineLengthInMinutes = this._scopeModel.ptlLength;
      var lineLengthInHours = lineLengthInMinutes * _globalConstants.TIME.ONE_MINUTE_IN_HOURS;
      var lineLength_km = (0, _unitConverters.km)(aircraft.groundSpeed * lineLengthInHours);
      var groundTrackVector = (0, _vector.vectorize2dFromRadians)(aircraft.groundTrack);
      var scaledGroundTrackVector = (0, _vector.vscale)(groundTrackVector, lineLength_km);

      var screenPositionOffsetX = _CanvasStageModel["default"].translateKilometersToPixels(scaledGroundTrackVector[0]);

      var screenPositionOffsetY = _CanvasStageModel["default"].translateKilometersToPixels(scaledGroundTrackVector[1]);

      cc.beginPath();
      cc.moveTo(0, 0);
      cc.lineTo(screenPositionOffsetX, -screenPositionOffsetY);
      cc.stroke();
      cc.restore();
    } // TODO: This is currently not working correctly and not in use

    /**
     * Draw dashed line from last coordinate of future track through
     * any later requested fixes.
     *
     * @for CanvasController
     * @method canvas_draw_future_track_fixes
     * @param cc {HTMLCanvasContext}
     * @param aircraft {AircraftModel}
     * @param future_track
     */

  }, {
    key: "canvas_draw_future_track_fixes",
    value: function canvas_draw_future_track_fixes()
    /* cc, aircraft, future_track */
    {} // const waypointList = aircraft.fms.waypoints;
    //
    // if (waypointList.length <= 1) {
    //     return;
    // }
    // const start = future_track.length - 1;
    // const x = CanvasStageModel.translateKilometersToPixels(future_track[start][0]) + CanvasStageModel._panX;
    // const y = -CanvasStageModel.translateKilometersToPixels(future_track[start][1]) + CanvasStageModel._panY;
    //
    // cc.beginPath();
    // cc.moveTo(x, y);
    // cc.setLineDash([3, 10]);
    //
    // for (let i = 0; i < waypointList.length; i++) {
    //     const [x, y] = waypointList[i].relativePosition;
    //     const fx = CanvasStageModel.translateKilometersToPixels(x) + CanvasStageModel._panX;
    //     const fy = -CanvasStageModel.translateKilometersToPixels(y) + CanvasStageModel._panY;
    //
    //     cc.lineTo(fx, fy);
    // }
    //
    // cc.stroke();

    /**
     * Run physics updates into the future, draw future track
     *
     * @for CanvasController
     * @method _drawAircraftFuturePath
     * @param cc {HTMLCanvasContext}
     * @param aircraft {AircraftModel}
     * @private
     */

  }, {
    key: "_drawAircraftFuturePath",
    value: function _drawAircraftFuturePath(cc, aircraft) {
      if (aircraft.isTaxiing() || _TimeKeeper["default"].simulationRate !== 1) {
        return;
      }

      var was_locked = false;
      var future_track = [];
      var fms_twin = (0, _cloneDeep2["default"])(aircraft.fms);
      var twin = (0, _cloneDeep2["default"])(aircraft);
      twin.fms = fms_twin;
      twin.projected = true;

      _TimeKeeper["default"].saveDeltaTimeBeforeFutureTrackCalculation();

      for (var i = 0; i < 60; i++) {
        twin.update();

        var ils_locked = twin.isEstablishedOnCourse() && twin.fms.currentPhase === _aircraftConstants.FLIGHT_PHASE.APPROACH;

        future_track.push([].concat(_toConsumableArray(twin.relativePosition), [ils_locked]));

        if (ils_locked && twin.altitude < 500) {
          break;
        }
      }

      _TimeKeeper["default"].restoreDeltaTimeAfterFutureTrackCalculation();

      cc.save();
      var strokeStyle = this.theme.RADAR_TARGET.PROJECTION_ARRIVAL; // future track colors

      if (aircraft.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
        strokeStyle = this.theme.RADAR_TARGET.PROJECTION_DEPARTURE;
      }

      cc.strokeStyle = strokeStyle;
      cc.globalCompositeOperation = 'screen';
      cc.lineWidth = 2;
      cc.beginPath();

      for (var _i2 = 0; _i2 < future_track.length; _i2++) {
        var track = future_track[_i2];
        var _ils_locked = track[2];

        var trackPosition = _CanvasStageModel["default"].translatePostionModelToPreciseCanvasPosition(track);

        if (_ils_locked && !was_locked) {
          cc.lineTo(trackPosition.x, trackPosition.y); // end the current path, start a new path with lockedStroke

          cc.stroke();
          cc.strokeStyle = this.theme.RADAR_TARGET.PROJECTION_ESTABLISHED_ON_APPROACH;
          cc.lineWidth = 3;
          cc.beginPath();
          cc.moveTo(trackPosition.x, trackPosition.y);
          was_locked = true;
          continue;
        }

        if (_i2 === 0) {
          cc.moveTo(trackPosition.x, trackPosition.y);
        } else {
          cc.lineTo(trackPosition.x, trackPosition.y);
        }
      }

      cc.stroke(); // TODO: following method not in use, leaving for posterity
      // this.canvas_draw_future_track_fixes(cc, twin, future_track);

      cc.restore();
    }
    /**
     * Draw the `MeasureTool` path and text labels
     *
     * @for CanvasController
     * @method _drawMeasureTool
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawMeasureTool",
    value: function _drawMeasureTool(cc) {
      var _this2 = this;

      if (!_MeasureTool["default"].hasPaths) {
        return;
      }

      var pathInfoList = _MeasureTool["default"].buildPathInfo();

      cc.save();
      cc.translate(_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight);
      pathInfoList.forEach(function (pathInfo) {
        _this2._drawMeasureToolPath(cc, pathInfo);

        _this2._drawMeasureToolLabels(cc, pathInfo);
      });
      cc.restore();
    }
    /**
     * Draw the `MeasureTool` text labels
     *
     * @for CanvasController
     * @method _drawMeasureToolLabels
     * @param cc {HTMLCanvasContext}
     * @param pathInfo {object} as returned by `MeasureTools.getPointsAndLabels()`
     * @private
     */

  }, {
    key: "_drawMeasureToolLabels",
    value: function _drawMeasureToolLabels(cc, pathInfo) {
      var leg = pathInfo.firstLeg;
      var values = [];
      var labelPadding = 5; // This way the points are translated only once

      while (leg != null) {
        // Ignore empty labels
        if (leg.labels !== null && leg.labels.length !== 0) {
          var position = _CanvasStageModel["default"].translatePostionModelToPreciseCanvasPosition(leg.midPoint);

          values.push({
            x: position.x,
            y: position.y,
            labels: leg.labels
          });
        }

        leg = leg.next;
      } // Shortcut if there are no labels (line is too short)


      if (values.length === 0) {
        return;
      } // Label backgrounds


      cc.fillStyle = this.theme.SCOPE.MEASURE_BACKGROUND;
      cc.font = this.theme.DATA_BLOCK.TEXT_FONT;
      values.forEach(function (item) {
        var x = item.x,
            y = item.y,
            labels = item.labels;
        var height = 2 * labelPadding + 12 * labels.length;
        var maxLabelWidth = labels.reduce(function (lastWidth, label) {
          var newWidth = cc.measureText(label).width;
          return Math.max(lastWidth, newWidth);
        }, 0);
        var width = 2 * labelPadding + maxLabelWidth;
        cc.fillRect(x, y, width, height);
      }); // Label text

      cc.fillStyle = this.theme.SCOPE.MEASURE_TEXT;
      values.forEach(function (item) {
        var labels = item.labels;
        var x = item.x + labelPadding;
        var y = item.y + 15;
        labels.forEach(function (line, index) {
          cc.fillText(line, x, y + 12 * index);
        });
      });
    }
    /**
     * Draw the `MeasureTool` path
     *
     * @for CanvasController
     * @method _drawMeasureToolPath
     * @param cc {HTMLCanvasContext}
     * @param pathInfo {object} as returned by `MeasureTools.getPointsAndLabels()`
     * @private
     */

  }, {
    key: "_drawMeasureToolPath",
    value: function _drawMeasureToolPath(cc, pathInfo) {
      var initialTurn = pathInfo.initialTurn;
      var leg = pathInfo.firstLeg;

      var firstPoint = _CanvasStageModel["default"].translatePostionModelToPreciseCanvasPosition(leg.startPoint);

      var firstMidPoint = _CanvasStageModel["default"].translatePostionModelToPreciseCanvasPosition(leg.midPoint);

      cc.strokeStyle = this.theme.SCOPE.MEASURE_LINE;
      cc.beginPath(); // If available, this draws the arc the a/c will fly to intercept the course to the
      // first fix

      if (initialTurn !== null) {
        var isRHT = initialTurn.isRHT,
            center = initialTurn.center,
            entryAngle = initialTurn.entryAngle,
            exitAngle = initialTurn.exitAngle,
            turnRadius = initialTurn.turnRadius;

        var position = _CanvasStageModel["default"].translatePostionModelToPreciseCanvasPosition(center);

        var radius = _CanvasStageModel["default"].translateKilometersToPixels(turnRadius); // The angles calculated in the `MeasureTool` are magnetic, and have to be shifted CCW 90°


        cc.arc(position.x, position.y, radius, entryAngle - Math.PI / 2, exitAngle - Math.PI / 2, !isRHT);
      } // Draw up to the first midpoint


      cc.moveTo(firstPoint.x, firstPoint.y);
      cc.lineTo(firstMidPoint.x, firstMidPoint.y); // Iterate through the linked list

      while (leg != null) {
        var _leg = leg,
            next = _leg.next;

        var _radius = _CanvasStageModel["default"].translateKilometersToPixels(leg.radius);

        var position1 = _CanvasStageModel["default"].translatePostionModelToPreciseCanvasPosition(leg.endPoint);

        if (next === null) {
          // This is the last leg, so simply draw to the end point
          cc.lineTo(position1.x, position1.y);
        } else {
          // Draw an arc'd line to the next midpoint
          var position2 = _CanvasStageModel["default"].translatePostionModelToPreciseCanvasPosition(next.midPoint);

          cc.arcTo(position1.x, position1.y, position2.x, position2.y, _radius);
          cc.lineTo(position2.x, position2.y);
        }

        leg = next;
      }

      cc.stroke();
    }
    /**
     * Draw the RADAR RETURN AND HISTORY DOTS ONLY of all radar target models
     *
     * @for CanvasController
     * @method _drawRadarTargetList
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawRadarTargetList",
    value: function _drawRadarTargetList(cc) {
      cc.font = _canvasConstants.BASE_CANVAS_FONT;
      cc.save();
      cc.translate(_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight);
      var radarTargetModels = this._scopeModel.radarTargetCollection.items;

      for (var i = 0; i < radarTargetModels.length; i++) {
        cc.save();

        this._drawSingleRadarTarget(cc, radarTargetModels[i]);

        cc.restore();
      }

      cc.restore();
    }
    /**
     * Draw an aircraft's data block
     * (box that contains callsign, altitude, speed)
     *
     * @for CanvasController
     * @method _drawSingleAircraftDataBlock
     * @param cc {HTMLCanvasContext}
     * @param radarTargetModel {RadarTargetModel}
     * @private
     */

  }, {
    key: "_drawSingleAircraftDataBlock",
    value: function _drawSingleAircraftDataBlock(cc, radarTargetModel) {
      var aircraftModel = radarTargetModel.aircraftModel;

      if (!aircraftModel.isVisible() || aircraftModel.hit) {
        return;
      }

      cc.save();
      var paddingLR = 5;
      var match = false; // Callsign Matching

      if (prop.input.callsign.length > 0 && aircraftModel.matchCallsign(prop.input.callsign)) {
        match = true;
      }

      var white = aircraftModel.isControllable ? this.theme.DATA_BLOCK.TEXT_IN_RANGE : this.theme.DATA_BLOCK.TEXT_OUT_OF_RANGE;

      if (match) {
        white = this.theme.DATA_BLOCK.TEXT_SELECTED;
      }

      cc.textBaseline = 'middle';
      var dataBlockLeaderDirection = radarTargetModel.dataBlockLeaderDirection;

      if (dataBlockLeaderDirection === _globalConstants.INVALID_NUMBER) {
        dataBlockLeaderDirection = this.theme.DATA_BLOCK.LEADER_DIRECTION;
      }

      var offsetComponent = [Math.sin((0, _unitConverters.degreesToRadians)(dataBlockLeaderDirection)), -Math.cos((0, _unitConverters.degreesToRadians)(dataBlockLeaderDirection))]; // `degreesToRadians('ctr')` above will yield NaN, so we override that here

      if (dataBlockLeaderDirection === 'ctr') {
        offsetComponent = [0, 0];
      } // Move to center of where the data block is to be drawn


      var radarTargetPositionX = (0, _core.round)(_CanvasStageModel["default"].translateKilometersToPixels(aircraftModel.relativePosition[0])) + _CanvasStageModel["default"]._panX;

      var radarTargetPositionY = -(0, _core.round)(_CanvasStageModel["default"].translateKilometersToPixels(aircraftModel.relativePosition[1])) + _CanvasStageModel["default"]._panY;
      var radarTargetPosition = [radarTargetPositionX, radarTargetPositionY];

      var leaderLength = this._calculateLeaderLength(radarTargetModel.dataBlockLeaderLength);

      var leaderStart = [radarTargetPosition[0] + offsetComponent[0] * this.theme.DATA_BLOCK.LEADER_PADDING_FROM_TARGET_PX, radarTargetPosition[1] + offsetComponent[1] * this.theme.DATA_BLOCK.LEADER_PADDING_FROM_TARGET_PX];
      var leaderEnd = [radarTargetPosition[0] + offsetComponent[0] * (leaderLength - this.theme.DATA_BLOCK.LEADER_PADDING_FROM_BLOCK_PX), radarTargetPosition[1] + offsetComponent[1] * (leaderLength - this.theme.DATA_BLOCK.LEADER_PADDING_FROM_BLOCK_PX)];
      var leaderIntersectionWithBlock = [radarTargetPosition[0] + offsetComponent[0] * leaderLength, radarTargetPosition[1] + offsetComponent[1] * leaderLength];
      cc.beginPath();
      cc.moveTo.apply(cc, leaderStart);
      cc.lineTo.apply(cc, leaderEnd);
      cc.strokeStyle = white;
      cc.stroke();
      var dataBlockCenter = radarTargetModel.calculateDataBlockCenter(leaderIntersectionWithBlock);
      cc.translate.apply(cc, _toConsumableArray(dataBlockCenter));

      this._drawLegacyDatablock(cc, aircraftModel); // height of TOTAL vertical space between the rows (0 for touching)


      var gap = 3;
      var lineheight = 4.5; // height of text row (used for spacing basis)

      var row1text = radarTargetModel.buildDataBlockRowOne();
      var row2text = radarTargetModel.buildDataBlockRowTwoPrimaryInfo();

      if (this.shouldShowSecondaryDataBlock()) {
        row2text = radarTargetModel.buildDataBlockRowTwoSecondaryInfo();
      }

      var fillStyle = aircraftModel.isControllable ? this.theme.DATA_BLOCK.TEXT_IN_RANGE : this.theme.DATA_BLOCK.TEXT_OUT_OF_RANGE;
      cc.fillStyle = fillStyle; // Draw full datablock text

      cc.font = this.theme.DATA_BLOCK.TEXT_FONT;
      cc.textAlign = 'left';
      cc.fillText(row1text, -this.theme.DATA_BLOCK.HALF_WIDTH + paddingLR, -gap / 2 - lineheight);
      cc.fillText(row2text, -this.theme.DATA_BLOCK.HALF_WIDTH + paddingLR, gap / 2 + lineheight);
      cc.font = _canvasConstants.BASE_CANVAS_FONT;
      cc.restore();
    }
    /**
     * Draw the legacy dataBlock
     *
     * @for CanvasController
     * @method
     * @param {HTML CanvasContext} cc
     * @param {AircraftModel} RadarTargetModel#aircraftModel
     */

  }, {
    key: "_drawLegacyDatablock",
    value: function _drawLegacyDatablock(cc, aircraftModel) {
      if (!this.theme.DATA_BLOCK.HAS_FILL) {
        return;
      } // TODO: logic and math here should be done once and not every frame. this could be moved to the `RadarTargetModel`
      // width of datablock (scales to fit callsign)


      var width = this.theme.DATA_BLOCK.WIDTH; // clamp(1, 6 * callsign.length) + (paddingLR * 2);

      var halfWidth = this.theme.DATA_BLOCK.HALF_WIDTH; // width / 2;
      // height of datablock

      var height = this.theme.DATA_BLOCK.HEIGHT; // 31;

      var halfHeight = this.theme.DATA_BLOCK.HALF_HEIGHT; // height / 2;
      // width of colored bar

      var barWidth = 3;
      var barHalfWidth = barWidth / 2; // const ILS_enabled = aircraftModel.pilot.hasApproachClearance;

      var lock_size = height / 3;
      var lock_offset = lock_size / 8;
      var point1 = lock_size - barHalfWidth;
      var a = point1 - lock_offset;
      var b = barHalfWidth;
      var clipping_mask_angle = Math.atan(b / a); // describes how far around to arc the arms of the ils lock case

      var pi_slice = Math.PI / 24;
      var match = false; // Callsign Matching

      if (prop.input.callsign.length > 0 && aircraftModel.matchCallsign(prop.input.callsign)) {
        match = true;
      } // set color, intensity, and style elements


      var red = this.theme.DATA_BLOCK.ARRIVAL_BAR_OUT_OF_RANGE;
      var green = this.theme.DATA_BLOCK.BACKGROUND_OUT_OF_RANGE;
      var blue = this.theme.DATA_BLOCK.DEPARTURE_BAR_OUT_OF_RANGE;
      var white = this.theme.DATA_BLOCK.TEXT_OUT_OF_RANGE;

      if (aircraftModel.isControllable) {
        red = this.theme.DATA_BLOCK.ARRIVAL_BAR_IN_RANGE;
        green = this.theme.DATA_BLOCK.BACKGROUND_IN_RANGE;
        blue = this.theme.DATA_BLOCK.DEPARTURE_BAR_IN_RANGE;
        white = this.theme.DATA_BLOCK.TEXT_IN_RANGE;

        if (match) {
          red = this.theme.DATA_BLOCK.ARRIVAL_BAR_SELECTED;
          green = this.theme.DATA_BLOCK.BACKGROUND_SELECTED;
          blue = this.theme.DATA_BLOCK.DEPARTURE_BAR_SELECTED;
          white = this.theme.DATA_BLOCK.TEXT_SELECTED;
        }
      } // Draw datablock shapes


      if (!aircraftModel.pilot.hasApproachClearance && this.theme.DATA_BLOCK.HAS_FILL) {
        // data block box background fill
        cc.fillStyle = green;
        cc.fillRect(-halfWidth, -halfHeight, width, height); // Draw colored bar

        cc.fillStyle = aircraftModel.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE ? blue : red;
        cc.fillRect(-halfWidth - barWidth, -halfHeight, barWidth, height);
        return;
      } // Box with ILS Lock Indicator


      cc.save(); // Draw green part of box (excludes space where ILS Clearance Indicator juts in)

      cc.fillStyle = green;
      cc.beginPath();
      cc.moveTo(-halfWidth, halfHeight); // bottom-left corner

      cc.lineTo(halfWidth, halfHeight); // bottom-right corner

      cc.lineTo(halfWidth, -halfHeight); // top-right corner

      cc.lineTo(-halfWidth, -halfHeight); // top-left corner

      cc.lineTo(-halfWidth, -point1); // begin side cutout

      cc.arc(-halfWidth - barHalfWidth, -lock_offset, lock_size / 2 + barHalfWidth, clipping_mask_angle - Math.PI / 2, 0);
      cc.lineTo(-halfWidth + lock_size / 2, lock_offset);
      cc.arc(-halfWidth - barHalfWidth, lock_offset, lock_size / 2 + barHalfWidth, 0, Math.PI / 2 - clipping_mask_angle);
      cc.closePath();
      cc.fill(); // Draw ILS Clearance Indicator

      cc.translate(-halfWidth - barHalfWidth, 0);
      cc.lineWidth = barWidth;
      cc.strokeStyle = red;
      cc.beginPath(); // top arc start

      cc.arc(0, -lock_offset, lock_size / 2, -pi_slice, Math.PI + pi_slice, true);
      cc.moveTo(0, -lock_size / 2);
      cc.lineTo(0, -halfHeight);
      cc.stroke(); // top arc end

      cc.beginPath(); // bottom arc start

      cc.arc(0, lock_offset, lock_size / 2, pi_slice, Math.PI - pi_slice);
      cc.moveTo(0, lock_size - barWidth);
      cc.lineTo(0, halfHeight);
      cc.stroke(); // bottom arc end

      if (aircraftModel.isEstablishedOnCourse()) {
        // Localizer Capture Indicator
        cc.fillStyle = white;
        cc.beginPath();
        cc.arc(0, 0, lock_size / 5, 0, Math.PI * 2);
        cc.fill(); // Draw Localizer Capture Dot
      }

      cc.translate(halfWidth + barHalfWidth, 0); // unclear how this works...

      cc.beginPath(); // if removed, white lines appear on top of bottom half of lock case

      cc.stroke(); // if removed, white lines appear on top of bottom half of lock case

      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawAircraftDataBlocks
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawAircraftDataBlocks",
    value: function _drawAircraftDataBlocks(cc) {
      var radarTargetModels = this._scopeModel.radarTargetCollection.items;
      cc.save();
      cc.translate(_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight);

      for (var i = 0; i < radarTargetModels.length; i++) {
        this._drawSingleAircraftDataBlock(cc, radarTargetModels[i]);
      }

      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawAirspaceAndRangeRings
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawAirspaceAndRangeRings",
    value: function _drawAirspaceAndRangeRings(cc) {
      var airport = _AirportController["default"].airport_get();

      var rangeRingRadius = this._calculateRangeRingRadius(airport);

      cc.save(); // translate to airport center
      // TODO: create method in CanvasStageModel to returns an array with these values

      cc.translate((0, _core.round)(_CanvasStageModel["default"].halfWidth + _CanvasStageModel["default"]._panX), (0, _core.round)(_CanvasStageModel["default"].halfHeight + _CanvasStageModel["default"]._panY)); // draw airspaces

      for (var i = 0; i < airport.airspace.length; i++) {
        var airspace = airport.airspace[i];
        cc.save();
        cc.strokeStyle = this.theme.SCOPE.AIRSPACE_PERIMETER;
        cc.fillStyle = this.theme.SCOPE.AIRSPACE_FILL;

        this._drawPoly(cc, airspace.relativePoly, false); // prevent infinite loop when rangeRingRadius is 0


        if (rangeRingRadius > 0) {
          cc.clip(); // cc.linewidth = 1;

          cc.strokeStyle = this.theme.SCOPE.RANGE_RING_COLOR; // Fill up airportModel's ctr_radius with rings of the specified radius

          for (var _i3 = 1; _i3 * rangeRingRadius < airport.ctr_radius; _i3++) {
            cc.beginPath();
            cc.arc(0, 0, rangeRingRadius * _CanvasStageModel["default"].scale * _i3, 0, (0, _circle.tau)());
            cc.stroke();
          }
        }

        cc.restore();
      } // this._drawAirspaceShelvesAndLabels(cc);


      cc.restore();
    }
  }, {
    key: "_drawAirspaceShelvesAndLabels",
    value: function _drawAirspaceShelvesAndLabels(cc) {
      if (!this._shouldDrawAirspace) {
        return;
      }

      cc.save();

      var airport = _AirportController["default"].airport_get();

      cc.strokeStyle = 'rgba(224, 128, 128, 1.0)';
      cc.fillStyle = 'rgba(224, 128, 128, 1.0)';
      cc.font = '12px monoOne, monospace';
      cc.textAlign = 'center';
      cc.textBaseline = 'middle';

      for (var i = 0; i < airport.airspace.length; i++) {
        var airspace = airport.airspace[i];
        cc.save(); // to allow reset of translation
        // required positioning to use _drawPoly

        cc.translate(_CanvasStageModel["default"].halfWidth + _CanvasStageModel["default"]._panX, _CanvasStageModel["default"].halfHeight + _CanvasStageModel["default"]._panY); // draw lines

        this._drawPoly(cc, airspace.relativePoly, false);

        var bottomFlightLevel = (0, _generalUtilities.leftPad)(Math.floor(airspace.floor / 100), 3);
        var topFlightLevel = (0, _generalUtilities.leftPad)(Math.ceil(airspace.ceiling / 100), 3);
        var content = "".concat(bottomFlightLevel, "-").concat(topFlightLevel, " (#").concat(i, ")");
        cc.restore(); // reset from translation used for poly above

        cc.save(); // required positioning to use _drawText

        cc.translate(_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight); // draw labels

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = airspace.labelPositions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var labelPosition = _step.value;

            this._drawText(cc, labelPosition, [content]);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        cc.restore();
      }

      cc.restore();
    }
    /**
     * Calculates the range ring radius
     *
     * @for CanvasController
     * @method _calculateRangeRingRadius
     * @param airport {AirportModel}
     * @private
     */

  }, {
    key: "_calculateRangeRingRadius",
    value: function _calculateRangeRingRadius(airport) {
      var userValue = _GameController["default"].getGameOption(_gameOptionConstants.GAME_OPTION_NAMES.RANGE_RINGS);

      var useDefault = userValue === 'default';
      var defaultRangeRings = airport.rangeRings;

      if (userValue === 'off' || useDefault && defaultRangeRings.enabled === false) {
        return 0;
      }

      if (!useDefault) {
        return (0, _unitConverters.km)(parseInt(userValue, _unitConverters.DECIMAL_RADIX));
      }

      return (0, _unitConverters.km)(defaultRangeRings.radius_nm);
    } // TODO: This method requires that we translate the canvas to the center, WITH correcting for pan.
    // This is the opposite of what _drawText does, and there is real advantage to the differing strategies.
    // They should both be made to behave in the same way, probably by translating to center, and adjusting
    // for pan within _drawPoly or _drawText itself, to make the usage in _drawFixes etc more intuitive.

    /**
     * Draw the provided polygon to the specified canvas
     *
     * This method does not itself provide any specific color/width/etc properties. These must be
     * set prior to calling this method.
     *
     * @for CanvasController
     * @method _drawPoly
     * @param cc {HTMLCanvasContext}
     * @param poly {array<array<number, number>>}
     * @private
     */

  }, {
    key: "_drawPoly",
    value: function _drawPoly(cc, poly) {
      var fill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      cc.beginPath();

      for (var i = 0; i < poly.length; i++) {
        var point = poly[i];
        cc.lineTo(_CanvasStageModel["default"].translateKilometersToPixels(point[0]), -_CanvasStageModel["default"].translateKilometersToPixels(point[1]));
      }

      cc.closePath();
      cc.stroke();

      if (fill) {
        cc.fill();
      }
    }
    /**
     * @param cc {HTMLCanvasContext}
     * @param terrainLevel {object}
     * @param elevation {number}
     * @private
     */

  }, {
    key: "_drawTerrainAtElevation",
    value: function _drawTerrainAtElevation(cc, terrainLevel, elevation) {
      // Here we use HSL colors instead of RGB to enable easier bulk adjustments
      // to saturation/lightness of multiple elevation levels without the need
      // to use web-based color tools
      var color = "hsla(".concat(this.theme.TERRAIN.COLOR[elevation]);
      cc.strokeStyle = "".concat(color, ", ").concat(this.theme.TERRAIN.BORDER_OPACITY, ")");
      cc.fillStyle = "".concat(color, ", ").concat(this.theme.TERRAIN.FILL_OPACITY, ")");

      for (var i = 0; i < terrainLevel.length; i++) {
        var terrainGroup = terrainLevel[i];
        cc.beginPath();

        for (var j = 0; j < terrainGroup.length; j++) {
          var terrainItem = terrainGroup[j];

          for (var k = 0; k < terrainItem.length; k++) {
            if (k === 0) {
              cc.moveTo(_CanvasStageModel["default"].translateKilometersToPixels(terrainItem[k][0]), -_CanvasStageModel["default"].translateKilometersToPixels(terrainItem[k][1]));
            }

            cc.lineTo(_CanvasStageModel["default"].translateKilometersToPixels(terrainItem[k][0]), -_CanvasStageModel["default"].translateKilometersToPixels(terrainItem[k][1]));
          }

          cc.closePath();
        }

        cc.fill();
        cc.stroke();
      }
    }
    /**
     * Draw the terrain legend in the upper right hand corner of the scope view
     *
     * @for CanvasController
     * @method _drawTerrainElevationLegend
     * @param  cc  {HTMLCanvasContext}
     * @param max_elevation {number}
     * @private
     */

  }, {
    key: "_drawTerrainElevationLegend",
    value: function _drawTerrainElevationLegend(cc, max_elevation) {
      cc.save();
      cc.font = _canvasConstants.BASE_CANVAS_FONT;
      cc.lineWidth = 1;
      var offset = 10;
      var width = _CanvasStageModel["default"].width;
      var height = _CanvasStageModel["default"].height;
      var box_width = 30;
      var box_height = 5;

      for (var i = 1000; i <= max_elevation; i += 1000) {
        cc.save(); // translate coordinates for every block to not use these X & Y twice in rect and text
        // .5 in X and Y coordinates are used to make 1px rectangle fit exactly into 1 px
        // and not be blurred

        cc.translate(width / 2 - 140.5 - (max_elevation - i) / 1000 * (box_width + 1), -height / 2 + offset + 0.5);
        cc.beginPath();
        cc.rect(0, 0, box_width - 1, box_height);
        cc.closePath(); // in the map, terrain of higher levels has fill of all the lower levels
        // so we need to fill it below exactly as in the map

        for (var j = 0; j <= i; j += 1000) {
          cc.fillStyle = "rgba(".concat(this.theme.TERRAIN.COLOR[j], ", ").concat(this.theme.TERRAIN.FILL_OPACITY, ")");
          cc.fill();
        }

        cc.strokeStyle = "rgba(".concat(this.theme.TERRAIN.COLOR[i], ", ").concat(this.theme.TERRAIN.BORDER_OPACITY, ")");
        cc.stroke(); // write elevation signs only for the outer elevations

        if (i === max_elevation || i === 1000) {
          cc.fillStyle = this.theme.SCOPE.COMPASS_TEXT;
          cc.textAlign = 'center';
          cc.textBaseline = 'top';
          cc.fillText("".concat(i, "'"), box_width / 2 + 0.5, offset + 2);
        }

        cc.restore();
      }

      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawTerrain
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawTerrain",
    value: function _drawTerrain(cc) {
      var airport = _AirportController["default"].airport_get();

      var airportTerrain = airport.terrain;
      var max_elevation = 0;

      if (!this._shouldDrawTerrain || Object.keys(airportTerrain).length === 0) {
        return;
      }

      cc.save();
      cc.translate(_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight); // Terrain key rectangles' outline stroke color
      // Also determines color of terrain outline drawn at '0ft'

      cc.strokeStyle = this.theme.SCOPE.FIX_FILL; // Somehow used to tint the terrain key rectangles' fill color
      // Also determines color of terrain fill at '0ft'

      cc.fillStyle = this.theme.SCOPE.FIX_FILL;
      cc.lineWidth = (0, _core.clamp)(0.5, _CanvasStageModel["default"].scale / 10, 2);
      cc.lineJoin = 'round';
      cc.save();
      cc.translate(_CanvasStageModel["default"]._panX, _CanvasStageModel["default"]._panY);

      for (var elevation in airportTerrain) {
        // eslint-disable-next-line
        if (!airportTerrain.hasOwnProperty(elevation)) {
          continue;
        }

        var terrainLevel = airportTerrain[elevation];

        if (elevation < 0 && !this._hasSeenTerrainWarning) {
          console.warn("".concat(airport.icao, ".geojson contains 'terrain' ") + ' below sea level, which is not supported!');
          this._hasSeenTerrainWarning = true;
          continue;
        }

        max_elevation = Math.max(max_elevation, elevation);

        this._drawTerrainAtElevation(cc, terrainLevel, elevation);
      }

      cc.restore();

      if (max_elevation !== 0) {
        this._drawTerrainElevationLegend(cc, max_elevation);
      }

      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawRestrictedAirspace
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawRestrictedAirspace",
    value: function _drawRestrictedAirspace(cc) {
      if (!this._shouldDrawRestrictedAreas) {
        return;
      }

      cc.save();
      cc.translate(_CanvasStageModel["default"].halfWidth + _CanvasStageModel["default"]._panX, _CanvasStageModel["default"].halfHeight + _CanvasStageModel["default"]._panY);
      cc.strokeStyle = this.theme.SCOPE.RESTRICTED_AIRSPACE;
      cc.lineWidth = Math.max(_CanvasStageModel["default"].scale / 3, 2);
      cc.lineJoin = 'round';
      cc.font = _canvasConstants.BASE_CANVAS_FONT;

      var airportModel = _AirportController["default"].airport_get();

      for (var i = 0; i < airportModel.restricted_areas.length; i++) {
        var area = airportModel.restricted_areas[i];
        cc.fillStyle = 'transparent';

        this._drawPoly(cc, area.coordinates); // TODO: Is the restricted airspace EVER filled???


        cc.fillStyle = this.theme.SCOPE.RESTRICTED_AIRSPACE;
        cc.textAlign = 'center';
        cc.textBaseline = 'top';
        var height = area.height === Infinity ? 'UNL' : "FL ".concat(Math.ceil(area.height / 1000) * 10);
        var height_shift = 0;

        if (area.name) {
          height_shift = -12;
          cc.fillText(area.name, (0, _core.round)(_CanvasStageModel["default"].translateKilometersToPixels(area.center[0])), -(0, _core.round)(_CanvasStageModel["default"].translateKilometersToPixels(area.center[1])));
        }

        cc.fillText(height, (0, _core.round)(_CanvasStageModel["default"].translateKilometersToPixels(area.center[0])), height_shift - (0, _core.round)(_CanvasStageModel["default"].translateKilometersToPixels(area.center[1])));
      }

      cc.restore();
    }
    /**
     * @for CanvasController
     * @method _drawVideoMap
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawVideoMap",
    value: function _drawVideoMap(cc) {
      var airportModel = _AirportController["default"].airport_get(); // Don't bother with the canvas set up if the airport has no visible maps


      if (!airportModel.mapCollection.hasVisibleMaps || !this._shouldDrawVideoMap) {
        return;
      }

      cc.save();
      cc.translate(_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight);
      cc.strokeStyle = this.theme.SCOPE.VIDEO_MAP;
      cc.lineWidth = Math.max(1, _CanvasStageModel["default"].scale / 15);
      cc.lineJoin = 'round';
      cc.font = _canvasConstants.BASE_CANVAS_FONT;
      cc.translate(_CanvasStageModel["default"]._panX, _CanvasStageModel["default"]._panY);
      cc.beginPath();
      var lines = airportModel.mapCollection.getVisibleMapLines();
      lines.forEach(function (mapItem) {
        cc.moveTo(_CanvasStageModel["default"].translateKilometersToPixels(mapItem[0]), -_CanvasStageModel["default"].translateKilometersToPixels(mapItem[1]));
        cc.lineTo(_CanvasStageModel["default"].translateKilometersToPixels(mapItem[2]), -_CanvasStageModel["default"].translateKilometersToPixels(mapItem[3]));
      });
      cc.stroke();
      cc.restore();
    } // TODO: this method should be removed or reworked.

    /**
     * Draw the compass around the edge of the scope view
     *
     * @for CanvasController
     * @method _drawSelectedAircraftCompass
     * @param cc {HTMLCanvasContext}
     * @private
     */

  }, {
    key: "_drawSelectedAircraftCompass",
    value: function _drawSelectedAircraftCompass(cc) {
      if (_GameController["default"].game_paused()) {
        return;
      }

      var callsign = prop.input.callsign.toUpperCase();

      if (callsign.length === 0) {
        return;
      } // TODO: this should be a method on the `AircraftController` if one doesn't already exist.
      // Get the selected aircraft.


      var aircraft = (0, _filter2["default"])(this._aircraftController.aircraft.list, function (p) {
        return p.matchCallsign(callsign) && p.isVisible();
      })[0];

      if (!aircraft) {
        return;
      }

      var canvasOrigin = [0, 0];
      var canvasSize = [_CanvasStageModel["default"].width, _CanvasStageModel["default"].height];

      var aircraftPosition = this._toCanvasPosition(aircraft.relativePosition);

      cc.save(); // generic styles of the compass marks

      cc.strokeStyle = this.theme.SCOPE.COMPASS_HASH;
      cc.fillStyle = this.theme.SCOPE.COMPASS_TEXT;
      cc.textAlign = 'center';
      cc.textBaseline = 'middle'; // Compute the intersection point between a ray originating from the
      // aircraft at a given heading angle and the canvas boundaries, for
      // each heading angle between 0 and 360 (by 1 degree increment)

      for (var heading = 1; heading <= 360; heading++) {
        // compute the 2D unit vector representing the ray direction using the given
        // heading angle
        var rayUnitVector = (0, _vector.vectorize2dFromDegrees)(heading); // Use the opposite of the y component of the vector because of the vertical
        // axes of the reference frames being oriented in opposite directions

        rayUnitVector[1] = -rayUnitVector[1]; // compute the intersection point between the ray and the canvas

        var intersection = (0, _vector.positive_intersection_with_rect)(aircraftPosition, rayUnitVector, canvasOrigin, canvasSize);

        if (!intersection) {
          continue;
        } // draw a mark and label at the intersection point
        // standard marks on all headings
        // minor marks on headings multiple of 5 degrees
        // major marks on headings multiple of 10 degrees


        var markLen = 8;

        if (heading % 5 === 0) {
          markLen = heading % 10 === 0 ? 16 : 12;
        }

        var markWeight = heading % 30 === 0 ? 2 : 1; // use the opposite of the length to draw toward the inside of the canvas

        var markVector = (0, _vector.vscale)(rayUnitVector, -markLen);
        var markStartPoint = intersection;
        var markEndPoint = (0, _vector.vadd)(markStartPoint, markVector); // draw the mark

        cc.lineWidth = markWeight;
        cc.beginPath();
        cc.moveTo.apply(cc, _toConsumableArray(markStartPoint));
        cc.lineTo.apply(cc, _toConsumableArray(markEndPoint));
        cc.stroke(); // only draw label on major marks

        if (heading % 10 !== 0) {
          continue;
        } // set label font heavier every 3 major marks


        cc.font = heading % 30 === 0 ? 'bold 10px monoOne, monospace' : _canvasConstants.BASE_CANVAS_FONT;
        var text = "".concat(String(heading).padStart(3, '0'));
        var textWidth = cc.measureText(text).width; // draw the label

        cc.fillText(text, markEndPoint[0] - rayUnitVector[0] * (textWidth / 2 + 4), markEndPoint[1] - rayUnitVector[1] * 7);
      }

      cc.restore();
    }
    /**
     * Find a canvas context stored within `#_context`
     *
     * @for CanvasController
     * @method _getCanvasContextByName
     * @param name {string}
     * @private
     */

  }, {
    key: "_getCanvasContextByName",
    value: function _getCanvasContextByName(name) {
      return this._context[name];
    } // TODO: this should be moved to the `CanvasStageModel`
    // NOTE: `CanvasStageModel.translatePostionModelToPreciseCanvasPosition()`
    // is a closely related function

    /**
     * Transform a scope relative position to a canvas relative position
     *
     * Create a vector "vCanvasToScope" describing the position of the canvas
     * relative to the scope, and simply add it to the given position to get the
     * position relative to the canvas.
     *
     * The vertical axes are oriented in opposite direction in our source and
     * destination frames of reference (scope versus canvas), so the y component of
     * the given position need to be "reversed".
     *
     * The given position in expressed in kilometers so it needs to be
     * translated to pixels.
     *
     * @for CanvasController
     * @method _toCanvasPosition
     * @param positionFromScope     array   an array of the x and y components of a
     *                                      position relative to the scope center
     */

  }, {
    key: "_toCanvasPosition",
    value: function _toCanvasPosition(positionFromScope) {
      // positionFromScope is given in kilometers so it needs to be translated
      // to pixels first
      //
      // use the opposite of the y component of the aircraft position because
      // the vertical axes are not oriented in the same direction in the
      // scope (aircraft) frame of reference versus the canvas frame of reference
      positionFromScope = [_CanvasStageModel["default"].translateKilometersToPixels(positionFromScope[0]), -_CanvasStageModel["default"].translateKilometersToPixels(positionFromScope[1])];
      var scopePositionRelativeToView = [_CanvasStageModel["default"]._panX, _CanvasStageModel["default"]._panY];
      var viewPositionRelativeToCanvasOrigin = [_CanvasStageModel["default"].halfWidth, _CanvasStageModel["default"].halfHeight];
      var scopePositionRelativeToCanvasOrigin = (0, _vector.vadd)(viewPositionRelativeToCanvasOrigin, scopePositionRelativeToView);
      return (0, _vector.vadd)(scopePositionRelativeToCanvasOrigin, positionFromScope);
    }
    /**
     * Calculate the length of the leader line connecting the target to the data block
     *
     * @for CanvasController
     * @method _calculateLeaderLength
     * @param dataBlockLeaderLength {number} from RadarTargetModel#dataBlockLeaderLength
     * @return {number} length, in pixels
     * @private
     */

  }, {
    key: "_calculateLeaderLength",
    value: function _calculateLeaderLength(dataBlockLeaderLength) {
      return dataBlockLeaderLength * this.theme.DATA_BLOCK.LEADER_LENGTH_INCREMENT_PIXELS + this.theme.DATA_BLOCK.LEADER_LENGTH_ADJUSTMENT_PIXELS - this.theme.DATA_BLOCK.LEADER_PADDING_FROM_BLOCK_PX - this.theme.DATA_BLOCK.LEADER_PADDING_FROM_TARGET_PX;
    }
    /**
     * Mark the canvas as dirty, forcing a redraw during the next frame
     *
     * This method should only be called via the `EventBus`
     * Facade method for `._markShallowRender()`
     *
     * @for CanvasController
     * @method _onMarkDirtyCanvas
     * @private
     */

  }, {
    key: "_onMarkDirtyCanvas",
    value: function _onMarkDirtyCanvas() {
      this._markShallowRender();
    }
    /**
     * Update local props as a result of the user panning the view
     *
     * This method will only be `trigger`ed by some other
     * class via the `EventBus`
     *
     * @for CanvasController
     * @method _onChangeViewportPan
     * @private
     */

  }, {
    key: "_onChangeViewportPan",
    value: function _onChangeViewportPan() {
      this._markDeepRender();
    }
    /**
     * Update local props as a result of a change in the current zoom level
     *
     * This method will only be `trigger`ed by some other
     * class via the `EventBus`
     *
     * @for CanvasController
     * @method _onChangeViewportZoom
     * @param mouseDelta {array<number, number>}
     * @private
     */

  }, {
    key: "_onChangeViewportZoom",
    value: function _onChangeViewportZoom() {
      this._markDeepRender();
    }
    /**
     * Toogle current value of `#_shouldDrawAirspace`
     *
     * This method will only be `trigger`ed by some other
     * class via the `EventBus`
     *
     * @for CanvasController
     * @method _onToggleAirspace
     * @private
     */

  }, {
    key: "_onToggleAirspace",
    value: function _onToggleAirspace() {
      this._shouldDrawAirspace = !this._shouldDrawAirspace;

      this._markDeepRender();
    }
    /**
     * Toogle current value of `#draw_labels`
     *
     * This method will only be `trigger`ed by some other
     * class via the `EventBus`
     *
     * @for CanvasController
     * @method _onToggleLabels
     * @private
     */

  }, {
    key: "_onToggleLabels",
    value: function _onToggleLabels() {
      this._shouldDrawFixLabels = !this._shouldDrawFixLabels;

      this._markDeepRender();
    }
    /**
     * Toogle current value of `#draw_restricted`
     *
     * This method will only be `trigger`ed by some other
     * class via the `EventBus`
     *
     * @for CanvasController
     * @method _onToggleRestrictedAreas
     * @private
     */

  }, {
    key: "_onToggleRestrictedAreas",
    value: function _onToggleRestrictedAreas() {
      this._shouldDrawRestrictedAreas = !this._shouldDrawRestrictedAreas;

      this._markDeepRender();
    }
    /**
     * Toogle current value of `#draw_sids`
     *
     * This method will only be `trigger`ed by some other
     * class via the `EventBus`
     *
     * @for CanvasController
     * @method _onToggleSidMap
     * @private
     */

  }, {
    key: "_onToggleSidMap",
    value: function _onToggleSidMap() {
      this._shouldDrawSidMap = !this._shouldDrawSidMap;

      this._markDeepRender();
    }
    /**
     * Toogle display of STAR routes
     *
     * This method will only be `trigger`ed by some other
     * class via the `EventBus`
     *
     * @for CanvasController
     * @method _onToggleStarMap
     * @private
     */

  }, {
    key: "_onToggleStarMap",
    value: function _onToggleStarMap() {
      this._shouldDrawStarMap = !this._shouldDrawStarMap;

      this._markDeepRender();
    }
    /**
     * Toogle current value of `#draw_terrain`
     *
     * This method will only be `trigger`ed by some other
     * class via the `EventBus`
     *
     * @for CanvasController
     * @method _onToggleTerrain
     * @private
     */

  }, {
    key: "_onToggleTerrain",
    value: function _onToggleTerrain() {
      this._shouldDrawTerrain = !this._shouldDrawTerrain;

      this._markDeepRender();
    }
    /**
     * Toogle display of video map
     *
     * This method will only be `trigger`ed by some other
     * class via the `EventBus`
     *
     * @for CanvasController
     * @method _onToggleVideoMap
     * @private
     */

  }, {
    key: "_onToggleVideoMap",
    value: function _onToggleVideoMap() {
      this._shouldDrawVideoMap = !this._shouldDrawVideoMap;

      this._markDeepRender();
    }
    /**
     * Notify that the range rings value has changed by the user.
     *
     * This method will only be `trigger`ed by some other
     * class via the `EventBus`
     *
     * @for CanvasController
     * @method _onRangeRingsChange
     * @private
     */

  }, {
    key: "_onRangeRingsChange",
    value: function _onRangeRingsChange() {
      this._markDeepRender();
    }
    /**
     * Update the value of `#_shouldShallowRender` to true, forcing a redraw
     * on the next frame.
     *
     * This method should be used for forcing redraws on _dynamic_ elements
     * only. In the future this will mean only items contained within the
     * `CANVAS_NAME.DYNAMIC` will be redrawn.
     *
     * @for CanvasController
     * @method _markShallowRender
     * @private
     */

  }, {
    key: "_markShallowRender",
    value: function _markShallowRender() {
      this._shouldShallowRender = true;
    }
    /**
     * Update the value of `#_shouldShallowRender` and `#_shouldDeepRender` to true, thus
     * forcing a redraw of both canvases on the next frame.
     *
     * This method should be used for forcing redraws on dynamic _and_ static elements.
     * In the future this will mean both `CANVAS_NAME.STATIC` and `CANVAS_NAME.DYNAMIC`
     * will be redrawn on the next frame.
     *
     * @for CanvasController
     * @method _markDeepRender
     * @private
     */

  }, {
    key: "_markDeepRender",
    value: function _markDeepRender() {
      this._shouldDeepRender = true;

      this._markShallowRender();
    }
    /**
     * Trigger _markShallowRender() when an aircraft is selected, thus
     * forcing a redraw of the dynamic canvas on the next frame.
     *
     * @for CanvasController
     * @method _onSelectAircraft
     * @private
     */

  }, {
    key: "_onSelectAircraft",
    value: function _onSelectAircraft() {
      this._markShallowRender();
    }
    /**
     * Trigger _markShallowRender() when an aircraft is deselected, thus
     * forcing a redraw of the dynamic canvas on the next frame.
     *
     * @for CanvasController
     * @method _onDeselectAircraft
     * @private
     */

  }, {
    key: "_onDeselectAircraft",
    value: function _onDeselectAircraft() {
      this._markShallowRender();
    }
    /**
     * Center a point in the view
     *
     * Used only for centering view on an aircraft position using
     * the x, y of an aircraft's `relativePosition`
     *
     * @for CanvasController
     * @method _onCenterPointInView
     * @param x {number}    relativePosition.x
     * @param y {number}    relativePosition.y
     */

  }, {
    key: "_onCenterPointInView",
    value: function _onCenterPointInView(_ref) {
      var x = _ref.x,
          y = _ref.y;
      _CanvasStageModel["default"]._panX = 0 - (0, _core.round)(_CanvasStageModel["default"].translateKilometersToPixels(x));
      _CanvasStageModel["default"]._panY = (0, _core.round)(_CanvasStageModel["default"].translateKilometersToPixels(y));

      this._markDeepRender();
    }
    /**
     * Callback method fired when an airport is changed
     *
     * Changing an airport will require a complete re-draw of all
     * items on all canvases, thus we call `._markDeepRender()` here
     * to initiate that process
     *
     * @for CanvasController
     * @method _onAirportChange
     * @private
     */

  }, {
    key: "_onAirportChange",
    value: function _onAirportChange() {
      this._markDeepRender();
    }
    /**
     * Change theme to the specified name
     *
     * This should ONLY be called through the EventBus during a `SET_THEME` event,
     * thus ensuring that the same theme is always in use by all app components
     *
     * This method must remain an arrow function in order to preserve the scope
     * of `this`, since it is being invoked by an EventBus callback
     *
     * @for CanvasController
     * @method _setTheme
     * @param themeName {string}
     */

  }, {
    key: "_setTheme",
    value: function _setTheme(themeName) {
      if (!(0, _has2["default"])(_themes.THEME, themeName)) {
        console.error("Expected valid theme to change to, but received '".concat(themeName, "'"));
        return;
      } // TODO: abstract to method


      if (this.theme !== null) {
        this.$element.removeClass(this.theme.CLASSNAME);
      }

      this.theme = _themes.THEME[themeName]; // TODO: abstract to method

      this.$element.addClass(this.theme.CLASSNAME);

      this._markDeepRender();
    }
  }]);

  return CanvasController;
}();

exports["default"] = CanvasController;

},{"../airport/AirportController":284,"../constants/aircraftConstants":303,"../constants/canvasConstants":306,"../constants/eventNames":308,"../constants/gameOptionConstants":309,"../constants/globalConstants":310,"../constants/routeConstants":314,"../constants/themes":319,"../engine/TimeKeeper":338,"../game/GameController":339,"../lib/EventBus":346,"../math/circle":348,"../math/core":349,"../math/vector":352,"../measurement/MeasureTool":355,"../navigationLibrary/NavigationLibrary":361,"../utilities/generalUtilities":387,"../utilities/unitConverters":391,"./CanvasStageModel":301,"jquery":1,"lodash/cloneDeep":183,"lodash/filter":190,"lodash/has":201,"lodash/inRange":205}],301:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _has2 = _interopRequireDefault(require("lodash/has"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _core = require("../math/core");

var _eventNames = require("../constants/eventNames");

var _canvasConstants = require("../constants/canvasConstants");

var _storageKeys = require("../constants/storageKeys");

var _globalConstants = require("../constants/globalConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Singleton responsible for mantining canvas dimensions, pan and zoom
 *
 * Also provides methods for translating `[x, y]` positions to
 * and from kilometers or pixels
 *
 * @class CanvasStageModel
 */
var CanvasStageModel =
/*#__PURE__*/
function () {
  /**
   * @constructor
   */
  function CanvasStageModel() {
    _classCallCheck(this, CanvasStageModel);

    /**
     * @property _eventBus
     * @type {EventBus}
     * @private
     */
    this._eventBus = _EventBus["default"];
    /**
     * Pixel height of the canvas(es)
     *
     * @property height
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    this._height = _globalConstants.INVALID_NUMBER;
    /**
     * Pixel width of the canvas(es)
     *
     * @property width
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    this._width = _globalConstants.INVALID_NUMBER;
    /**
     * Midpoint of view along the `x` coordinate
     *
     * @property _panX
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    this._panX = _globalConstants.INVALID_NUMBER;
    /**
     * Midpoint of view along the `y` coordinate
     *
     * @property _panY
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    this._panY = _globalConstants.INVALID_NUMBER;
    /**
     * pixels per km
     *
     * @property _defaultScale
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    this._defaultScale = _globalConstants.INVALID_NUMBER;
    /**
     * maximum scale value
     *
     * @property _scaleMax
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    this._scaleMax = _globalConstants.INVALID_NUMBER;
    /**
     * minimum scale value
     *
     * @property _scaleMin
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    this._scaleMin = _globalConstants.INVALID_NUMBER;
    /**
     * Current scale value
     *
     * scale is essentially the zoom value, the larger the
     * scale the closer the current zoom.
     *
     * @property _scale
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    this._scale = _globalConstants.INVALID_NUMBER;
    return this._init();
  }
  /**
   * @property height
   * @type {number}
   */


  _createClass(CanvasStageModel, [{
    key: "_init",

    /**
     * @for CanvasStageModel
     * @method _init
     * @private
     */
    value: function _init() {
      this._height = _canvasConstants.DEFAULT_CANVAS_SIZE.HEIGHT;
      this._width = _canvasConstants.DEFAULT_CANVAS_SIZE.WIDTH;
      this._panX = _canvasConstants.PAN.X;
      this._panY = _canvasConstants.PAN.Y;
      this._defaultScale = _canvasConstants.SCALE.DEFAULT;
      this._scaleMin = _canvasConstants.SCALE.MIN;
      this._scaleMax = _canvasConstants.SCALE.MAX;
      this._scale = this._retrieveZoomLevelFromStorageOrDefault();
    }
    /**
     * @for CanvasStageModel
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this._height = _globalConstants.INVALID_NUMBER;
      this._width = _globalConstants.INVALID_NUMBER;
      this._panX = _globalConstants.INVALID_NUMBER;
      this._panY = _globalConstants.INVALID_NUMBER;
      this._defaultScale = _globalConstants.INVALID_NUMBER;
      this._scaleMax = _globalConstants.INVALID_NUMBER;
      this._scaleMin = _globalConstants.INVALID_NUMBER;
      this._scale = _globalConstants.INVALID_NUMBER;
    }
    /**
     * Translate a kilometer value to pixels based on the current `#_scale` value
     *
     * @for CanvasStageModel
     * @method translateKilometersToPixels
     * @param kilometerValue {number}   value in kilometers
     * @return {number}                 value in pixels
     */

  }, {
    key: "translateKilometersToPixels",
    value: function translateKilometersToPixels(kilometerValue) {
      return kilometerValue * this._scale;
    }
    /**
     * Translate a mouse position, in pixels, as it relates to the
     * browser window to canvas position
     *
     * @for CanvasStageModel
     * @method translateMousePositionToCanvasPosition
     * @param x {number}
     * @param y {number}
     * @return {object<string, number>}
     */

  }, {
    key: "translateMousePositionToCanvasPosition",
    value: function translateMousePositionToCanvasPosition(x, y) {
      var canvasPositionX = x - this.halfWidth;
      var canvasPositionY = -y + this.halfHeight;
      return {
        x: canvasPositionX,
        y: canvasPositionY
      };
    }
    /**
     * Translate a pixel value to kilometers based on the current `#_scale` value
     *
     * @for CanvasStageModel
     * @method translatePixelsToKilometers
     * @param pixelValue {number}  value in pixels
     * @return {number}            value in kilometers
     */

  }, {
    key: "translatePixelsToKilometers",
    value: function translatePixelsToKilometers(pixelValue) {
      return pixelValue / this._scale;
    }
    /**
     * Translate an `[x, y]` tuple (in km) to a canvas position (in px)
     *
     * The return values will be high precision numbers that can be used
     * to plot an exact pixel position.
     *
     * This method should not be used for things like pan and aircraft future tracks
     *
     * @for CanvasStageModel
     * @method translatePostionModelToPreciseCanvasPosition
     * @param x {number}
     * @param y {number}
     * @return {object<string, number>}
     */

  }, {
    key: "translatePostionModelToPreciseCanvasPosition",
    value: function translatePostionModelToPreciseCanvasPosition(_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          x = _ref2[0],
          y = _ref2[1];

      var canvasX = this.translateKilometersToPixels(x) + this._panX;

      var canvasY = this.translateKilometersToPixels(y) * -1 + this._panY;

      return {
        x: canvasX,
        y: canvasY
      };
    }
    /**
     * Translate an `[x, y]` tuple (in km) to a canvas position (in px)
     *
     * The return values will be rounded and are thus not considered precise
     *
     * Calls to this method should be used to calculate approximate canvas position,
     * useful for things like pan and cursor screen position.
     *
     * This method should not be used to translate an aircraft position
     *
     * @for CanvasStageModel
     * @method translatePostionModelToRoundedCanvasPosition
     * @param position {array<number, number>}  `[x, y]` position coordinates (in km)
     * @return {object<string, number>}
     */

  }, {
    key: "translatePostionModelToRoundedCanvasPosition",
    value: function translatePostionModelToRoundedCanvasPosition(position) {
      var _this$translatePostio = this.translatePostionModelToPreciseCanvasPosition(position),
          x = _this$translatePostio.x,
          y = _this$translatePostio.y;

      return {
        x: (0, _core.round)(x),
        y: (0, _core.round)(y)
      };
    }
    /**
     * Update the current canvas dimensions
     *
     * Calls to this method will happen as a result of a browser window resize
     *
     * @for CanvasStageModel
     * @method updateHeightAndWidth
     * @param nextHeight {number}   next height value in pixels
     * @param nextWidth {number}    next width value in pixels
     */

  }, {
    key: "updateHeightAndWidth",
    value: function updateHeightAndWidth(nextHeight, nextWidth) {
      this._height = nextHeight - _canvasConstants.DEFAULT_CANVAS_SIZE.FOTTER_HEIGHT_OFFSET;
      this._width = nextWidth;
    }
    /**
     * Update the current pan values.
     *
     * @for CanvasStageModel
     * @method updatePan
     * @param x {number}
     * @param y {number}
     */

  }, {
    key: "updatePan",
    value: function updatePan(x, y) {
      this._panX = x;
      this._panY = y;

      this._eventBus.trigger(_eventNames.EVENT.PAN_VIEWPORT);
    }
    /**
     * @for CanvasStageModel
     * @method zoomIn
     */

  }, {
    key: "zoomIn",
    value: function zoomIn() {
      var isZoomOut = true;

      this._updateZoom(isZoomOut);
    }
    /**
     * @for CanvasStageModel
     * @method zoomOut
     */

  }, {
    key: "zoomOut",
    value: function zoomOut() {
      var isZoomOut = false;

      this._updateZoom(isZoomOut);
    }
    /**
     * Reset the current `#_scale` value to the `#_defaultScale`
     *
     * @for CanvasStageModel
     * @method zoomReset
     */

  }, {
    key: "zoomReset",
    value: function zoomReset() {
      this._scale = this._defaultScale;

      this._storeZoomLevel();

      this._eventBus.trigger(_eventNames.EVENT.ZOOM_VIEWPORT);
    }
    /**
     * Look for a stored `#_scale` value in localStorage
     *
     * When a stored value cannot be found, use the `SCALE.DEFAULT` value
     *
     * @for CanvasStageModel
     * @method _retrieveZoomLevelFromStorage
     * @return {number}
     * @private
     */

  }, {
    key: "_retrieveZoomLevelFromStorageOrDefault",
    value: function _retrieveZoomLevelFromStorageOrDefault() {
      if (!(0, _has2["default"])(localStorage, _storageKeys.STORAGE_KEY.ZOOM_LEVEL)) {
        return _canvasConstants.SCALE.DEFAULT;
      }

      var storedScale = localStorage.getItem(_storageKeys.STORAGE_KEY.ZOOM_LEVEL);
      return storedScale;
    }
    /**
     * Store the current `#_scale` value in localStorage
     *
     * @for CanvasStageModel
     * @method _storeZoomLevel
     * @private
     */

  }, {
    key: "_storeZoomLevel",
    value: function _storeZoomLevel() {
      localStorage.setItem(_storageKeys.STORAGE_KEY.ZOOM_LEVEL, this._scale);
    }
    /**
     * Update the current `#_scale` value
     *
     * @for CanvasStageModel
     * @method _updateScale
     * @param isZoomIn {boolean}
     * @private
     */

  }, {
    key: "_updateScale",
    value: function _updateScale(isZoomIn) {
      if (isZoomIn) {
        this._scale = Math.min(this._scale / _canvasConstants.SCALE.CHANGE_FACTOR, this._scaleMax);
        return;
      }

      this._scale = Math.max(this._scale * _canvasConstants.SCALE.CHANGE_FACTOR, this._scaleMin);
    }
    /**
     * Update the current `#_panX`, `#_panY`, and `#_scale` values
     *
     * When a user changes the zoom level, we must also adjust pan
     * values to account for a change in `#_scale`. Pixel dimensions of
     * the canvas don't change on zoom, but the `#_scale` does. So we
     * must re-calculate current pan values with the updated `#_scale`
     *
     * Calling this method will trigger an `EventBus` event that the
     * `CanvasController` is listening for that will trigger a deepRender
     *
     * @for CanvasStageModel
     * @method _updateZoom
     * @param isZoomIn {boolean}  flag for when use is zooming in
     * @private
     */

  }, {
    key: "_updateZoom",
    value: function _updateZoom(isZoomIn) {
      // store current pan in km, so it can be re-calculated with an updated `_#scale`
      var previousX = (0, _core.round)(this.translatePixelsToKilometers(this._panX));
      var previousY = (0, _core.round)(this.translatePixelsToKilometers(this._panY));

      this._updateScale(isZoomIn); // take previous pan values (in km) and calculate their current position
      // based on the new `#_scale` value


      var nextPanX = (0, _core.round)(this.translateKilometersToPixels(previousX));
      var nextPanY = (0, _core.round)(this.translateKilometersToPixels(previousY));
      this.updatePan(nextPanX, nextPanY);

      this._storeZoomLevel();

      this._eventBus.trigger(_eventNames.EVENT.ZOOM_VIEWPORT);
    }
  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
    /**
     * @property halfHeight
     * @type {number}
     */

  }, {
    key: "halfHeight",
    get: function get() {
      return (0, _core.round)(this._height / 2);
    }
    /**
     * @property scale
     * @type {number}
     */

  }, {
    key: "scale",
    get: function get() {
      return this._scale;
    }
    /**
     * @property width
     * @type {number}
     */

  }, {
    key: "width",
    get: function get() {
      return this._width;
    }
    /**
     * @property halfWidth
     * @type {number}
     */

  }, {
    key: "halfWidth",
    get: function get() {
      return (0, _core.round)(this._width / 2);
    }
  }]);

  return CanvasStageModel;
}();

var _default = new CanvasStageModel();

exports["default"] = _default;

},{"../constants/canvasConstants":306,"../constants/eventNames":308,"../constants/globalConstants":310,"../constants/storageKeys":318,"../lib/EventBus":346,"../math/core":349,"lodash/has":201}],302:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _selectors = require("../constants/selectors");

var _storageKeys = require("../constants/storageKeys");

var _eventNames = require("../constants/eventNames");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * The controller class for the in-game changelog.
 *
 * @class ChangelogController
 */
var ChangelogController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {ContentQueue} contentQueue
   */
  function ChangelogController(contentQueue) {
    _classCallCheck(this, ChangelogController);

    /**
     * A string representation of the actual changelog.
     *
     * @property content
     * @type {String}
     */
    this.content = null;
    /**
     * The content queue, used to load in the changelog data
     *
     * @property contentQueue
     * @type {ContentQueue}
     */

    this.contentQueue = null;
    /**
     * The DOM of the changelog container, containing version, data, and dismiss.
     *
     * @property $changelogContainer
     * @type {JQuery|HTMLElement}
     */

    this.$changelogContainer = null;
    /**
     * Changelog data element - where the text goes
     *
     * @property $changelogData
     * @type {JQuery|HTMLElement}
     */

    this.$changelogData = null;
    /**
     * Toggle selector for the changelog
     * You know, the button thing
     *
     * @property $changelogToggle
     * @type {JQuery|HTMLElement}
     */

    this.$changelogToggle = null;
    /**
     * local reference to the EventBus
     *
     * @property _eventBus
     * @type {EventBus}
     */

    this._eventBus = null;
    this.init(contentQueue);
  } // ------------------------------ LIFECYCLE ------------------------------

  /**
   * @for ChangelogController
   * @method init
   * @chainable
   */


  _createClass(ChangelogController, [{
    key: "init",
    value: function init(contentQueue) {
      this.content = '<p>Loading...</p>';
      this.contentQueue = contentQueue;
      this._eventBus = _EventBus["default"];

      this._createChildren();

      this.$changelogData.html(this.content);

      this._createHandlers();

      this.enable();
      this.loadChangelogContent();
      return this;
    }
    /**
     * @for ChangelogController
     * @method reset
     * @chainable
     */

  }, {
    key: "reset",
    value: function reset() {
      this.content = null;
      this.contentQueue = null;
      this.$changelogContainer = null;
      this.$changelogData = null;
      this.$changelogToggle = null;
      this._eventBus = null;

      this._resetHandlers();

      this.disable();
      return this;
    }
    /**
     * @for ChangelogController
     * @method enable
     */

  }, {
    key: "enable",
    value: function enable() {
      this._eventBus.on(_eventNames.EVENT.TOGGLE_CHANGELOG, this._onChangelogToggleHandler);
    }
    /**
     * @for ChangelogController
     * @method disable
     */

  }, {
    key: "disable",
    value: function disable() {
      this.$changelogToggle.off(_eventNames.EVENT.TOGGLE_CHANGELOG, this._onChangelogToggleHandler);
    }
    /**
     * Sets up the DOM class properties
     *
     * @for ChangelogController
     * @method _createChildren
     * @private
     * @chainable
     */

  }, {
    key: "_createChildren",
    value: function _createChildren() {
      this.$changelogContainer = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.CHANGELOG_CONTAINER);
      this.$changelogData = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.CHANGELOG_CONTENT);
      this.$changelogToggle = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_CHANGELOG);
      return this;
    }
    /**
     * Sets up the event handlers
     *
     * @for ChangelogController
     * @method _createHandlers
     * @private
     * @chainable
     */

  }, {
    key: "_createHandlers",
    value: function _createHandlers() {
      this._onChangelogToggleHandler = this._onChangelogToggle.bind(this);
      return this;
    }
    /**
     * Sets up the event handlers
     *
     * @for ChangelogController
     * @method _resetHandlers
     * @private
     * @chainable
     */

  }, {
    key: "_resetHandlers",
    value: function _resetHandlers() {
      this._onChangelogToggleHandler = null;
      return this;
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Calls a changelog loader asynchronously. Calls `onLoadComplete` when
     * the changelog data is successfully loaded. Stores data in
     * `this.content`.
     *
     * @for ChangelogController
     * @method loadChangelogContent
     */

  }, {
    key: "loadChangelogContent",
    value: function loadChangelogContent() {
      var _this = this;

      var options = {
        url: 'assets/changelog.json',
        immediate: true
      };
      var changelogPromise = this.contentQueue.add(options);
      changelogPromise.done(function (data
      /* , textStatus, jqXHR */
      ) {
        _this.content = data.changelog;

        _this.onLoadComplete();
      });
    }
    /**
     * Called when the changelog is loaded (the promise was resolved) as the
     * callback from the deferred promise.
     *
     * @for ChangelogController
     * @method onLoadComplete
     */

  }, {
    key: "onLoadComplete",
    value: function onLoadComplete() {
      this.isLoaded = true;
      this.$changelogData.html(this.content);

      if (this._shouldShowOnLoad()) {
        this._onChangelogToggle();
      }
    } // ------------------------------ PRIVATE ------------------------------

    /**
     * Toggles visibility.
     *
     * @for ChangelogController
     * @method _onChangelogToggle
     * @private
     */

  }, {
    key: "_onChangelogToggle",
    value: function _onChangelogToggle() {
      this.$changelogToggle.toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
      this.$changelogContainer.toggleClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
    }
    /**
     * Determines whether the user has played this version before,
     * and if the changelog should display on load.
     *
     * @for ChangelogController
     * @method _shouldShowOnLoad
     * @returns {Boolean} if the user has not played this version
     */

  }, {
    key: "_shouldShowOnLoad",
    value: function _shouldShowOnLoad() {
      var lastPlayedVersion = localStorage[_storageKeys.STORAGE_KEY.ATC_LAST_VERSION];
      var currentVersion = this.version;
      var shouldDisplayChangelog = lastPlayedVersion !== currentVersion;

      if (shouldDisplayChangelog) {
        localStorage[_storageKeys.STORAGE_KEY.ATC_LAST_VERSION] = currentVersion;
      }

      return shouldDisplayChangelog;
    }
  }]);

  return ChangelogController;
}();

exports["default"] = ChangelogController;

},{"../constants/eventNames":308,"../constants/selectors":316,"../constants/storageKeys":318,"../lib/EventBus":346,"jquery":1}],303:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SEPARATION = exports.PERFORMANCE = exports.FLIGHT_PHASE = exports.FLIGHT_CATEGORY = void 0;

/**
 * @property FLIGHT_CATEGORY
 * @type {Object}
 * @final
 */
var FLIGHT_CATEGORY = {
  ARRIVAL: 'arrival',
  DEPARTURE: 'departure',
  OVERFLIGHT: 'overflight'
};
/**
 * Enumeration for the phases of flight
 *
 * @property FLIGHT_PHASE
 * @type {object}
 * @final
 */

exports.FLIGHT_CATEGORY = FLIGHT_CATEGORY;
var FLIGHT_PHASE = {
  /**
   * initial status of a new departing aircraft. After the aircraft is issued the 'taxi' command,
   * the aircraft transitions to 'taxi' mode
   *
   * @memberof FLIGHT_PHASE
   * @property
   * @type {string}
   */
  APRON: 'APRON',

  /**
   * the process of getting ready for takeoff. After a delay, the aircraft becomes ready and
   * transitions into 'waiting' mode
   *
   * @memberof FLIGHT_PHASE
   * @property TAXI
   * @type {string}
   */
  TAXI: 'TAXI',

  /**
   * the aircraft is ready for takeoff and awaits clearence to take off
   *
   * @memberof FLIGHT_PHASE
   * @property WAITING
   * @type {string}
   */
  WAITING: 'WAITING',

  /**
   * is assigned to an aircraft in the process of taking off. The aircraft are still on the
   * ground or have not yet reached the minimum altitude
   *
   * @memberof FLIGHT_PHASE
   * @property TAKEOFF
   * @type {string}
   */
  TAKEOFF: 'TAKEOFF',

  /**
   * Not yet reached requested cruise altitude
   *
   * Aircraft remain in this phase until reaching their requested cruise altitude (CRUISE)
   *
   * @memberof FLIGHT_PHASE
   * @property CLIMB
   * @type {string}
   */
  CLIMB: 'CLIMB',

  /**
   * Not yet cleared to descend below requested cruise altitude
   *
   * Aircraft remain in this phase until cleared to descend (DESCENT)
   *
   * @memberof FLIGHT_PHASE
   * @property CRUISE
   * @type {string}
   */
  CRUISE: 'CRUISE',

  /**
   * Instructed to enter (or already in) airborne holding pattern
   *
   * Aircraft remain in this phase until cleared out of the hold (CLIMB/CRUISE/DESCENT)
   *
   * @memberof FLIGHT_PHASE
   * @property HOLD
   * @type {string}
   */
  HOLD: 'HOLD',

  /**
   * Configured for (or already in) descent out of requested cruise altitude
   *
   * Aircraft remain in this phase until fully established on an approach (APPROACH)
   *
   * @memberof FLIGHT_PHASE
   * @property DESCENT
   * @type {string}
   */
  DESCENT: 'DESCENT',

  /**
   * Fully established on the approach, outside of the final approach fix
   *
   * Aircraft remain in this phase until within the final approach fix (LANDING)
   *
   * @memberof FLIGHT_PHASE
   * @property APPROACH
   * @type {string}
   */
  APPROACH: 'APPROACH',

  /**
   * Fully established on the approach, within the final approach fix
   *
   * Aircraft remain in this phase until instructed to go around (DESCENT)
   *   - If landing successful, they will remain in this phase until deletion
   *
   * @memberof FLIGHT_PHASE
   * @property LANDING
   * @type {string}
   */
  LANDING: 'LANDING'
};
/**
 * Enumerations for various performance constants
 *
 * @property PERFORMANCE
 * @type {Object}
 * @final
 */

exports.FLIGHT_PHASE = FLIGHT_PHASE;
var PERFORMANCE = {
  /**
   * Factor by which to increase the speed of deceleration on the ground as opposed
   * to while in flight, due to the effects of reverse thrust and braking
   *
   * @property DECELERATION_FACTOR_DUE_TO_GROUND_BRAKING
   * @type {Number}
   * @final
   */
  DECELERATION_FACTOR_DUE_TO_GROUND_BRAKING: 3.5,

  /**
   * Maximum vertical distance between the aircraft and the glidepath to
   * consider the aircraft to be "established on the glidepath"
   *
   * @property MAXIMUM_ALTITUDE_DIFFERENCE_CONSIDERED_ESTABLISHED_ON_GLIDEPATH
   * @type {number}
   * @final
   */
  MAXIMUM_ALTITUDE_DIFFERENCE_CONSIDERED_ESTABLISHED_ON_GLIDEPATH: 100,

  /**
  * Maximum distance from the current waypoint to allow us to proceed to the next waypoint
  * due to a tight turn, without requiring us to continue toward the current waypoint.
  *
  * @property MAXIMUM_DISTANCE_TO_FLY_BY_WAYPOINT_NM
  * @type {number}
  * @final
  */
  MAXIMUM_DISTANCE_TO_FLY_BY_WAYPOINT_NM: 5,

  /**
   * Maximum distance from the current waypoint to consider it to have been passed over,
   * allowing us to proceed to the next fix.
   *
   * @property MAXIMUM_DISTANCE_TO_PASS_WAYPOINT_NM
   * @type {number}
   * @final
   */
  MAXIMUM_DISTANCE_TO_PASS_WAYPOINT_NM: 0.5,

  /**
   * Maximum lateral offset from the approach course to consider the aircraft close enough
   * to be "established on the approach course", which is an important condition for applying
   * rules of separation.
   *
   * @property MAXIMUM_DISTANCE_CONSIDERED_ESTABLISHED_ON_APPROACH_COURSE_NM
   * @type {number}
   * @final
   */
  MAXIMUM_DISTANCE_CONSIDERED_ESTABLISHED_ON_APPROACH_COURSE_NM: 0.0822894,
  // appx. 500 feet

  /**
   * Maximum angular difference from the approach course heading to consider the aircraft close
   * to be "established on the approach course", which is an important condition for applying
   * rules of separation.
   *
   * @property MAXIMUM_ANGLE_CONSIDERED_ESTABLISHED_ON_APPROACH_COURSE
   * @type {number}
   * @final
   */
  MAXIMUM_ANGLE_CONSIDERED_ESTABLISHED_ON_APPROACH_COURSE: 0.0872665,
  // appx. 5 degrees

  /**
   * Maximum angular difference from the hold outbound heading to consider the aircraft close
   * to be "established on the hold course".
   *
   * @property MAXIMUM_ANGLE_CONSIDERED_ESTABLISHED_ON_HOLD_COURSE
   * @type {number}
   * @final
   */
  MAXIMUM_ANGLE_CONSIDERED_ESTABLISHED_ON_HOLD_COURSE: 0.0017453,
  // appx. 0.1 degrees

  /**
   * Altitude above the runway to which aircraft may descend on an instrument approach.
   * Note: Below this altitude, the aircraft is in landing mode
   *
   * @property INSTRUMENT_APPROACH_MINIMUM_DESCENT_ALTITUDE
   * @type {number}
   * @final
   */
  INSTRUMENT_APPROACH_MINIMUM_DESCENT_ALTITUDE: 200,

  /**
   * Length of time individual aircraft will require themselves to be established at Vref
   * (their landing speed) before landing. If they cannot reach that speed by that time, they
   * will not consider themselves on a "stable approach", and will likely go around.
   *
   * @memberof PERFORMANCE
   * @property STABLE_APPROACH_TIME_SECONDS
   * @type {number}
   * @final
   */
  STABLE_APPROACH_TIME_SECONDS: 60,

  /**
   * Altitude above the runway at which aircraft begin their on-course turn, in feet
   *
   * @property TAKEOFF_TURN_ALTITUDE
   * @type {number}
   * @final
   */
  TAKEOFF_TURN_ALTITUDE: 400,

  /**
   * Rate of turn, in radians per second
   *
   * @property TURN_RATE
   * @type {number}
   * @final
   */
  TURN_RATE: 0.0523598776,
  // 3 degrees

  /**
   * Proportion of the maximum capable descent rate that aircraft will use by default
   *
   * @property TYPICAL_DESCENT_FACTOR
   * @type {number}
   * @final
   */
  TYPICAL_DESCENT_FACTOR: 0.7,

  /**
   * Proportion of the maximum capable climb rate that aircraft will use by default
   *
   * @property TYPICAL_CLIMB_FACTOR
   * @type {number}
   * @final
   */
  TYPICAL_CLIMB_FACTOR: 0.7,

  /**
   * Standard pressure, the baseline used universally, is 1013.25 hPa, which is equivalent to 1013.25 mb or 29.92 inHg
   *
   * @property DEFAULT_ALTIMETER_IN_INHG
   * @type {number}
   * @final
   */
  DEFAULT_ALTIMETER_IN_INHG: 29.92
};
/**
 * Separation distances between aircraft
 *
 * @property SEPARATION
 * @type {Object}
 * @final
 */

exports.PERFORMANCE = PERFORMANCE;
var SEPARATION = {
  /**
   * 14.816km = 8nm (max possible sep minmum)
   *
   * @memberof SEPARATION
   * @property MAX_KM
   * @type {number}
   * @final
   */
  MAX_KM: 14.816,

  /**
   * Standard Basic Lateral Separation Minimum
   *
   * @memberof SEPARATION
   * @property STANDARD_LATERAL_KM
   * @type {number}
   * @final
   */
  STANDARD_LATERAL_KM: 5.556,
  // 3nm

  /**
   * Minimum vertical separation in feet
   *
   * @memberof SEPARATION
   * @property VERTICAL_FT
   * @type {number}
   * @final
   */
  VERTICAL_FT: 1000
};
exports.SEPARATION = SEPARATION;

},{}],304:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CALLSIGN_RANDOM_DIGIT_CHARACTER = exports.CALLSIGN_RANDOM_LETTER_CHARACTER = exports.DEFAULT_CALLSIGN_FORMAT = exports.AIRLINE_NAME_FLEET_SEPARATOR = void 0;

/**
 * Character used to separate the airline and fleet
 * Example: AAL airlines and long fleet -> 'AAL/long'
 *
 * @enum AIRLINE_NAME_FLEET_SEPARATOR
 * @type {string}
 */
var AIRLINE_NAME_FLEET_SEPARATOR = '/';
/**
 * Default callsign format
 *
 * @enum DEFAULT_CALLSIGN_FORMAT
 * @type {string}
*/

exports.AIRLINE_NAME_FLEET_SEPARATOR = AIRLINE_NAME_FLEET_SEPARATOR;
var DEFAULT_CALLSIGN_FORMAT = '###';
/**
 * Character used to represent a position where a random letter should be generated
 * in a callsign
 *
 * @enum CALLSIGN_RANDOM_LETTER_CHARACTER
 * @type {string}
*/

exports.DEFAULT_CALLSIGN_FORMAT = DEFAULT_CALLSIGN_FORMAT;
var CALLSIGN_RANDOM_LETTER_CHARACTER = '@';
/**
 * Character used to represent a position where a random digit should be generated
 * in a callsign
 *
 * @enum CALLSIGN_RANDOM_DIGIT_CHARACTER
 * @type {string}
*/

exports.CALLSIGN_RANDOM_LETTER_CHARACTER = CALLSIGN_RANDOM_LETTER_CHARACTER;
var CALLSIGN_RANDOM_DIGIT_CHARACTER = '#';
exports.CALLSIGN_RANDOM_DIGIT_CHARACTER = CALLSIGN_RANDOM_DIGIT_CHARACTER;

},{}],305:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_AIRPORT_ICAO = exports.AIRPORT_CONTROL_POSITION_NAME = exports.AIRPORT_CONSTANTS = void 0;

/**
 * @enum AIRPORT_CONSTANTS {object}
 * @type {object}
 * @final
 */
var AIRPORT_CONSTANTS = {
  /**
   * @memberof AIRPORT_CONSTANTS
   * @property DEFAULT_SPAWN_ALTITUDE_MIN
   * @type {number}
   * @final
   */
  DEFAULT_SPAWN_ALTITUDE_MIN: 10000,

  /**
   * @memberof AIRPORT_CONSTANTS
   * @property DEFAULT_SPAWN_ALTITUDE_MAX
   * @type {number}
   * @final
   */
  DEFAULT_SPAWN_ALTITUDE_MAX: 10000,

  /**
   * @memberof AIRPORT_CONSTANTS
   * @property DEFAULT_SPAWN_AIRCRAFT_SPEED_KTS
   * @type {number}
   * @final
   */
  DEFAULT_SPAWN_AIRCRAFT_SPEED_KTS: 250,

  /**
   * Distance out along final approach course where the FAF is located
   *
   * @memberof AIRPORT_CONSTANTS
   * @property FINAL_APPROACH_FIX_DISTANCE_NM
   * @type {number}
   * @final
   */
  FINAL_APPROACH_FIX_DISTANCE_NM: 5,

  /**
   * Maximum allowable indicated airspeed for aircraft below 10,000 feet MSL
   *
   * @memberof AIRPORT_CONSTANTS
   * @property MAX_SPEED_BELOW_10K_FEET
   * @type {number}
   * @final
   */
  MAX_SPEED_BELOW_10K_FEET: 250,

  /**
   * @memberof AIRPORT_CONSTANTS
   * @property MIN_ENTRAIL_DISTANCE_NM
   * @type {number}
   * @final
   */
  MIN_ENTRAIL_DISTANCE_NM: 5.5,
  SRS_REDUCED_MINIMA_FEET: {
    CAT1: 3000,
    CAT2: 4500,
    CAT3: 6000
  }
};
/**
 * List of control positions at the airport, used to differentiate which ATC callsign to used
 *
 * @enum AIRPORT_CONTROL_POSITION_NAME
 * @type {object}
 * @final
 */

exports.AIRPORT_CONSTANTS = AIRPORT_CONSTANTS;
var AIRPORT_CONTROL_POSITION_NAME = {
  /**
  * Provides approach control services
  *
  * @memberof AIRPORT_CONTROL_POSITION_NAME
  * @property APPROACH
  * @type {string}
  * @final
  */
  APPROACH: 'app',

  /**
  * Provides departure control services
  *
  * @memberof AIRPORT_CONTROL_POSITION_NAME
  * @property TOWER
  * @type {string}
  * @final
  */
  DEPARTURE: 'dep',

  /**
  * Provides Air Traffic Control Tower (ATCT) services for surface and runway movements
  *
  * @memberof AIRPORT_CONTROL_POSITION_NAME
  * @property TOWER
  * @type {string}
  * @final
  */
  TOWER: 'twr'
};
/**
 * ICAO identifier of the airport to show after initial load
 *
 * @enum DEFAULT_AIRPORT_ICAO
 * @type {string}
 * @final
 */

exports.AIRPORT_CONTROL_POSITION_NAME = AIRPORT_CONTROL_POSITION_NAME;
var DEFAULT_AIRPORT_ICAO = 'ksea';
exports.DEFAULT_AIRPORT_ICAO = DEFAULT_AIRPORT_ICAO;

},{}],306:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PAN = exports.SCALE = exports.DEFAULT_CANVAS_SIZE = exports.BASE_CANVAS_FONT = exports.CANVAS_NAME = void 0;

/**
 * Enumeration of canvas names
 *
 * @enum CANVAS_NAME
 * @final
 */
var CANVAS_NAME = {
  /**
   * Name of the `static` canvas.
   *
   * This canvas should hold all of the items that do not update every frame;
   * things like terrain, fixes, video map, etc
   *
   * @memberOf CANVAS_NAME
   * @property STATIC
   */
  STATIC: 'static',

  /**
   * Name of the `dynamic` canvas.
   *
   * This canvas should hold all of the items that do update every frame;
   * things like aircraft, aircraft data blocks, etc
   *
   * @memberOf CANVAS_NAME
   * @property STATIC
   */
  DYNAMIC: 'dynamic'
};
/**
 * @enum BASE_CANVAS_FONT
 * @final
 */

exports.CANVAS_NAME = CANVAS_NAME;
var BASE_CANVAS_FONT = '10px monoOne, monospace';
/**
 * @enum DEFAULT_CANVAS_SIZE
 * @final
 */

exports.BASE_CANVAS_FONT = BASE_CANVAS_FONT;
var DEFAULT_CANVAS_SIZE = {
  HEIGHT: 480,
  WIDTH: 640,
  FOTTER_HEIGHT_OFFSET: 36
};
/**
 * @enum SCALE
 * @final
 */

exports.DEFAULT_CANVAS_SIZE = DEFAULT_CANVAS_SIZE;
var SCALE = {
  // TODO: not a fan of this name
  CHANGE_FACTOR: 0.9,
  DEFAULT: 8,
  MIN: 1,
  MAX: 80
};
/**
 * @enum PAN
 * @final
 */

exports.SCALE = SCALE;
var PAN = {
  X: 0,
  Y: 0
};
exports.PAN = PAN;

},{}],307:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ENVIRONMENT = void 0;

/**
 * @enum ENVIRONMENT {object}
 * @type {object}
 * @final
 */
var ENVIRONMENT = {
  /**
   * @memberof ENVIRONMENT
   * @property WIND_INCREASE_FACTOR_PER_FT
   * @type {number}
   * @final
   */
  WIND_INCREASE_FACTOR_PER_FT: 0.00002,
  // 2.00% per thousand feet

  /**
   * Factor at which density altitude increases per foot of altitude.
   * NOTE: At a higher density altitude, the same IAS will yield a higher TAS.
   *       Consider density altitude to be directly proportionate to the amount
   *       by which the TAS increases above the IAS. Therefore, this value also
   *       represents how much the TAS will increase per foot.
   *
   * @memberof ENVIRONMENT
   * @property DENSITY_ALT_INCREASE_FACTOR_PER_FT
   * @type {number}
   * @final
   */
  DENSITY_ALT_INCREASE_FACTOR_PER_FT: 0.000016 // 0.16% per thousand feet

};
exports.ENVIRONMENT = ENVIRONMENT;

},{}],308:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AIRCRAFT_EVENT = exports.EVENT = void 0;

/**
 * Enum containing all triggerable events triggered via the `EventBus`
 *
 * Before adding an event, every effort should be made to communicate
 * accross classes with direct imports. Events are available but can
 * be harder to debug and follow. Use with caution.
 *
 * @property EVENT
 * @type {Object}
 * @final
 */
var EVENT = {
  /**
   * Add an aircraft to the simulation
   *
   * @memberof EVENT
   * @property ADD_AIRCRAFT
   * @type {string}
   */
  ADD_AIRCRAFT: 'add-aircraft',

  /**
   * @memberof EVENT
   * @property AIRPORT_CHANGE
   * @type {string}
   */
  AIRPORT_CHANGE: 'airport-change',

  /**
   * A click was registered outside of a specific `StripViewModel`
   * and the active strip, if any, should have the `active`
   * css classname removed
   *
   * @memberof EVENT
   * @property DESELECT_AIRCRAFT
   * @type {string}
   */
  DESELECT_AIRCRAFT: 'deselect-aircraft',

  /**
   * Event used to notify the `CanvasController` when a re-draw
   * should happen outside of the usual game loop.
   *
   * This should only occur as a result of a user action
   *
   * @memberof EVENT
   * @property MARK_SHALLOW_RENDER
   * @type {string}
   */
  MARK_SHALLOW_RENDER: 'mark-shallow-render',

  /**
   * A pan event has been detected necessitating an entire redraw of each canvas
   *
   * This may constitute a pan-in-progress and not the completion of a panning action
   *
   * @memberof EVENT
   * @property PAN_VIEWPORT
   * @type {string}
   */
  PAN_VIEWPORT: 'pan-viewport',

  /**
   * Fired when the update loop should be either paused or resumed.
   *
   * Usually called when airport data is changing (ie, when a new airport
   * is being loaded).
   *
   * @memberof EVENT
   * @property PAUSE_UPDATE_LOOP
   * @type {string}
   */
  PAUSE_UPDATE_LOOP: 'pause-update-loop',

  /**
   * Increase the length of the PTL lines on the scope
   *
   * @memberof EVENT
   * @property PTL_DECREASE_LENGTH
   * @type {string}
   */
  PTL_DECREASE_LENGTH: 'ptl-decrease-length',

  /**
   * Increase the length of the PTL lines on the scope
   *
   * @memberof EVENT
   * @property PTL_INCREASE_LENGTH
   * @type {string}
   */
  PTL_INCREASE_LENGTH: 'ptl-increase-length',

  /**
   * Remove an aircraft from the sim
   *
   * Usually as a result of the `del` user command
   *
   * @memberof EVENT
   * @property REMOVE_AIRCRAFT
   * @type {string}
   */
  REMOVE_AIRCRAFT: 'remove-aircraft',

  /**
   * Remove an `AircraftConflict` for an aircraft
   *
   * @memberof EVENT
   * @property REMOVE_AIRCRAFT_CONFLICT
   * @type {string}
   */
  REMOVE_AIRCRAFT_CONFLICT: 'remove-aircraft-conflict',

  /**
   * An aircraft has been located and needs to be centered in the view
   *
   * @memberof EVENT
   * @property REQUEST_TO_CENTER_POINT_IN_VIEW
   * @type {string}
   */
  REQUEST_TO_CENTER_POINT_IN_VIEW: 'request-to-center-point-in-view',

  /**
   * An aircraft data block was clicked and the corresponding
   * `StripViewModel` must also be selected
   *
   * @memberof EVENT
   * @property SELECT_AIRCRAFT
   * @type {string}
   */
  SELECT_AIRCRAFT: 'select-aircraft',

  /**
   * An aircraft progress strip was clicked
   *
   * @memberof EVENT
   * @property STRIP_CLICK
   * @type {string}
   */
  STRIP_CLICK: 'strip-click',

  /**
   * An aircraft progress strip was double clicked
   *
   * @memberof EVENT
   * @property STRIP_DOUBLE_CLICK
   * @type {string}
   */
  STRIP_DOUBLE_CLICK: 'strip-double-click',

  /**
   * Change the active theme to the specified theme name
   *
   * @memberof EVENT
   * @property SET_THEME
   * @type {string}
   */
  SET_THEME: 'set-theme',

  /**
   * Step through pre-defined timewarp speeds
   *
   * @memberof EVENT
   * @property TIMEWARP_TOGGLE
   * @type {string}
   */
  TIMEWARP_TOGGLE: 'timewarp-toggle',

  /**
   * @memberof EVENT
   * @property TOGGLE_AIRPORT_GUIDE
   * @type {string}
   */
  TOGGLE_AIRPORT_GUIDE: 'toggle-airport-guide',

  /**
   * @memberof EVENT
   * @property TOGGLE_AIRSPACE
   * @type {string}
   */
  TOGGLE_AIRSPACE: 'toggle-airspace',

  /**
   * @memberof EVENT
   * @property TOGGLE_CHANGELOG
   * @type {string}
   */
  TOGGLE_CHANGELOG: 'toggle-changelog',

  /**
   * @memberof EVENT
   * @property TOGGLE_LABELS
   * @type {string}
   */
  TOGGLE_LABELS: 'toggle-labels',

  /**
   * Pause/unpause the game loop
   *
   * @memberof EVENT
   * @property TOGGLE_PAUSE
   * @type {string}
   */
  TOGGLE_PAUSE: 'toggle-pause',

  /**
   * @memberof EVENT
   * @property TOGGLE_RESTRICTED_AREAS
   * @type {string}
   */
  TOGGLE_RESTRICTED_AREAS: 'toggle-restricted-areas',

  /**
   * @memberof EVENT
   * @property TOGGLE_SID_MAP
   * @type {string}
   */
  TOGGLE_SID_MAP: 'toggle-sid-map',

  /**
   * @memberof EVENT
   * @property TOGGLE_STAR_MAP
   * @type {string}
   */
  TOGGLE_STAR_MAP: 'toggle-star-map',

  /**
   * @memberof EVENT
   * @property TOGGLE_TERRAIN
   * @type {string}
   */
  TOGGLE_TERRAIN: 'toggle-terrain',

  /**
   * @memberof EVENT
   * @property TOGGLE_TRAFFIC
   * @type {string}
   */
  TOGGLE_TRAFFIC: 'toggle-traffic',

  /**
   * Open/close the tutorial modal
   *
   * @memberof EVENT
   * @property TOGGLE_TUTORIAL
   * @type {string}
   */
  TOGGLE_TUTORIAL: 'toggle-tutorial',

  /**
   * @memberof EVENT
   * @property TOGGLE_VIDEO_MAP
   * @type {string}
   */
  TOGGLE_VIDEO_MAP: 'toggle-video-map',

  /**
   * @memberof EVENT
   * @property RANGE_RINGS_CHANGE
   * @type {string}
   */
  RANGE_RINGS_CHANGE: 'range-rings-change',

  /**
   * @memberof EVENT
   * @property MEASURE_TOOL_STYLE_CHANGE
   * @type {string}
   */
  MEASURE_TOOL_STYLE_CHANGE: 'measure-tool-style-change',

  /**
   * A click has been registered in the unpause button shown within the
   * screen overlay whil the app is paused
   *
   * @memberof EVENT
   * @property UNPAUSE
   * @type {string}
   */
  UNPAUSE: 'unpause',

  /**
   * The zoom level has changed necessitating an entire redraw of each canvas
   *
   * @memberof EVENT
   * @property ZOOM_VIEWPORT
   * @type {string}
   */
  ZOOM_VIEWPORT: 'zoom-viewport'
};
exports.EVENT = EVENT;
var AIRCRAFT_EVENT = {
  /**
   * Triggered when the aircraft received takeoff clearance.
   *
   * @memberof AIRCRAFT_EVENT
   * @property TAKEOFF
   * @type {string}
   */
  TAKEOFF: 'takeoff',

  /**
   * Trigged when the aircraft enters the approach
   *
   * @memberof AIRCRAFT_EVENT
   * @property APPROACH
   * @type {string}
   */
  APPROACH: 'approach',

  /**
   * Trigged when the aircraft reaches its final approach
   *
   * @memberof AIRCRAFT_EVENT
   * @property FINAL_APPROACH
   * @type {string}
   */
  FINAL_APPROACH: 'final-approach',

  /**
   * FOR FUTURE USE. Should be trigged when the aircraft landed on the runway.
   *
   * @memberof AIRCRAFT_EVENT
   * @property LANDING
   * @type {string}
   */
  LANDING: 'landing',

  /**
   * The aircraft landed and came to a fullstop.
   *
   * @memberof AIRCRAFT_EVENT
   * @property FULLSTOP
   * @type {string}
   */
  FULLSTOP: 'fullstop',

  /**
   * Triggered when the aircraft exits the airspace.
   *
   * @memberof AIRCRAFT_EVENT
   * @property AIRSPACE_EXIT
   * @type {string}
   */
  AIRSPACE_EXIT: 'airspace-exit'
};
exports.AIRCRAFT_EVENT = AIRCRAFT_EVENT;

},{}],309:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GAME_OPTION_VALUES = exports.GAME_OPTION_NAMES = void 0;

var _eventNames = require("./eventNames");

var _inputConstants = require("./inputConstants");

/* eslint-disable max-len, import/prefer-default-export */

/**
 * Name enumeration of available game options
 *
 * @property GAME_OPTION_NAMES
 * @type {Object}
 * @final
 */
var GAME_OPTION_NAMES = {
  CONTROL_METHOD: 'controlMethod',
  DRAW_PROJECTED_PATHS: 'drawProjectedPaths',
  DRAW_ILS_DISTANCE_SEPARATOR: 'drawIlsDistanceSeparator',
  MEASURE_TOOL_PATH: 'measureToolPath',
  MOUSE_CLICK_DRAG: 'mouseClickDrag',
  PROJECTED_TRACK_LINE_LENGTHS: 'ptlLengths',
  RANGE_RINGS: 'rangeRings',
  SOFT_CEILING: 'softCeiling',
  THEME: 'theme'
};
/**
 * User options
 *
 * These options are presented in a modal and are stored in localStorage
 *
 * @property GAME_OPTION_VALUES
 * @type {array<object>}
 * @final
 */

exports.GAME_OPTION_NAMES = GAME_OPTION_NAMES;
var GAME_OPTION_VALUES = [{
  name: GAME_OPTION_NAMES.THEME,
  defaultValue: 'DEFAULT',
  description: 'Scope Theme',
  type: 'select',
  onChangeEventHandler: _eventNames.EVENT.SET_THEME,
  optionList: [{
    displayLabel: 'Classic',
    value: 'CLASSIC'
  }, {
    displayLabel: 'Default',
    value: 'DEFAULT'
  }]
}, {
  name: GAME_OPTION_NAMES.CONTROL_METHOD,
  defaultValue: 'classic',
  description: 'Control Method',
  type: 'select',
  onChangeEventHandler: null,
  optionList: [{
    displayLabel: 'Classic',
    value: 'classic'
  }, {
    displayLabel: 'Arrow Keys',
    value: 'arrows'
  }]
}, {
  name: GAME_OPTION_NAMES.DRAW_ILS_DISTANCE_SEPARATOR,
  defaultValue: 'from-theme',
  description: 'Show trailing separation indicator on ILS',
  help: 'Draw a trailing indicator 2.5 NM (4.6km) behind landing aircraft to help with traffic spacing',
  type: 'select',
  onChangeEventHandler: null,
  optionList: [{
    displayLabel: 'From Theme',
    value: 'from-theme'
  }, {
    displayLabel: 'Yes',
    value: 'yes'
  }, {
    displayLabel: 'No',
    value: 'no'
  }]
}, {
  name: GAME_OPTION_NAMES.PROJECTED_TRACK_LINE_LENGTHS,
  defaultValue: '1-2-4-8',
  description: 'Projected Track Line (PTL) increments, in minutes',
  type: 'select',
  onChangeEventHandler: null,
  optionList: [{
    displayLabel: '1-2-4-8',
    value: '1-2-4-8'
  }, {
    displayLabel: '1-2-4-6-8-10-12-14-16',
    value: '1-2-4-6-8-10-12-14-16'
  }, {
    displayLabel: '1-2-3-4-5-6-7-8',
    value: '1-2-3-4-5-6-7-8'
  }]
}, {
  name: GAME_OPTION_NAMES.DRAW_PROJECTED_PATHS,
  defaultValue: 'selected',
  description: 'Draw aircraft projected path',
  type: 'select',
  onChangeEventHandler: null,
  optionList: [{
    displayLabel: 'Always',
    value: 'always'
  }, {
    displayLabel: 'Selected',
    value: 'selected'
  }, {
    displayLabel: 'Never',
    value: 'never'
  }]
}, {
  name: GAME_OPTION_NAMES.SOFT_CEILING,
  defaultValue: 'yes',
  description: 'Allow departures via climb',
  help: 'Normally aircraft departs the airspace by flying beyond the horizontal bounds.  If set to yes, aircraft may also depart the airspace by climbing above it.',
  type: 'select',
  onChangeEventHandler: null,
  optionList: [{
    displayLabel: 'Yes',
    value: 'yes'
  }, {
    displayLabel: 'No',
    value: 'no'
  }]
}, {
  name: GAME_OPTION_NAMES.MOUSE_CLICK_DRAG,
  defaultValue: 'right',
  description: 'Panning Button',
  help: 'Which mouse button (left or right) should drag the canvas when held',
  type: 'select',
  onChangeEventHandler: null,
  optionList: [{
    displayLabel: 'Left Click',
    value: 'left'
  }, {
    displayLabel: 'Right Click',
    value: 'right'
  }]
}, {
  name: GAME_OPTION_NAMES.RANGE_RINGS,
  defaultValue: 'default',
  description: 'Range rings',
  help: 'Radius of range rings, in nautical miles',
  type: 'select',
  onChangeEventHandler: _eventNames.EVENT.RANGE_RINGS_CHANGE,
  optionList: [{
    displayLabel: 'Default',
    value: 'default'
  }, {
    displayLabel: 'Off',
    value: 'off'
  }, {
    displayLabel: '1 nm',
    value: 1
  }, {
    displayLabel: '2 nm',
    value: 2
  }, {
    displayLabel: '5 nm',
    value: 5
  }, {
    displayLabel: '10 nm',
    value: 10
  }, {
    displayLabel: '15 nm',
    value: 15
  }, {
    displayLabel: '20 nm',
    value: 20
  }]
}, {
  name: GAME_OPTION_NAMES.MEASURE_TOOL_PATH,
  defaultValue: '0',
  description: 'Measure path style',
  help: 'How the path is rendered when using the range/bearing measuring tool',
  type: 'select',
  onChangeEventHandler: _eventNames.EVENT.MEASURE_TOOL_STYLE_CHANGE,
  optionList: [{
    displayLabel: 'Straight lines only',
    value: _inputConstants.MEASURE_TOOL_STYLE.STRAIGHT
  }, {
    displayLabel: 'Arc to next fix, then straight',
    value: _inputConstants.MEASURE_TOOL_STYLE.ARC_TO_NEXT
  }, {
    displayLabel: 'All lines arced',
    value: _inputConstants.MEASURE_TOOL_STYLE.ALL_ARCED
  }]
}];
exports.GAME_OPTION_VALUES = GAME_OPTION_VALUES;

},{"./eventNames":308,"./inputConstants":311}],310:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.INVALID_INDEX = exports.INVALID_NUMBER = exports.PHYSICS_CONSTANTS = exports.REGEX = exports.TIME = void 0;

/**
 * Commonly used time conversion rates
 *
 * @property TIME
 * @type {Object}
 * @final
 */
var TIME = {
  ONE_HOUR_IN_SECONDS: 3600,
  ONE_HOUR_IN_MINUTES: 60,
  ONE_HOUR_IN_MILLISECONDS: 3600000,
  ONE_MINUTE_IN_HOURS: 1 / 60,
  ONE_MINUTE_IN_SECONDS: 60,
  ONE_MINUTE_IN_MILLISECONDS: 60000,
  ONE_SECOND_IN_HOURS: 1 / 3600,
  ONE_SECOND_IN_MINUTES: 1 / 60,
  ONE_SECOND_IN_MILLISECONDS: 1000,
  ONE_MILLISECOND_IN_HOURS: 1 / 3600000,
  ONE_MILLISECOND_IN_MINUTES: 1 / 60000,
  ONE_MILLISECOND_IN_SECONDS: 1 / 1000
};
/**
 * Regular expressions
 *
 * @property REGEX
 * @type {Object}
 * @final
 */

exports.TIME = TIME;
var REGEX = {
  ALTITUDE_RESTRICTION: /^A([0-9]{1,3})([+-]?)$/,
  COMPASS_DIRECTION: /^[NESW]/,
  DOUBLE_DOT: /\.\./g,
  HOLD_DISTANCE: /^([1-9]|1[0-9])(nm|min)$/i,
  LAT_LONG: /^([NESW])(\d+(\.\d+)?)([d °](\d+(\.\d+)?))?([m '](\d+(\.\d+)?))?$/,
  SPEED_RESTRICTION: /^S([1-9][0-9]{2})([+-]?)$/,
  SW: /[SW]/,
  SINGLE_DOT: /\./g,
  THREE_DIGIT_NUMBER: /^[0-9]{3}$/,
  TRANSPONDER_CODE: /^[0-7][0-7][0-7][0-7]$/,
  UNICODE: /[^\u0000-\u00ff]/,
  WHITESPACE: /\s/g
};
/**
 * A collection of constant values used in physics calculations
 *
 * @property PHYSICS_CONSTANTS
 * @type {Object}
 * @final
 */

exports.REGEX = REGEX;
var PHYSICS_CONSTANTS = {
  /**
   * Average radius of simplified earth spheroid, in nautical miles
   * Note: Calculated from conversion of 3440nm to km
   *
   * @property EARTH_RADIUS_NM
   * @type {number}
   * @final
   */
  EARTH_RADIUS_KM: 6370.88,

  /**
   * Average radius of simplified earth spheroid, in nautical miles
   *
   * @property EARTH_RADIUS_NM
   * @type {number}
   * @final
   */
  EARTH_RADIUS_NM: 3440,

  /**
   * Acceleration due to force of gravity, in m/s
   *
   * @property GRAVITATIONAL_MAGNITUDE
   * @type {number}
   * @final
   */
  GRAVITATIONAL_MAGNITUDE: 9.81
};
/**
 * Value used to indicate an invalid or otherwise unset Value
 * Examples include invalid array index, and numeric properties that have
 * no real value set other than the value (this value) set at initilization.
 *
 * @enum INVALID_NUMBER
 * @type {number}
 * @final
 */

exports.PHYSICS_CONSTANTS = PHYSICS_CONSTANTS;
var INVALID_NUMBER = -1;
/**
 * Enumeration for an invalid index number.
 *
 * @enum INVALID_INDEX
 * @type {number}
 * @final
 */

exports.INVALID_NUMBER = INVALID_NUMBER;
var INVALID_INDEX = -1;
exports.INVALID_INDEX = INVALID_INDEX;

},{}],311:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PARSED_COMMAND_NAME = exports.MOUSE_EVENT_CODE = exports.MOUSE_BUTTON_NAMES = exports.MEASURE_TOOL_STYLE = exports.LEGACY_KEY_CODES = exports.KEY_CODES = exports.COMMAND_CONTEXT = void 0;

/**
 * Context of commands entered into command bar
 *
 * @enum COMMAND_CONTEXT
 * @type {object}
 */
var COMMAND_CONTEXT = {
  AIRCRAFT: 'aircraft',
  SCOPE: 'scope'
};
/**
 * Enumeration of key codes used for inputs.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
 *
 * @property KEY_CODES
 * @type {Object}
 * @final
 */

exports.COMMAND_CONTEXT = COMMAND_CONTEXT;
var KEY_CODES = {
  CONTROL_LEFT: 'ControlLeft',
  CONTROL_RIGHT: 'ControlRight',
  SHIFT_LEFT: 'ShiftLeft',
  SHIFT_RIGHT: 'ShiftRight',
  ENTER: 'Enter',
  ESCAPE: 'Escape',
  TAB: 'Tab',
  PAGE_UP: 'PageUp',
  PAGE_DOWN: 'PageDown',
  // numpad
  NUM_MULTIPLY: 'NumpadMultiply',
  NUM_ADD: 'NumpadAdd',
  NUM_SUBTRACT: 'NumpadSubtract',
  NUM_DIVIDE: 'NumpadDivide',
  NUM_ENTER: 'NumpadEnter',
  // arrow keys
  LEFT_ARROW: 'ArrowLeft',
  UP_ARROW: 'ArrowUp',
  RIGHT_ARROW: 'ArrowRight',
  DOWN_ARROW: 'ArrowDown',
  // F-Keys
  F1: 'F1',
  F2: 'F2',
  F3: 'F3',
  F4: 'F4',
  F5: 'F5',
  F6: 'F6',
  F7: 'F7',
  F8: 'F8',
  F9: 'F9',
  F10: 'F10',
  F11: 'F11',
  F12: 'F12',
  // `
  BAT_TICK: 'Backquote'
};
/**
 * Enumeration of key codes used for inputs (for older browsers like IE)
 *
 * @property LEGACY_KEY_CODES
 * @type {Object}
 * @final
 */

exports.KEY_CODES = KEY_CODES;
var LEGACY_KEY_CODES = {
  ENTER: 13,
  ESCAPE: 27,
  TAB: 9,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  // numpad
  NUM_MULTIPLY: 106,
  NUM_ADD: 107,
  NUM_SUBTRACT: 109,
  NUM_DIVIDE: 111,
  // arrow keys
  LEFT_ARROW: 37,
  UP_ARROW: 38,
  RIGHT_ARROW: 39,
  DOWN_ARROW: 40,
  // F-Keys
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  // `
  BAT_TICK: 220
};
/**
 * Enumeration of the render styles used by `MeasureTool`
 */

exports.LEGACY_KEY_CODES = LEGACY_KEY_CODES;
var MEASURE_TOOL_STYLE = {
  STRAIGHT: 'straight',
  ARC_TO_NEXT: 'initial_turn',
  ALL_ARCED: 'arced'
};
/**
 * Enumeration of the mouse button names
 *
 * @property MOUSE_BUTTON_NAMES
 * @type {Object}
 * @final
 */

exports.MEASURE_TOOL_STYLE = MEASURE_TOOL_STYLE;
var MOUSE_BUTTON_NAMES = {
  LEFT: 'left',
  MIDDLE: 'middle',
  RIGHT: 'right'
};
/**
 * Enumeration of mouse events returned from $event.which
 *
 * These codes can only be used with jQuery event object.
 *
 * @property MOUSE_EVENT_CODE
 * @type {Object}
 * @final
 */

exports.MOUSE_BUTTON_NAMES = MOUSE_BUTTON_NAMES;
var MOUSE_EVENT_CODE = {
  LEFT_PRESS: 1,
  MIDDLE_PRESS: 2,
  RIGHT_PRESS: 3
};
/**
 * Name of a command returned from the Parser
 *
 * @property PARSED_COMMAND_NAME
 * @type {Object}
 * @final
 */

exports.MOUSE_EVENT_CODE = MOUSE_EVENT_CODE;
var PARSED_COMMAND_NAME = {
  AIRAC: 'airac',
  AIRPORT: 'airport',
  AUTO: 'auto',
  CLEAR: 'clear',
  PAUSE: 'pause',
  RATE: 'rate',
  TIMEWARP: 'timewarp',
  TRANSMIT: 'transmit',
  TUTORIAL: 'tutorial'
};
exports.PARSED_COMMAND_NAME = PARSED_COMMAND_NAME;

},{}],312:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LOG = void 0;

/**
 * @property LOG
 * @type {Object}
 * @final
 */
var LOG = {
  DEBUG: 0,
  INFO: 1,
  WARNING: 2,
  ERROR: 3,
  FATAL: 4
};
exports.LOG = LOG;

},{}],313:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RELATIVE_POSITION_OFFSET_INDEX = exports.GPS_COORDINATE_INDEX = exports.DEFAULT_SCREEN_POSITION = void 0;

/**
 * Screen position to default to if the actual position cannot be calculated, in shape of [x,y]
 *
 * @property DEFAULT_SCREEN_POSITION
 * @type {Array}
 * @final
 */
var DEFAULT_SCREEN_POSITION = [0, 0];
/**
 * Map of the content of all indices of the array parsed into the position model
 *
 * @property GPS_COORDINATE_INDEX
 * @type {Object}
 * @final
 */

exports.DEFAULT_SCREEN_POSITION = DEFAULT_SCREEN_POSITION;
var GPS_COORDINATE_INDEX = {
  /**
   * @property LATITUDE
   * @type {number}
   * @final
   */
  LATITUDE: 0,

  /**
   * @property LONGITUDE
   * @type {number}
   * @final
   */
  LONGITUDE: 1,

  /**
   * @property ELEVATION
   * @type {number}
   * @final
   */
  ELEVATION: 2
};
/**
 * Map of the content of all the indices of the relativePosition array
 *
 * @property RELATIVE_POSITION_OFFSET_INDEX
 * @type {Object}
 * @final
 */

exports.GPS_COORDINATE_INDEX = GPS_COORDINATE_INDEX;
var RELATIVE_POSITION_OFFSET_INDEX = {
  /**
   * @property LATITUDINAL
   * @type {number}
   * @final
   */
  LATITUDINAL: 0,

  /**
   * @property LONGITUDINAL
   * @type {number}
   * @final
   */
  LONGITUDINAL: 1
};
exports.RELATIVE_POSITION_OFFSET_INDEX = RELATIVE_POSITION_OFFSET_INDEX;

},{}],314:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PROCEDURE_TYPE = exports.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER = exports.LEG_TYPE = exports.DIRECT_SEGMENT_DIVIDER = void 0;

/**
* Symbol that divides each direct segment
*
* @enum DIRECT_SEGMENT_DIVIDER
* @type {string}
* @final
*/
var DIRECT_SEGMENT_DIVIDER = '..';
/**
* Known types of `LegModel`s
*
* @enum LEG_TYPE
* @type {object}
* @final
*/

exports.DIRECT_SEGMENT_DIVIDER = DIRECT_SEGMENT_DIVIDER;
var LEG_TYPE = {
  /**
  * For legs following an airway from entry point to exit point
  *
  * @memberof LEG_TYPE
  * @property AIRWAY
  * @type {string}
  */
  AIRWAY: 'airway',

  /**
  * For legs that are simply direct from the previous fix to the next fix
  *
  * @memberof LEG_TYPE
  * @property DIRECT
  * @type {string}
  */
  DIRECT: 'direct',

  /**
  * For legs following an instrument procedure from entry point to exit point
  *
  * This currently includes SIDs and STARs (though additional procedures are planned)
  *
  * @memberof LEG_TYPE
  * @property PROCEDURE
  * @type {string}
  */
  PROCEDURE: 'procedure'
};
/**
* Symbol that divides each route segment
*
* @enum PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER
* @type {string}
* @final
*/

exports.LEG_TYPE = LEG_TYPE;
var PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER = '.';
/**
* @property PROCEDURE_TYPE
* @type {Object}
* @final
*/

exports.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER = PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER;
var PROCEDURE_TYPE = {
  SID: 'SID',
  STAR: 'STAR'
};
exports.PROCEDURE_TYPE = PROCEDURE_TYPE;

},{}],315:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DATA_BLOCK_POSITION_MAP = exports.DATA_BLOCK_DIRECTION_LENGTH_SEPARATOR = void 0;

/**
 * Character used to separate the data block direction and length when specified
 * in a scope command. Example: '3/2' --> direction '3' and length '2'
 *
 * @enum DATA_BLOCK_DIRECTION_LENGTH_SEPARATOR
 * @type {string}
 */
var DATA_BLOCK_DIRECTION_LENGTH_SEPARATOR = '/';
/**
 * Map of which number position correlates to what heading away from the
 * aircraft to draw the leader line and data block
 *
 * @enum DATA_BLOCK_POSITION_MAP
 * @type {object}
 */

exports.DATA_BLOCK_DIRECTION_LENGTH_SEPARATOR = DATA_BLOCK_DIRECTION_LENGTH_SEPARATOR;
var DATA_BLOCK_POSITION_MAP = {
  8: 360,
  9: 45,
  6: 90,
  3: 135,
  2: 180,
  1: 225,
  4: 270,
  7: 315,
  5: 'ctr'
};
exports.DATA_BLOCK_POSITION_MAP = DATA_BLOCK_POSITION_MAP;

},{}],316:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SELECTORS = exports.IDS = exports.CLASSNAMES = void 0;

var _mapValues2 = _interopRequireDefault(require("lodash/mapValues"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// TODO: Why are SO many element-specific selectors classes instead of IDs?
// We are for some reason defining an ID, and sometimes finding the element by
// searching the ID name, and other times we are searching by the id-specific
// class name that is also assigned to that specific element... why?

/**
 * CSS classnames used throught the app.
 *
 * @property CLASSNAMES
 * @type {Object}
 * @final
 */
var CLASSNAMES = {
  ACTIVE: 'active',
  AIRCRAFT: 'aircraft',
  AIRPORT_GUIDE_VIEW: 'js-airportGuide-view',
  AIRPORT_LIST: 'airport-list',
  AIRPORT_LIST_ITEM: 'airport-list-item',
  AIRPORT_LIST_ITEM_IS_ACTIVE: 'mix-airport-list-item_isActive',
  ALL_SET: 'allSet',
  ALTITUDE: 'altitude',
  ARRIVAL: 'arrival',
  BLACKBOX: 'blackBox',
  CALLSIGN: 'callsign',
  CHANGELOG_CONTAINER: 'js-changelogContainer',
  CHANGELOG_CONTENT: 'js-changelog',
  CHANGELOG_VERSION: 'changelog-version',
  CONTROL: 'control',
  DEPARTURE: 'departure',
  DESTINATION: 'destination',
  DIALOG: 'dialog',
  DIALOG_BODY: 'dialog-body',
  FAST_FORWARDS: 'fast-forwards',
  FOLLOWING_STAR: 'followingSTAR',
  FORM_VALUE: 'form-value',
  HEADING: 'heading',
  HIDDEN: 'hidden',
  HOLD: 'hold',
  LEFT: 'left',
  LOADING_VIEW: 'js-loadingView',
  LOOKING_GOOD: 'lookingGood',
  MESSAGE: 'message',
  NEGATIVE: 'negative',
  NEXT: 'next',
  NOT_SELECTABLE: 'notSelectable',
  OPEN: 'open',
  OPTIONS_DIALOG: 'option-dialog',
  TRAFFIC_DIALOG: 'traffic-dialog',
  OVERFLIGHT: 'overflight',
  PAUSED: 'paused',
  PREV: 'prev',
  RIGHT: 'right',
  RUNWAY: 'runway',
  SPEED_2: 'speed-2',
  SPEED_5: 'speed-5',
  SPEED: 'speed',
  STRIP_VIEW_AIRCRAFT_TYPE: '.js-stripView-aircraftModel',
  STRIP_VIEW_ALTERNATE_AIRPORT_ID: '.js-stripView-alternateAirportId',
  STRIP_VIEW_ARRIVAL_AIRPORT_ID: '.js-stripView-arrivalAirportId',
  STRIP_VIEW_ARRIVALS_LIST: 'js-stripViewArrivals-list',
  STRIP_VIEW_ASSIGNED_ALTITUDE: '.js-stripView-assignedAltitude',
  STRIP_VIEW_CALLSIGN: '.js-stripView-callsign',
  STRIP_VIEW_CID: '.js-stripView-cid',
  STRIP_VIEW_DEPARTURE_AIRPORT_ID: '.js-stripView-departureAirportId',
  STRIP_VIEW_DEPARTURES_LIST: 'js-stripViewDepartures-list',
  STRIP_VIEW_FLIGHT_PLAN_ALTITUDE: '.js-stripView-flightPlanAltitude',
  STRIP_VIEW_FLIGHT_PLAN: '.js-stripView-flightPlan',
  STRIP_VIEW_IS_HIDDEN: 'mix-stripView_isHidden',
  STRIP_VIEW_PREPLANNING: 'stripView-preplanning',
  STRIP_VIEW_REMARKS: '.js-stripView-remarks',
  STRIP_VIEW_RUNWAY: '.js-stripView-runway',
  STRIP_VIEW_TRANSPONDER: '.js-stripView-transponder',
  STRIP_VIEW_TRIGGER: 'js-stripView-trigger',
  STRIP_VIEW: 'js-stripView',
  STRIP: 'strip',
  SWITCH_AIRPORT: 'switch-airport',
  TOGGLE_AIRPORT_GUIDE: 'toggle-airport-guide',
  TOGGLE_AIRSPACE: 'toggle-airspace',
  TOGGLE_CHANGELOG: 'js-changelogToggle',
  TOGGLE_LABELS: 'toggle-labels',
  TOGGLE_RESTRICTED_AREAS: 'toggle-restricted-areas',
  TOGGLE_PAUSE: 'toggle-pause',
  TOGGLE_SIDS: 'toggle-sids',
  TOGGLE_SPEECH: 'toggle-speech',
  TOGGLE_STARS: 'toggle-stars',
  TOGGLE_TERRAIN: 'toggle-terrain',
  TOGGLE_TRAFFIC: 'toggle-traffic',
  TOGGLE_TUTORIAL: 'toggle-tutorial',
  TOGGLE_VIDEO_MAP: 'toggle-video-map',
  WARN: 'warn',
  WARNING_BUTTON: 'warning-button'
};
/**
 * CSS IDs used throughout the app.
 *
 * @property SELECTOR_IDS
 * @type {Object}
 * @final
 */

exports.CLASSNAMES = CLASSNAMES;
var IDS = {
  AIRPORT_GUIDE: 'airportGuide-bd',
  AIRPORT_GUIDE_CONTAINER: 'airportGuide-container',
  AIRPORT_SWITCH: 'airport-switch',
  CANVASES: 'canvases',
  CLOCK: 'clock',
  COMMAND: 'command',
  LOADING: 'loading',
  LOG: 'log',
  NAVAIDS_CANVAS: 'navaids-canvas',
  PAUSED: 'paused',
  TOGGLE_OPTIONS: 'toggle-options',
  TUTORIAL: 'tutorial',
  GITHUB_EXTERNAL_LINK: 'js-github-external-link',
  SCORE: 'score',
  SIDEBAR: 'sidebar'
};
/**
 * Take a classname string and return a classname selector that can be used by jQuery to find an HTML Element.
 *
 * @function buildSelectorsFromClassnames
 * @return {object}
 */

exports.IDS = IDS;

var buildSelectorsFromClassnames = function buildSelectorsFromClassnames() {
  var classnameSelectors = (0, _mapValues2["default"])(CLASSNAMES, function (value) {
    return ".".concat(value);
  });
  return classnameSelectors;
};
/**
 *
 * @function buildSelectorsFromIds
 * @return {object}
 */


var buildSelectorsFromIds = function buildSelectorsFromIds() {
  var idSelectors = (0, _mapValues2["default"])(IDS, function (value) {
    return "#".concat(value);
  });
  return idSelectors;
};
/**
 * @property DOM_SELECTORS
 * @type {Object}
 * @final
 */


var DOM_SELECTORS = _objectSpread({}, buildSelectorsFromClassnames(), buildSelectorsFromIds());
/**
 * Combinator constant.
 *
 * Allows for a single import that has access to both CLASSNAMES, IDS and DOM_SELECTORS
 *
 * @property SELECTORS
 * @type {Object}
 * @final
 */


var SELECTORS = {
  CLASSNAMES: CLASSNAMES,
  IDS: IDS,
  DOM_SELECTORS: DOM_SELECTORS
};
exports.SELECTORS = SELECTORS;

},{"lodash/mapValues":232}],317:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FASTER_SPEED = exports.NORMAL_SPEED = exports.HIGHER_PITCH = exports.LOWER_PITCH = exports.VOICES = void 0;

/**
 * @property VOICES
 * @type {Array}
 * @final
 */
var VOICES = ['Alex', 'Daniel', 'Fiona', 'Google US English', 'Google UK English Female', 'Google UK English Male'];
/**
 * @property LOWER_PITCH
 * @type {float}
 * @final
 */

exports.VOICES = VOICES;
var LOWER_PITCH = 0.9;
/**
 * @property HIGHER_PITCH
 * @type {float}
 * @final
 */

exports.LOWER_PITCH = LOWER_PITCH;
var HIGHER_PITCH = 1.125;
/**
 * @property NORMAL_SPEED
 * @type {float}
 * @final
 */

exports.HIGHER_PITCH = HIGHER_PITCH;
var NORMAL_SPEED = 1.0;
/**
 * @property FASTER_SPEED
 * @type {float}
 * @final
 */

exports.NORMAL_SPEED = NORMAL_SPEED;
var FASTER_SPEED = 1.125;
exports.FASTER_SPEED = FASTER_SPEED;

},{}],318:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.STORAGE_KEY = void 0;

/**
 * @property STORAGE_KEY
 * @type {Object}
 * @final
 */
var STORAGE_KEY = {
  ATC_LAST_AIRPORT: 'atc-last-airport',
  ATC_LAST_VERSION: 'atc-last-version',
  ATC_SPEECH_ENABLED: 'atc-speech-enabled',
  FIRST_RUN_TIME: 'first-run-time',
  ZOOM_LEVEL: 'zoom-level'
};
exports.STORAGE_KEY = STORAGE_KEY;

},{}],319:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.THEME = void 0;

var _theme = require("./themes/classic/theme");

var _theme2 = require("./themes/default/theme");

var THEME = {
  CLASSIC: _theme.THEME_CLASSIC,
  DEFAULT: _theme2.THEME_DEFAULT
};
exports.THEME = THEME;

},{"./themes/classic/theme":326,"./themes/default/theme":333}],320:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COLOR = void 0;

/**
 * @property COLOR
 * @type {Object}
 * @final
 */
var COLOR = {
  BLACK_07: 'rgba(0, 0, 0, 0.7)',
  BLUE_02: 'rgba(128, 255, 255, 0.2)',
  BLUE_05: 'rgba(128, 255, 255, 0.5)',
  BLUE_06: 'rgba(128, 255, 255, 0.6)',
  BLUE_09: 'rgba(128, 255, 255, 0.9)',
  BLUE_LIGHT_SOFT_03: 'rgba(150, 200, 255, 0.3)',
  GRAY_LIGHT: 'rgba(224, 224, 224, 1.0)',
  GRAY: 'rgba(150, 150, 150, 1)',
  GREEN_02: 'rgba(76, 118, 97, 0.2)',
  GREEN_05: 'rgba(76, 118, 97, 0.5)',
  GREEN_09: 'rgba(76, 118, 97, 0.9)',
  GREEN_DARK: 'rgba(51, 85, 68, 1)',
  GREEN_LIGHT_PALE_002: 'rgba(200, 255, 200, 0.02)',
  GREEN_LIGHT_PALE_01: 'rgba(200, 255, 200, 0.1)',
  GREEN_LIGHT_PALE_025: 'rgba(200, 255, 200, 0.25)',
  GREEN_LIGHT: 'rgba(193, 218, 205, 1)',
  GREEN_MEDIUM: 'rgba(68, 102, 85, 1)',
  RED_02: 'rgba(224, 128, 128, 0.2)',
  RED_05: 'rgba(224, 128, 128, 0.5)',
  RED_06: 'rgba(224, 128, 128, 0.6)',
  RED_08: 'rgba(224, 128, 128, 0.8)',
  RED_09: 'rgba(224, 128, 128, 0.9)',
  RED_BRIGHT_07: 'rgba(255, 0, 0, 0.7)',
  RED: 'rgba(224, 128, 128, 1.0)',
  WHITE_02: 'rgba(255, 255, 255, 0.2)',
  WHITE_04: 'rgba(255, 255, 255, 0.4)',
  WHITE_05: 'rgba(255, 255, 255, 0.5)',
  WHITE_07: 'rgba(255, 255, 255, 0.7)',
  WHITE_08: 'rgba(255, 255, 255, 0.8)',
  WHITE_09: 'rgba(255, 255, 255, 0.9)',
  WHITE: 'rgba(255, 255, 255, 1.0)'
};
exports.COLOR = COLOR;

},{}],321:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DATA_BLOCK_THEME = void 0;

var _color = require("../color");

var DATA_BLOCK_THEME = {
  AIRCRAFT_MODEL_ICAO_CHARACTER_LIMIT: 4,
  ARRIVAL_BAR_IN_RANGE: _color.COLOR.RED_05,
  ARRIVAL_BAR_OUT_OF_RANGE: _color.COLOR.RED_02,
  ARRIVAL_BAR_SELECTED: _color.COLOR.RED_09,
  BACKGROUND_IN_RANGE: _color.COLOR.GREEN_05,
  BACKGROUND_OUT_OF_RANGE: _color.COLOR.GREEN_02,
  BACKGROUND_SELECTED: _color.COLOR.GREEN_09,
  DEPARTURE_BAR_IN_RANGE: _color.COLOR.BLUE_05,
  DEPARTURE_BAR_OUT_OF_RANGE: _color.COLOR.BLUE_02,
  DEPARTURE_BAR_SELECTED: _color.COLOR.BLUE_09,
  HALF_HEIGHT: 16,
  HALF_WIDTH: 35,
  HAS_FILL: true,
  HEIGHT: 32,
  LEADER_DIRECTION: 360,
  LEADER_LENGTH_ADJUSTMENT_PIXELS: -10,
  LEADER_LENGTH_INCREMENT_PIXELS: 25,
  LEADER_LENGTH: 1,
  LEADER_PADDING_FROM_BLOCK_PX: 0,
  LEADER_PADDING_FROM_TARGET_PX: 0,
  SCRATCHPAD_CHARACTER_LIMIT: 3,
  TEXT_FONT: '10px monoOne, monospace',
  TEXT_IN_RANGE: _color.COLOR.WHITE_05,
  TEXT_OUT_OF_RANGE: _color.COLOR.WHITE_02,
  TEXT_SELECTED: _color.COLOR.WHITE_09,
  WIDTH: 70
};
exports.DATA_BLOCK_THEME = DATA_BLOCK_THEME;

},{"../color":320}],322:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RADAR_TARGET_THEME = void 0;

var _color = require("../color");

var RADAR_TARGET_THEME = {
  HISTORY_DOT_INSIDE_RANGE: _color.COLOR.WHITE,
  HISTORY_DOT_OUTSIDE_RANGE: _color.COLOR.GRAY_LIGHT,
  HISTORY_DOT_RADIUS_KM: 0.2,
  HISTORY_LENGTH: 10,
  PROJECTED_TRACK_LINES: _color.COLOR.WHITE,
  PROJECTION_ARRIVAL: _color.COLOR.RED_06,
  PROJECTION_DEPARTURE: _color.COLOR.BLUE_06,
  PROJECTION_ESTABLISHED_ON_APPROACH: _color.COLOR.RED,
  RADAR_TARGET: _color.COLOR.GRAY_LIGHT,
  RADIUS_KM: 0.5,
  RADIUS_SELECTED_KM: 0.75,
  RING_CONFLICT: _color.COLOR.WHITE_02,
  RING_VIOLATION: _color.COLOR.RED,
  HALO: _color.COLOR.GREEN_LIGHT,
  TRAILING_SEPARATION_INDICATOR_ENABLED: true,
  TRAILING_SEPARATION_INDICATOR: _color.COLOR.RED_08
};
exports.RADAR_TARGET_THEME = RADAR_TARGET_THEME;

},{"../color":320}],323:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SCOPE_THEME = void 0;

var _color = require("../color");

var SCOPE_THEME = {
  AIRSPACE_FILL: _color.COLOR.GREEN_LIGHT_PALE_002,
  AIRSPACE_PERIMETER: _color.COLOR.GREEN_LIGHT_PALE_025,
  BACKGROUND: _color.COLOR.GREEN_DARK,
  COMPASS_HASH: _color.COLOR.GRAY_LIGHT,
  COMPASS_TEXT: _color.COLOR.WHITE,
  CROSSHAIR_STROKE: _color.COLOR.GRAY,
  FIX_FILL: _color.COLOR.WHITE_05,
  FIX_TEXT: _color.COLOR.WHITE_05,
  HALO_DEFAULT_RADIUS_NM: 3,
  HALO_MAX_RADIUS_NM: 20,

  /**
   * Color to use for the background on the `MeasureTool` labels
   *
   * @memberof SCOPE_THEME
   * @property MEASURE_BACKGROUND
   */
  MEASURE_BACKGROUND: _color.COLOR.GREEN_MEDIUM,

  /**
   * Color to use for the text on the `MeasureTool` line
   *
   * @memberof SCOPE_THEME
   * @property MEASURE_LINE
   */
  MEASURE_LINE: _color.COLOR.GREEN_LIGHT,

  /**
   * Color to use for the text on the `MeasureTool` labels
   *
   * @memberof SCOPE_THEME
   * @property MEASURE_TEXT
   */
  MEASURE_TEXT: _color.COLOR.WHITE,
  RANGE_RING_COLOR: _color.COLOR.GREEN_LIGHT_PALE_01,
  RESTRICTED_AIRSPACE: _color.COLOR.BLUE_LIGHT_SOFT_03,
  RUNWAY_EXTENDED_CENTERLINE: _color.COLOR.GREEN_MEDIUM,
  RUNWAY_LABELS: _color.COLOR.WHITE_08,
  RUNWAY: _color.COLOR.WHITE_04,
  SID: _color.COLOR.BLUE_06,
  STAR: _color.COLOR.RED,
  TOP_ROW_TEXT: _color.COLOR.WHITE_08,
  VIDEO_MAP: _color.COLOR.GREEN_LIGHT
};
exports.SCOPE_THEME = SCOPE_THEME;

},{"../color":320}],324:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TERRAIN_THEME = void 0;
var TERRAIN_THEME = {
  BORDER_OPACITY: 1,
  FILL_OPACITY: 0.1,
  COLOR: {
    0: '199, 100%, 30%',
    1000: '139, 70%, 35%',
    2000: '104, 46%, 56%',
    3000: '60, 25%, 100%',
    4000: '35, 97%, 75%',
    5000: '18, 85%, 62%',
    6000: '24, 67%, 37%'
  }
};
exports.TERRAIN_THEME = TERRAIN_THEME;

},{}],325:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WIND_VANE_THEME = void 0;

var _color = require("../color");

var WIND_VANE_THEME = {
  DIRECTION_LINE_GUSTY: _color.COLOR.RED_BRIGHT_07,
  DIRECTION_LINE: _color.COLOR.WHITE_07,
  INNER_RING_STROKE: _color.COLOR.WHITE_07,
  OUTER_RING_FILL: _color.COLOR.BLACK_07,
  WIND_SPEED_TEXT: _color.COLOR.WHITE_07
};
exports.WIND_VANE_THEME = WIND_VANE_THEME;

},{"../color":320}],326:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.THEME_CLASSIC = void 0;

var _dataBlock = require("./modules/dataBlock");

var _radarTarget = require("./modules/radarTarget");

var _scope = require("./modules/scope");

var _terrain = require("./modules/terrain");

var _windVane = require("./modules/windVane");

/**
 * @enum THEME_CLASSIC
 * @type {Object}
 * @final
 */
var THEME_CLASSIC = {
  CLASSNAME: 'canvas-theme-classic',
  DATA_BLOCK: _dataBlock.DATA_BLOCK_THEME,
  RADAR_TARGET: _radarTarget.RADAR_TARGET_THEME,
  SCOPE: _scope.SCOPE_THEME,
  TERRAIN: _terrain.TERRAIN_THEME,
  WIND_VANE: _windVane.WIND_VANE_THEME
};
exports.THEME_CLASSIC = THEME_CLASSIC;

},{"./modules/dataBlock":321,"./modules/radarTarget":322,"./modules/scope":323,"./modules/terrain":324,"./modules/windVane":325}],327:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COLOR = void 0;

/**
 * @property COLOR
 * @type {Object}
 * @final
 */
var COLOR = {
  BLUE_VERY_LIGHT: 'rgba(64, 127, 143, 1.0)',
  BLUE_LIGHT: 'rgba(56, 111, 125, 1.0)',
  BLUE_MEDIUM_LIGHT: 'rgba(48, 96, 108, 1.0)',
  BLUE_MEDIUM: 'rgba(40, 80, 90, 1.0)',
  BLUE_MEDIUM_DARK: 'rgba(32, 64, 72, 1.0)',
  BLUE_MEDIUM_DARK_01: 'rgba(32, 64, 72, 0.1)',
  BLUE_DARK: 'rgba(24, 49, 55, 1.0)',
  BLUE_VERY_DARK: 'rgba(16, 33, 37, 1.0)',
  GREEN_LIGHT: 'rgba(193, 218, 205, 1)',
  GRAY_VERY_VERY_DARK: 'rgba(20, 20, 20, 1.0)',
  RED: 'rgba(224, 128, 128, 1.0)',
  WHITE: 'rgba(255, 255, 255, 1.0)',
  WHITE_05: 'rgba(255, 255, 255, 0.5)'
};
exports.COLOR = COLOR;

},{}],328:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DATA_BLOCK_THEME = void 0;

var _color = require("../color");

// TODO: Instead of individual colors, can we somehow specify an alpha value
// for 'IN_RANGE', 'OUT_OF_RANGE' and 'SELECTED', to be applied to the entire
// data block? Possibly `cc.globalAlpha`, to be only effective while drawing
// the data block, then `cc.restore()` to return to normal opacity?

/**
 * Colors and options for data blocks
 *
 * @enum DATA_BLOCK_THEME
 * @type {object}
 */
var DATA_BLOCK_THEME = {
  /**
   * Number of characters of aircraft model icao to show in data block
   *
   * @memberof AIRCRAFT_MODEL_ICAO_CHARACTER_LIMIT
   * @type {number}
   */
  AIRCRAFT_MODEL_ICAO_CHARACTER_LIMIT: 4,

  /**
   * Color of the bar on the left side of the data block
   * Opacity used for when the aircraft is within the airspace
   *
   * @memberof DATA_BLOCK_THEME
   * @property ARRIVAL_BAR_IN_RANGE
   */
  ARRIVAL_BAR_IN_RANGE: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Color of the bar on the left side of the data block
   * Opacity used for when the aircraft is outside the airspace
   *
   * @memberof DATA_BLOCK_THEME
   * @property ARRIVAL_BAR_OUT_OF_RANGE
   */
  ARRIVAL_BAR_OUT_OF_RANGE: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Color of the bar on the left side of the data block
   * Opacity used for when the aircraft is selected
   *
   * @memberof DATA_BLOCK_THEME
   * @property ARRIVAL_BAR_SELECTED
   */
  ARRIVAL_BAR_SELECTED: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Color of the data block fill (if it is enabled)
   * Opacity used for when the aircraft is within the airspace
   *
   * @memberof DATA_BLOCK_THEME
   * @property BACKGROUND_IN_RANGE
   */
  BACKGROUND_IN_RANGE: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Color of the data block fill (if it is enabled)
   * Opacity used for when the aircraft is outside the airspace
   *
   * @memberof DATA_BLOCK_THEME
   * @property BACKGROUND_OUT_OF_RANGE
   */
  BACKGROUND_OUT_OF_RANGE: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Color of the data block fill (if it is enabled)
   * Opacity used for when the aircraft is selected
   *
   * @memberof DATA_BLOCK_THEME
   * @property BACKGROUND_SELECTED
   */
  BACKGROUND_SELECTED: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Color of the bar on the left side of the data block
   * Opacity used for when the aircraft is within the airspace
   *
   * @memberof DATA_BLOCK_THEME
   * @property DEPARTURE_BAR_IN_RANGE
   */
  DEPARTURE_BAR_IN_RANGE: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Color of the bar on the left side of the data block
   * Opacity used for when the aircraft is outside the airspace
   *
   * @memberof DATA_BLOCK_THEME
   * @property DEPARTURE_BAR_OUT_OF_RANGE
   */
  DEPARTURE_BAR_OUT_OF_RANGE: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Color of the bar on the left side of the data block
   * Opacity used for when the aircraft is selected
   *
   * @memberof DATA_BLOCK_THEME
   * @property DEPARTURE_BAR_SELECTED
   */
  DEPARTURE_BAR_SELECTED: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Whether or not to fill the data block with a background color
   * This z
   *
   * @memberof DATA_BLOCK_THEME
   * @property HAS_FILL
   */
  HAS_FILL: false,

  /**
   * One half of the height of a data block
   *
   * @memberof DATA_BLOCK_THEME
   * @property HALF_HEIGHT
   */
  HALF_HEIGHT: 16,

  /**
   * One half of the width of a data block
   *
   * @memberof DATA_BLOCK_THEME
   * @property HALF_HEIGHT
   */
  HALF_WIDTH: 30,

  /**
   * Height of a data block
   *
   * @memberof DATA_BLOCK_THEME
   * @property HEIGHT
   */
  HEIGHT: 32,

  /**
   * Direction to extend the data block away from the target
   * Currently, only 360, 45, 90, 135, 180, 225, 270, and 315 are available.
   *
   * @memberof DATA_BLOCK_THEME
   * @property LEADER_DIRECTION
   */
  LEADER_DIRECTION: 360,

  /**
   * Number of additional pixels away from the target to position the data block
   * Used to adjust spacing between data block and target at lowest leader length
   *
   * @memberof DATA_BLOCK_THEME
   * @property LEADER_LENGTH_ADJUSTMENT_PIXELS
   */
  LEADER_LENGTH_ADJUSTMENT_PIXELS: -10,

  /**
   * Number of pixels longer the leader line becomes with each increase of
   * the 'leader length' value
   *
   * @memberof DATA_BLOCK_THEME
   * @property LEADER_LENGTH_INCREMENT_PIXELS
   */
  LEADER_LENGTH_INCREMENT_PIXELS: 25,

  /**
   * Default length of the leader lines (no meaningful units)
   * The 'leader line' is the line that connects the target (position dot) to
   * the data block so you know which callsign applies to which aircraft
   *
   * @memberof DATA_BLOCK_THEME
   * @property LEADER_LENGTH
   */
  LEADER_LENGTH: 1,

  /**
   * Distance from data block after which the leader line is drawn
   * Higher values mean a shorter leader line
   *
   * @memberof DATA_BLOCK_THEME
   * @type {number}
   */
  LEADER_PADDING_FROM_BLOCK_PX: -2,

  /**
   * Distance from radar target after which the leader line is drawn
   * Higher values mean a shorter leader line
   *
   * @memberof DATA_BLOCK_THEME
   * @type {number}
   */
  LEADER_PADDING_FROM_TARGET_PX: 0,

  /**
   * Number of characters of scratchpad to show in data block
   *
   * @memberof DATA_BLOCK_THEME
   * @type {number}
   */
  SCRATCHPAD_CHARACTER_LIMIT: 3,

  /**
   * Font and size of text used in the data block
   *
   * @memberof DATA_BLOCK_THEME
   * @property TEXT_FONT
   */
  TEXT_FONT: '10px monoOne, monospace',

  /**
   * Color of text used in the data block
   * Opacity used for when the aircraft is within the airspace
   *
   * @memberof DATA_BLOCK_THEME
   * @property TEXT_IN_RANGE
   */
  TEXT_IN_RANGE: _color.COLOR.WHITE,

  /**
   * Color of text used in the data block
   * Opacity used for when the aircraft is outside the airspace
   *
   * @memberof DATA_BLOCK_THEME
   * @property TEXT_OUT_OF_RANGE
   */
  TEXT_OUT_OF_RANGE: _color.COLOR.WHITE,

  /**
   * Color of text used in the data block
   * Opacity used for when the aircraft is selected
   *
   * @memberof DATA_BLOCK_THEME
   * @property TEXT_SELECTED
   */
  TEXT_SELECTED: _color.COLOR.WHITE,

  /**
   * Width of the data block
   *
   * @memberof DATA_BLOCK_THEME
   * @property WIDTH
   */
  WIDTH: 60
};
exports.DATA_BLOCK_THEME = DATA_BLOCK_THEME;

},{"../color":327}],329:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RADAR_TARGET_THEME = void 0;

var _color = require("../color");

/**
 * Colors and options for radar targets
 *
 * @enum RADAR_TARGET_THEME
 * @type {object}
 */
var RADAR_TARGET_THEME = {
  /**
   * Color of the dots behind the aircraft, showing where it has been
   * Opacity used for when the aircraft is within the airspace
   *
   * @memberof RADAR_TARGET_THEME
   * @property HISTORY_DOT_INSIDE_RANGE
   */
  HISTORY_DOT_INSIDE_RANGE: _color.COLOR.WHITE_05,

  /**
   * Color of the dots behind the aircraft, showing where it has been
   * Opacity used for when the aircraft is outside the airspace
   *
   * @memberof RADAR_TARGET_THEME
   * @property HISTORY_DOT_OUTSIDE_RANGE
   */
  HISTORY_DOT_OUTSIDE_RANGE: _color.COLOR.WHITE_05,

  /**
   * Radius of the history dots, in kilometers
   *
   * @memberof RADAR_TARGET_THEME
   * @property HISTORY_DOT_RADIUS_KM
   */
  HISTORY_DOT_RADIUS_KM: 0.2,

  /**
   * Number of history dots to display behind the aircraft
   *
   * @memberof RADAR_TARGET_THEME
   * @property HISTORY_LENGTH
   */
  HISTORY_LENGTH: 7,

  /**
   * Color of projected track lines
   *
   * @memberof RADAR_TARGET_THEME
   * @property PROJECTED_TRACK_LINES
   */
  PROJECTED_TRACK_LINES: _color.COLOR.WHITE,

  /**
   * Color of projection lines showing an arrival aircraft will go
   *
   * @memberof RADAR_TARGET_THEME
   * @property PROJECTION_ARRIVAL
   */
  PROJECTION_ARRIVAL: _color.COLOR.RED,

  /**
   * Color of projection lines showing where a departure aircraft will go
   *
   * @memberof RADAR_TARGET_THEME
   * @property PROJECTION_DEPARTURE
   */
  PROJECTION_DEPARTURE: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Color of projection lines used when the aircraft is
   * established on an instrument approach
   *
   * @memberof RADAR_TARGET_THEME
   * @property PROJECTION_ESTABLISHED_ON_APPROACH
   */
  PROJECTION_ESTABLISHED_ON_APPROACH: _color.COLOR.RED,

  /**
   * Color of any radar target, including that of aircraft
   * A 'radar target' is the dot showing the actual position
   *
   * @memberof RADAR_TARGET_THEME
   * @property RADAR_TARGET
   */
  RADAR_TARGET: _color.COLOR.WHITE,

  /**
   * Radius to draw all radar targets
   *
   * @memberof RADAR_TARGET_THEME
   * @property RADIUS_KM
   */
  RADIUS_KM: 0.5,

  /**
   * Radius to draw radar targets of aircraft that are currently selected
   *
   * @memberof RADAR_TARGET_THEME
   * @property RADIUS_SELECTED_KM
   */
  RADIUS_SELECTED_KM: 0.75,

  /**
   * Color of conflict rings (shown to warn you of possible issue)
   *
   * @memberof RADAR_TARGET_THEME
   * @property RING_CONFLICT
   */
  RING_CONFLICT: _color.COLOR.BLUE_DARK,

  /**
   * Color of violation rings (shown when aircraft have lost separation)
   *
   * @memberof RADAR_TARGET_THEME
   * @property RING_VIOLATION
   */
  RING_VIOLATION: _color.COLOR.RED,

  /**
   * Color of halo
   *
   * @memberof RADAR_TARGET_THEME
   * @property HALO
   */
  HALO: _color.COLOR.GREEN_LIGHT,

  /**
   * Whether or not the small line behind aircraft established on an
   * instrument approach should be drawn
   *
   * @memberof RADAR_TARGET_THEME
   * @property TRAILING_SEPARATION_INDICATOR_ENABLED
   */
  TRAILING_SEPARATION_INDICATOR_ENABLED: false,

  /**
   * Color of small line behind aircraft established on an instrument approach
   *
   * @memberof RADAR_TARGET_THEME
   * @property TRAILING_SEPARATION_INDICATOR
   */
  TRAILING_SEPARATION_INDICATOR: _color.COLOR.BLUE_DARK
};
exports.RADAR_TARGET_THEME = RADAR_TARGET_THEME;

},{"../color":327}],330:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SCOPE_THEME = void 0;

var _color = require("../color");

/**
 * Colors and options for scope
 *
 * @enum SCOPE_THEME
 * @type {object}
 */
var SCOPE_THEME = {
  /**
   * Color to fill the airspace area
   *
   * @memberof SCOPE_THEME
   * @property AIRSPACE_FILL
   */
  AIRSPACE_FILL: _color.COLOR.BLUE_MEDIUM_DARK_01,

  /**
   * Color to draw the solid line along the airspace perimeter
   *
   * @memberof SCOPE_THEME
   * @property AIRSPACE_PERIMETER
   */
  AIRSPACE_PERIMETER: _color.COLOR.BLUE_DARK,

  /**
   * Color of the overall background of the scope
   *
   * @memberof SCOPE_THEME
   * @property BACKGROUND
   */
  BACKGROUND: _color.COLOR.BLUE_VERY_DARK,

  /**
   * Color of the minor and major hash marks of the relative compass headings
   * displayed when an aircraft is selected
   *
   * @memberof SCOPE_THEME
   * @property COMPASS_HASH
   */
  COMPASS_HASH: _color.COLOR.BLUE_MEDIUM_DARK,

  /**
   * Color of the heading text by the major hash marks of the relative compass
   * headings displayed when an aircraft is selected
   *
   * @memberof SCOPE_THEME
   * @property COMPASS_TEXT
   */
  COMPASS_TEXT: _color.COLOR.BLUE_MEDIUM_DARK,

  /**
   * Color of the crosshair symbol drawn by `CanvasController.canvas_draw_crosshairs()`
   * This is mostly a debug function used to help developers get some context on the
   * state of the canvas when examining and improving the current drawing system
   *
   * @memberof SCOPE_THEME
   * @property CROSSHAIR_STROKE
   */
  CROSSHAIR_STROKE: _color.COLOR.RED,

  /**
   * Color to fill the fix triangles with
   *
   * @memberof SCOPE_THEME
   * @property FIX_FILL
   */
  FIX_FILL: _color.COLOR.BLUE_MEDIUM,

  /**
   * Color to use for the labels on each of the fixes
   *
   * @memberof SCOPE_THEME
   * @property FIX_TEXT
   */
  FIX_TEXT: _color.COLOR.BLUE_MEDIUM,

  /**
   * Size to draw halos when size is not specified
   *
   * @memberof SCOPE_THEME
   * @property HALO_DEFAULT_RADIUS_NM
   */
  HALO_DEFAULT_RADIUS_NM: 3,

  /**
   * Maximum size to draw halos when size is not specified
   *
   * @memberof SCOPE_THEME
   * @property HALO_MAX_RADIUS_NM
   */
  HALO_MAX_RADIUS_NM: 20,

  /**
   * Color to use for the background on the `MeasureTool` labels
   *
   * @memberof SCOPE_THEME
   * @property MEASURE_BACKGROUND
   */
  MEASURE_BACKGROUND: _color.COLOR.BLUE_MEDIUM_DARK,

  /**
   * Color to use for the text on the `MeasureTool` line
   *
   * @memberof SCOPE_THEME
   * @property MEASURE_LINE
   */
  MEASURE_LINE: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Color to use for the labels on the `MeasureTool` labels
   *
   * @memberof SCOPE_THEME
   * @property MEASURE_TEXT
   */
  MEASURE_TEXT: _color.COLOR.WHITE,

  /**
   * Color of the range rings shown on the scope around the airport
   *
   * @memberof SCOPE_THEME
   * @property RANGE_RING_COLOR
   */
  RANGE_RING_COLOR: _color.COLOR.BLUE_DARK,

  /**
   * Color used to depict the restricted airspace areas
   *
   * @memberof SCOPE_THEME
   * @property RESTRICTED_AIRSPACE
   */
  RESTRICTED_AIRSPACE: _color.COLOR.BLUE_MEDIUM_LIGHT,

  /**
   * Color of the lines extending out from the runway thresholds
   *
   * @memberof SCOPE_THEME
   * @property RUNWAY_EXTENDED_CENTERLINE
   */
  RUNWAY_EXTENDED_CENTERLINE: _color.COLOR.BLUE_MEDIUM_DARK,

  /**
   * Color of the runway label text
   *
   * @memberof SCOPE_THEME
   * @property RUNWAY_LABELS
   */
  RUNWAY_LABELS: _color.COLOR.BLUE_LIGHT,

  /**
   * Color of the runways themselves
   *
   * @memberof SCOPE_THEME
   * @property RUNWAY
   */
  RUNWAY: _color.COLOR.WHITE,

  /**
   * Color of the lines drawn between fixes on SIDs
   *
   * @memberof SCOPE_THEME
   * @property SID
   */
  SID: _color.COLOR.BLUE_VERY_LIGHT,

  /**
   * Color of the lines drawn between fixes on STARs
   *
   * @memberof SCOPE_THEME
   * @property STAR
   */
  STAR: _color.COLOR.RED,

  /**
   * Color of the lines drawn between fixes on STARs
   *
   * @memberof SCOPE_THEME
   * @property TOP_ROW_TEXT
   */
  TOP_ROW_TEXT: _color.COLOR.WHITE,

  /**
   * Color of the video map lines (defined in the `maps`
   * section of the airport file)
   *
   * @memberof SCOPE_THEME
   * @property VIDEO_MAP
   */
  VIDEO_MAP: _color.COLOR.BLUE_MEDIUM
};
exports.SCOPE_THEME = SCOPE_THEME;

},{"../color":327}],331:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TERRAIN_THEME = void 0;

/**
 * Colors and options for terrain contours
 *
 * @enum TERRAIN_THEME
 * @type {object}
 */
var TERRAIN_THEME = {
  /**
   * Opacity of the lines on outer edges of terrain-elevated areas
   *
   * @memberof TERRAIN_THEME
   * @property BORDER_OPACITY
   */
  BORDER_OPACITY: 1,

  /**
   * Opacity of the fill color within terrain-elevated areas
   *
   * @memberof TERRAIN_THEME
   * @property FILL_OPACITY
   */
  FILL_OPACITY: 0.1,

  /**
   * Colors for each elevation level (in feet), in HSL
   * From these HSL values, we later generate HSLA for use in the canvas
   *
   * Note that values must use the following units:
   * (H) Hue:         degrees
   * (S) Saturation:  percentage
   * (L) Lightness:   percentage
   *
   * @memberof TERRAIN_THEME
   * @property COLOR
   */
  COLOR: {
    0: '199, 100%, 22%',
    1000: '190, 38%, 20%',
    2000: '190, 38%, 20%',
    3000: '190, 38%, 20%',
    4000: '190, 38%, 20%',
    5000: '190, 38%, 20%',
    6000: '72, 38%, 15%',
    7000: '72, 38%, 15%',
    8000: '72, 38%, 15%',
    9000: '72, 38%, 15%',
    10000: '72, 38%, 15%',
    11000: '312, 38%, 20%',
    12000: '312, 38%, 20%',
    13000: '312, 38%, 20%',
    14000: '312, 38%, 20%',
    15000: '312, 38%, 20%',
    16000: '132, 38%, 20%',
    17000: '132, 38%, 20%',
    18000: '132, 38%, 20%',
    19000: '132, 38%, 20%',
    20000: '132, 38%, 20%',
    21000: '12, 38%, 30%',
    22000: '12, 38%, 30%',
    23000: '12, 38%, 30%',
    24000: '12, 38%, 30%',
    25000: '12, 38%, 30%'
  }
};
exports.TERRAIN_THEME = TERRAIN_THEME;

},{}],332:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WIND_VANE_THEME = void 0;

var _color = require("../color");

/**
 * Colors and options for wind vane
 *
 * @enum WIND_VANE_THEME
 * @type {object}
 */
var WIND_VANE_THEME = {
  /**
   * Color of the line indicating the wind direction in gusty winds
   *
   * @memberof WIND_VANE_THEME
   * @property DIRECTION_LINE_GUSTY
   */
  DIRECTION_LINE_GUSTY: _color.COLOR.WHITE,

  /**
   * Color of the line indicating the wind direction
   *
   * @memberof WIND_VANE_THEME
   * @property DIRECTION_LINE
   */
  DIRECTION_LINE: _color.COLOR.WHITE,

  /**
   * Color of the ring around the wind speed
   *
   * @memberof WIND_VANE_THEME
   * @property INNER_RING_STROKE
   */
  INNER_RING_STROKE: _color.COLOR.WHITE,

  /**
   * Color to fill the whole wind vane
   *
   * @memberof WIND_VANE_THEME
   * @property OUTER_RING_FILL
   */
  OUTER_RING_FILL: _color.COLOR.GRAY_VERY_VERY_DARK,

  /**
   * Color of the wind speed text
   *
   * @memberof WIND_VANE_THEME
   * @property WIND_SPEED_TEXT
   */
  WIND_SPEED_TEXT: _color.COLOR.WHITE
};
exports.WIND_VANE_THEME = WIND_VANE_THEME;

},{"../color":327}],333:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.THEME_DEFAULT = void 0;

var _dataBlock = require("./modules/dataBlock");

var _radarTarget = require("./modules/radarTarget");

var _scope = require("./modules/scope");

var _terrain = require("./modules/terrain");

var _windVane = require("./modules/windVane");

/**
 * @enum THEME_DEFAULT
 * @type {Object}
 * @final
 */
var THEME_DEFAULT = {
  CLASSNAME: 'canvas-theme-default',
  DATA_BLOCK: _dataBlock.DATA_BLOCK_THEME,
  RADAR_TARGET: _radarTarget.RADAR_TARGET_THEME,
  SCOPE: _scope.SCOPE_THEME,
  TERRAIN: _terrain.TERRAIN_THEME,
  WIND_VANE: _windVane.WIND_VANE_THEME
};
exports.THEME_DEFAULT = THEME_DEFAULT;

},{"./modules/dataBlock":328,"./modules/radarTarget":329,"./modules/scope":330,"./modules/terrain":331,"./modules/windVane":332}],334:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRACKABLE_EVENT = void 0;

/**
 * Enum of categories used for ga event tracking
 *
 * @property TRACKABLE_EVENT
 */
var TRACKABLE_EVENT = {
  /**
   * airport-specific events like:
   *
   * - initial-load
   * - airport switcher open
   * - airport switcher close
   * - airport switcher change
   *
   * @memberof TRACKABLE_EVENT
   * @property AIRPORTS
   */
  AIRPORTS: 'airports',

  /**
   * spawn pattern changes like
   *
   * - flight-category
   * - spawn-pattern
   *
   * @memberof CHANGE_SPAWN_PATTERN
   * @property SETTINGS
   */
  CHANGE_SPAWN_PATTERN: 'change-spawn-pattern',

  /**
   * options events, encompasses all buttons
   * in option bar footer
   *
   * will report on/off (true/false) for each option
   *
   * timewarp should report current timewarp value
   *
   * @memberof TRACKABLE_EVENT
   * @property OPTIONS
   */
  OPTIONS: 'options',

  /**
   * toggle of settings dialog
   *
   * tracks change and next setting of a game option
   *
   * @memberof TRACKABLE_EVENT
   * @property SETTINGS
   */
  SETTINGS: 'settings',

  /**
   * reports on prev/next actions of tutorial
   *
   * @memberof TRACKABLE_EVENT
   * @property TUTORIAL
   */
  TUTORIAL: 'tutorial',

  /**
   * reports on clicks of links to an external resource
   *
   * @memberof
   * @property OUTBOUND
   */
  OUTBOUND: 'outbound',

  /**
   * reports when the ui log renders an error message
   *
   * @memberof TRACKABLE_EVENT
   * @property UI_LOG
   */
  UI_LOG: 'ui-log'
};
exports.TRACKABLE_EVENT = TRACKABLE_EVENT;

},{}],335:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VECTOR_WAYPOINT_PREFIX = exports.SPEED_RESTRICTION_PREFIX = exports.RNAV_WAYPOINT_DISPLAY_NAME = exports.RNAV_WAYPOINT_PREFIX = exports.RESTRICTION_SEPARATOR = exports.RESTRICTION_INDEX = exports.NAME_INDEX = exports.HOLD_WAYPOINT_PREFIX = exports.FLY_OVER_WAYPOINT_PREFIX = exports.DEFAULT_HOLD_PARAMETERS = exports.BELOW_SYMBOL = exports.ALTITUDE_RESTRICTION_PREFIX = exports.ABOVE_SYMBOL = void 0;

/**
 * Symbol denoting a greater than restriction
 *
 * @enum ABOVE_SYMBOL
 * @type {string}
 * @final
 */
var ABOVE_SYMBOL = '+';
/**
 * Character prefix indicating the subsequent value is an altitude restriction
 *
 * @enum ALTITUDE_RESTRICTION_PREFIX
 * @type {string}
 * @final
 */

exports.ABOVE_SYMBOL = ABOVE_SYMBOL;
var ALTITUDE_RESTRICTION_PREFIX = 'A';
/**
 * Symbol denoting a less than restriction
 *
 * @enum ABOVE_SYMBOL
 * @type {string}
 * @final
 */

exports.ALTITUDE_RESTRICTION_PREFIX = ALTITUDE_RESTRICTION_PREFIX;
var BELOW_SYMBOL = '-';
/**
 * Default options for holding patterns
 *
 * @enum DEFAULT_HOLD_PARAMETERS
 * @type {Object}
 * @final
 */

exports.BELOW_SYMBOL = BELOW_SYMBOL;
var DEFAULT_HOLD_PARAMETERS = {
  inboundHeading: undefined,
  legLength: '1min',
  speedMaximum: undefined,
  timer: -1,
  turnDirection: 'right'
};
/**
* Symbol that prepends a fixname indicating the aircraft should pass completely
* over the fix before turning toward the next fix on their route
*
* @enum FLY_OVER_WAYPOINT_PREFIX
* @type {string}
*/

exports.DEFAULT_HOLD_PARAMETERS = DEFAULT_HOLD_PARAMETERS;
var FLY_OVER_WAYPOINT_PREFIX = '^';
/**
* Symbol that prepends a fixname indicating the aircraft should enter
* a holding pattern once it arrives at the fix.
*
* @enum HOLD_WAYPOINT_PREFIX
* @type {string}
* @final
*/

exports.FLY_OVER_WAYPOINT_PREFIX = FLY_OVER_WAYPOINT_PREFIX;
var HOLD_WAYPOINT_PREFIX = '@';
/**
* Index where the name is located within `["WAMMY", "A20+|S220"]`
*
* @enum NAME_INDEX
* @type {number}
* @final
*/

exports.HOLD_WAYPOINT_PREFIX = HOLD_WAYPOINT_PREFIX;
var NAME_INDEX = 0;
/**
* Index where the restriction is located within `["WAMMY", "A20+|S220"]`
*
* @enum RESTRICTION_INDEX
* @type {number}
* @final
*/

exports.NAME_INDEX = NAME_INDEX;
var RESTRICTION_INDEX = 1;
/**
* Character used to separate altitude/speed restrictions from each other
*
* @enum RESTRICTION_SEPARATOR
* @type {string}
* @final
*/

exports.RESTRICTION_INDEX = RESTRICTION_INDEX;
var RESTRICTION_SEPARATOR = '|';
/**
* Symbol used to denote an RNAV waypoint
*
* @enum RNAV_WAYPOINT_PREFIX
* @type {string}
* @final
*/

exports.RESTRICTION_SEPARATOR = RESTRICTION_SEPARATOR;
var RNAV_WAYPOINT_PREFIX = '_';
/**
* @enum RNAV_WAYPOINT_DISPLAY_NAME
* @type {string}
* @final
*/

exports.RNAV_WAYPOINT_PREFIX = RNAV_WAYPOINT_PREFIX;
var RNAV_WAYPOINT_DISPLAY_NAME = '[RNAV]';
/**
* Character prefix indicating the subsequent value is a speed restriction
*
* @enum SPEED_RESTRICTION_PREFIX
* @type {string}
* @final
*/

exports.RNAV_WAYPOINT_DISPLAY_NAME = RNAV_WAYPOINT_DISPLAY_NAME;
var SPEED_RESTRICTION_PREFIX = 'S';
/**
* Symbols that prepends a three digit number, indicating that the created waypoint
* should simply be to follow the given heading until told to proceed to next waypoint
*
* @enum VECTOR_WAYPOINT_PREFIX
* @type {string}
* @final
*/

exports.SPEED_RESTRICTION_PREFIX = SPEED_RESTRICTION_PREFIX;
var VECTOR_WAYPOINT_PREFIX = '#';
exports.VECTOR_WAYPOINT_PREFIX = VECTOR_WAYPOINT_PREFIX;

},{}],336:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _LoadableContentModel = _interopRequireDefault(require("./LoadableContentModel"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Asynchronous JSON asset loading framework.
 *
 * Allows queueing assets to be loaded, assets may queued at a higher
 * priority by specifying the `immediate` option.  All assets with the
 * `immediate` option will be loaded before other assets.
 *
 * Events:
 *   startLoading - When an asset start being loaded, asset url as data
 *   stopLoading - When the last asset in the queue is downloaded
 *
 * Example:
 *  var promise = zlsa.atc.loadAsset({url: 'assets/aircraft/b747.json'});
 *
 * @module zlsa.atc.loadAsset
 */

/**
* Implementation of the queueing
*/
var ContentQueueClass =
/*#__PURE__*/
function () {
  function ContentQueueClass(loadingView) {
    _classCallCheck(this, ContentQueueClass);

    this.loadingView = loadingView;
    this.isLoading = false;
    this.lowPriorityQueue = [];
    this.highPriorityQueue = [];
    this.queuedContent = {};
  }
  /**
   * Adds or updates a piece of content
   *
   * Supports a url becoming an `immediate` load
   *
   * @for ContentQueue
   * @method add
   * @param options {object}
   * @return {Promise}
   */


  _createClass(ContentQueueClass, [{
    key: "add",
    value: function add(options) {
      var c = new _LoadableContentModel["default"](options);

      if (c.url in this.queuedContent) {
        c = this.queuedContent[c.url];

        if (c.immediate && !this.queuedContent[c.url].immediate) {
          var idx = _jquery["default"].inArray(c.url, this.lowPriorityQueue);

          if (idx > -1) {
            this.highPriorityQueue.push(this.lowPriorityQueue.splice(idx, 1));
          }
        }
      } else {
        this.queuedContent[c.url] = c;

        if (c.immediate) {
          this.highPriorityQueue.push(c.url);
        } else {
          this.lowPriorityQueue.push(c.url);
        }
      }

      if (!this.isLoading) {
        this.startLoad();
      }

      return c.deferred.promise();
    }
    /**
     * @for ContentQueue
     * @method startLoad
     * @return {boolean}
     */

  }, {
    key: "startLoad",
    value: function startLoad() {
      if (this.highPriorityQueue.length) {
        this.load(this.highPriorityQueue.shift());
        return true;
      } else if (this.lowPriorityQueue.length) {
        this.load(this.lowPriorityQueue.shift());
        return true;
      }

      return false;
    }
    /**
     * @for contentQueue
     * @method load
     * @param url {string}
     * @return {Promise}
     */

  }, {
    key: "load",
    value: function load(url) {
      var _this = this;

      var c = this.queuedContent[url];

      _jquery["default"].getJSON(c.url).done(function (data, textStatus, jqXHR) {
        c.deferred.resolve(data, textStatus, jqXHR);
      }).fail(function (jqXHR, textStatus, errorThrown) {
        c.deferred.reject(jqXHR, textStatus, errorThrown);
      }).always(function () {
        delete _this.queuedContent[c.url];
      });
    }
  }]);

  return ContentQueueClass;
}();

exports["default"] = ContentQueueClass;

},{"./LoadableContentModel":337,"jquery":1}],337:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _get2 = _interopRequireDefault(require("lodash/get"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Simple container for a given piece of content
 *
 * @class LoadableContentModel
 */
var LoadableContentModel = function LoadableContentModel(options) {
  _classCallCheck(this, LoadableContentModel);

  this.url = options.url;
  this.immediate = (0, _get2["default"])(options, 'immediate', false);
  this.type = 'json';
  this.deferred = _jquery["default"].Deferred();
};

exports["default"] = LoadableContentModel;

},{"jquery":1,"lodash/get":200}],338:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _core = require("../math/core");

var _globalConstants = require("../constants/globalConstants");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Value used as `#_frameDeltaTime` when performing future track
 * calculations for aircraft.
 *
 * @property SIMULATION_RATE_FOR_TRACK_PROJECTIONS
 * @type {number}
 * @final
 */
var SIMULATION_RATE_FOR_TRACK_PROJECTIONS = 5;
/**
 * Singleton used to manage game time and the advancement of animation frames
 *
 * You will notice a large number of the instance properties are private with exposed getters.
 * This is done to ensure that other classes are not able to modify the property values
 * of this class. TimeKeeping is an integral part of the app and must be able to keep accurate,
 * consistent time. Other classes can use these values but should never, directly, edit them.
 *
 * @class TimeKeeper
 */

var TimeKeeper =
/*#__PURE__*/
function () {
  /**
   * @constructor
   */
  function TimeKeeper() {
    _classCallCheck(this, TimeKeeper);

    /**
     * Sum of `deltaTime` values
     *
     * Used an an incrementor, thus we default to `0` instead of `-1`
     *
     * @property _accumulatedDeltaTime
     * @type {number}
     * @default 0
     * @private
     */
    this._accumulatedDeltaTime = 0;
    /**
     * Nubmer of frames rendered
     *
     * Used an an incrementor, thus we default to `0` instead of `-1`
     *
     * @property frames
     * @type {number}
     * @default 0
     * @private
     */

    this._elapsedFrameCount = 0;
    /**
     * Time difference in seconds between the `#lastFrame` and `#_frameStartTimestamp`
     *
     * **This is the most important value of this class.**
     *
     * From this value, we calculate how far everything has moved within the sim
     * as defined by (in the simplest terms):
     *
     * ```
     * d = distance
     * r = rate
     * t = time
     *
     * d = r * t
     * ```
     *
     * This property should only be used and accessed internally
     * All external methods should use public getter: `#deltaTime`
     *
     * This value is the single source of truth for true `deltaTime`, however,
     * we will only ever use this value locally. Every other external method needs
     * `deltaTime * simulationRate`, as provided by `#deltaTime`, to account for
     * any timewarp adjustments by the user
     *
     * @property _frameDeltaTime
     * @type {number}
     * @default -1
     * @private
     */

    this._frameDeltaTime = 0;
    /**
     * Timestamp for the current frame
     *
     * @property _frameStartTimestamp
     * @type {number}
     * @default -1
     * @private
     */

    this._frameStartTimestamp = 0; // TODO: not entirely sure what this is for

    /**
     *
     *
     * @property _frameStep
     * @type {number}
     * @default 0
     * @private
     */

    this._frameStep = 0;
    /**
     * This property is used to hold the value of `#_frameDeltaTime` when
     * performing future path calculations.
     *
     * This value should never be modified externally and only modified internally via the
     * `.saveDeltaTimeBeforeFutureTrackCalculation()' and `.restoreDeltaTimeAfterFutureTrackCalculation()`
     * methods.
     *
     * We modify `#_frameDeltaTime` like this so we can _fake_ a timewarp of 5 during future
     * track calculations.
     *
     * // TODO: this method of future track calculation should be looking into. it is non-performant
     * // and, frankly, quite messy.
     *
     * @property _futureTrackDeltaTimeCache
     * @type {number}
     * @default -1
     * @private
     */

    this._futureTrackDeltaTimeCache = -1;
    /**
     * Flag used to determine if the sim has been paused
     *
     * This defaults to `true` because the sim is effectively paused
     * on initial load. This way the game loop doesn't run needlessly
     * as the sim is loading.
     *
     * @property _isPaused
     * @type {boolean}
     * @default false
     * @private
     */

    this._isPaused = true;
    /**
     * Timestamp of the previous frame
     *
     * @property _previousFrameTimestamp
     * @type {number}
     */

    this._previousFrameTimestamp = 0;
    /**
     * Timestamp for the start of rendering
     *
     * @property _startTimestamp
     * @type {number}
     * @private
     */

    this._startTimestamp = 0;
    /**
     * Previously known as `timewarp`, this value is used a time multiplier
     *
     * This value is changed via methods exposed here used within the
     * `GameController` and is used to effectively _speed up_ this sim
     *
     * This value is used as a multiplier when returning the current `#_frameDeltaTime`
     * which causes moving objects appear to have moved a farther distance than they
     * would have at normal speed
     *
     * It is possible to set any numeric value via system command, though the
     * UI enforces values of: `1`, `2` and `5` via the timewarp toggle button
     *
     * @property _simulationRate
     * @type {number}
     * @default 1
     * @private
     */

    this._simulationRate = 1;
    return this._init();
  }
  /**
   * Accumulated time since the start of the simulation in seconds
   *
   * @property accumulatedDeltaTime
   * @type {number}
   */


  _createClass(TimeKeeper, [{
    key: "_init",

    /**
     * Lifecycle method
     *
     * @for TimeKeeper
     * @method _init
     * @chainable
     */
    value: function _init() {
      return this;
    }
    /**
     * Reset model properties
     *
     * @for TimeKeeper
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this._accumulatedDeltaTime = 0;
      this._elapsedFrameCount = 0;
      this._frameDeltaTime = 0;
      this._frameStartTimestamp = 0;
      this._frameStep = 0;
      this._futureTrackDeltaTimeCache = -1;
      this._isPaused = true;
      this._previousFrameTimestamp = 0;
      this._startTimestamp = 0;
      this._simulationRate = 1;
    }
    /**
     * Wrapper used to get current `#_frameDeltaTime` value or zero under certain conditions
     *
     * When the sim is 'paused' or un-focused, we do not want `#_frameDeltaTime` to be used
     * in position calculations. This causes movement at a time when there shouldn't be any.
     *
     * By supplying `0` in those cases, there is effectively no 'time' difference and thus no
     * change in position given a rate. This freezes objects at their current position until
     * such time we begin returning `#_frameDeltaTime` again.
     *
     * @for TimeKeeper
     * @method getDeltaTimeForGameStateAndTimewarp
     * @return {number} delta time in seconds
     */

  }, {
    key: "getDeltaTimeForGameStateAndTimewarp",
    value: function getDeltaTimeForGameStateAndTimewarp() {
      if (this.isPaused || this._isReturningFromPauseAndNotFutureTrack()) {
        return 0;
      }

      return this.deltaTime;
    }
    /**
     * Used to store the current `#_frameDeltaTime` and override the current delta
     * with a static value
     *
     * This method should be called immediately before performing calculations
     * for an aircraft's future path. Immediately after those calculations are
     * performed, `.restoreDeltaTimeAfterFutureTrackCalculation()` should be called
     * so position calculations can continue with the correct `#_frameDeltaTime`
     *
     * Modifying `#_frameDeltaTime` this way, though not ideal, is based on
     * the original implmenetation. This gives us a way to _fudge_ the
     * current deltTime and make it easy to draw out an aircraft's future path
     *
     * @for TimeKeeper
     * @method saveDeltaTimeBeforeFutureTrackCalculation
     */

  }, {
    key: "saveDeltaTimeBeforeFutureTrackCalculation",
    value: function saveDeltaTimeBeforeFutureTrackCalculation() {
      this._futureTrackDeltaTimeCache = this._frameDeltaTime;
      this._frameDeltaTime = SIMULATION_RATE_FOR_TRACK_PROJECTIONS;
    }
    /**
     * Used to reset `#_futureTrackDeltaTimeCache` after future track
     * calculations have finished
     *
     * This method should be called immediately after performing calculations
     * for an aircraft's future path.
     *
     * @for TimeKeeper
     * @method restoreDeltaTimeAfterFutureTrackCalculation
     */

  }, {
    key: "restoreDeltaTimeAfterFutureTrackCalculation",
    value: function restoreDeltaTimeAfterFutureTrackCalculation() {
      this._frameDeltaTime = this._futureTrackDeltaTimeCache;
      this._futureTrackDeltaTimeCache = -1;
    }
    /**
     * Updates the value of `#_isPaused`
     *
     * Calls to this method will happen externally as a result of a user
     * interaction with the controls bar
     *
     * This value is used in reference to `#_frameDeltaTime`. So `#_isPaused`
     * will be true if the app is _either_ paused or blurred. When this
     * value is true, `#_frameDeltaTime` value will be `0` so the position
     * of moving objects will not changes while `#_isPaused` is `true`
     *
     * @for TimeKeeper
     * @method setPause
     * @param nextPaus {boolean}
     */

  }, {
    key: "setPause",
    value: function setPause(nextPause) {
      if (nextPause === this._isPaused) {
        return;
      }

      this._isPaused = nextPause;
    }
    /**
     * Helper method used by the `CanvasController` to determine whether or not we
     * should re-calculate and re-draw
     *
     * This returns `true` once every `#_frameStep` based on total `#_elapsedFrameCount`
     *
     * @for TimeKeeper
     * @method shouldUpdate
     * @return {boolean}
     */

  }, {
    key: "shouldUpdate",
    value: function shouldUpdate() {
      return this._elapsedFrameCount % this._frameStep === 0;
    }
    /**
     * Update time and `#_frameDeltaTime` values
     *
     * Should be called at the end of each update cycle by the `AppController`
     * Calling this method signifies the end of a frame and the beginning of
     * a new frame
     *
     * @for TimeKeeper
     * @method update
     */

  }, {
    key: "update",
    value: function update() {
      if (this._futureTrackDeltaTimeCache !== -1) {
        return;
      }

      var currentTime = this.gameTimeSeconds;

      this._incrementFrame();

      this._calculateNextDeltaTime(currentTime);

      this._calculateFrameStep();
    }
    /**
     * Update the value of `#_simulationRate`
     *
     * Calls to this method will happen externally as a result of a user interaction
     * with the controls bar or by issuing a system command.
     *
     * @for TimeKeeper
     * @method updateSimulationRate
     * @param nextTimewarp {number}  the next value for `#_simulationRate`
     */

  }, {
    key: "updateSimulationRate",
    value: function updateSimulationRate(nextTimewarp) {
      if (nextTimewarp < 0) {
        return;
      }

      this._simulationRate = nextTimewarp;
    }
    /**
     * Increments the `#_elapsedFrameCount` value by `1`
     *
     * Called every frame via `.update()`
     *
     * Calls to this method signal the start of a new frame
     *
     * @for TimeKeeper
     * @method incrementFrame
     * @private
     */

  }, {
    key: "_incrementFrame",
    value: function _incrementFrame() {
      this._elapsedFrameCount += 1;
    }
    /**
     * Caclulate the difference (delta) between the `#currentTime`
     * and `#_previousFrameTimestamp`
     *
     * Called every frame via `.update()`
     *
     * @for TimeKeeper
     * @method _calculateNextDelatTime
     * @param currentTime {number} current time in seconds
     * @private
     */

  }, {
    key: "_calculateNextDeltaTime",
    value: function _calculateNextDeltaTime(currentTime) {
      var frameDelay = 1;
      var elapsed = currentTime - this._frameStartTimestamp;

      if (elapsed > frameDelay) {
        this._frameStartTimestamp = currentTime;
      }

      this._frameDeltaTime = currentTime - this._previousFrameTimestamp;
      this._previousFrameTimestamp = currentTime;
      this._accumulatedDeltaTime += this.getDeltaTimeForGameStateAndTimewarp();
    }
    /**
     * Updates the `#_frameStep` value based on the current `#_simulationRate`
     *
     * Called every frame via `.update()`
     *
     * @for CanvasController
     * @method _calculateFrameStep
     * @private
     */

  }, {
    key: "_calculateFrameStep",
    value: function _calculateFrameStep() {
      // TODO: what do the magic numbers mean?
      this._frameStep = Math.round((0, _core.extrapolate_range_clamp)(1, this._simulationRate, 10, 30, 1));
    }
    /**
     * Boolean abstraction used to determine if this frame is being calculated after returning
     * from pause, which is assumed when `#_frameDeltaTime` is greater than `1` and
     * `#_simulationRate` is `1`. And this is not part of a future track calculation, when
     * `#_futureTrackDeltaTimeCache` is `-1`.
     *
     * @for TimeKeeper
     * @method _isReturningFromPauseAndNotFutureTrack
     * @return {boolean}
     */

  }, {
    key: "_isReturningFromPauseAndNotFutureTrack",
    value: function _isReturningFromPauseAndNotFutureTrack() {
      return this.deltaTime >= 1 && this._simulationRate === 1 && this._futureTrackDeltaTimeCache === -1;
    }
  }, {
    key: "accumulatedDeltaTime",
    get: function get() {
      return this._accumulatedDeltaTime;
    }
    /**
     * Current timestamp in milliseconds
     *
     * This is the same value as `gameTime`.
     * We define this getter here simply for the added context
     * given in the name
     *
     * @property gameTimeMilliseconds
     * @return {number}
     */

  }, {
    key: "gameTimeMilliseconds",
    get: function get() {
      return new Date().getTime();
    }
    /**
     * Current timestamp in seconds
     *
     * @property gameTimeSeconds
     * @return {number}
     */

  }, {
    key: "gameTimeSeconds",
    get: function get() {
      return new Date().getTime() * _globalConstants.TIME.ONE_MILLISECOND_IN_SECONDS;
    }
    /**
     * Current `#_frameDeltaTime` multiplied by the current `#_simulationRate`
     *
     * This is value any external method needs when calculating movement with
     * deltaTime. No external method should every access `#_frameDeltaTime`
     * because that value will not account for `#_simulationRate`.
     *
     * For more information on the concept of `deltaTime` see:
     * https://en.wikipedia.org/wiki/Delta_timing
     *
     * @property deltaTime
     * @return {number} current delta time in seconds
     */

  }, {
    key: "deltaTime",
    get: function get() {
      var deltaTimeOffsetBySimulationRate = this._frameDeltaTime * this._simulationRate;
      return Math.min(deltaTimeOffsetBySimulationRate, 100);
    }
    /**
     * @property isPaused
     * @type {boolean}
     */

  }, {
    key: "isPaused",
    get: function get() {
      return this._isPaused;
    }
    /**
     * The fast-forward value used to speed up animated distances
     *
     * Previously known as `timewarp`
     *
     * @property simulationRate
     * @type {number}
     */

  }, {
    key: "simulationRate",
    get: function get() {
      return this._simulationRate;
    }
  }]);

  return TimeKeeper;
}();

var _default = new TimeKeeper();

exports["default"] = _default;

},{"../constants/globalConstants":310,"../math/core":349}],339:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.GAME_EVENTS = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _EventTracker = _interopRequireDefault(require("../EventTracker"));

var _GameOptions = _interopRequireDefault(require("./GameOptions"));

var _TimeKeeper = _interopRequireDefault(require("../engine/TimeKeeper"));

var _core = require("../math/core");

var _eventNames = require("../constants/eventNames");

var _gameOptionConstants = require("../constants/gameOptionConstants");

var _globalConstants = require("../constants/globalConstants");

var _trackableEvents = require("../constants/trackableEvents");

var _selectors = require("../constants/selectors");

var _themes = require("../constants/themes");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// TODO: Remember to move me to wherever the constants end up being moved to

/**
 * Definitions of point values for given game events
 * @type {Object}
 */
var GAME_EVENTS_POINT_VALUES = {
  AIRSPACE_BUST: -200,
  ARRIVAL: 10,
  COLLISION: -1000,
  DEPARTURE: 10,
  EXTREME_CROSSWIND_OPERATION: -15,
  EXTREME_TAILWIND_OPERATION: -75,
  GO_AROUND: -50,
  HIGH_CROSSWIND_OPERATION: -5,
  HIGH_TAILWIND_OPERATION: -25,
  ILLEGAL_APPROACH_CLEARANCE: -10,
  LOCALIZER_INTERCEPT_ABOVE_GLIDESLOPE: -10,
  NOT_CLEARED_ON_ROUTE: -25,
  SEPARATION_LOSS: -200,
  NO_TAKEOFF_SEPARATION: -200
};
/**
 * List of game events
 * @type {Object}
 */

var GAME_EVENTS = {
  AIRSPACE_BUST: 'AIRSPACE_BUST',
  ARRIVAL: 'ARRIVAL',
  COLLISION: 'COLLISION',
  DEPARTURE: 'DEPARTURE',
  EXTREME_CROSSWIND_OPERATION: 'EXTREME_CROSSWIND_OPERATION',
  EXTREME_TAILWIND_OPERATION: 'EXTREME_TAILWIND_OPERATION',
  GO_AROUND: 'GO_AROUND',
  HIGH_CROSSWIND_OPERATION: 'HIGH_CROSSWIND_OPERATION',
  HIGH_TAILWIND_OPERATION: 'HIGH_TAILWIND_OPERATION',
  ILLEGAL_APPROACH_CLEARANCE: 'ILLEGAL_APPROACH_CLEARANCE',

  /**
  * Aircraft is cleared for the approach, has just become fully established on the localizer,
  * but they are above the glideslope, and will have to chase it down
  *
  * This event is used to assess a penalty to the controller because they are required to have
  * aircraft at/below glideslope altitude when intercepting the localizer
  *
  * @memberof GAME_EVENTS
  * @property LOCALIZER_INTERCEPT_ABOVE_GLIDESLOPE
  * @type {string}
  */
  LOCALIZER_INTERCEPT_ABOVE_GLIDESLOPE: 'LOCALIZER_INTERCEPT_ABOVE_GLIDESLOPE',
  NOT_CLEARED_ON_ROUTE: 'NOT_CLEARED_ON_ROUTE',
  SEPARATION_LOSS: 'SEPARATION_LOSS',
  NO_TAKEOFF_SEPARATION: 'NO_TAKEOFF_SEPARATION'
};
/**
 * @class GameController
 */

exports.GAME_EVENTS = GAME_EVENTS;

var GameController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   */
  function GameController() {
    var _this = this;

    _classCallCheck(this, GameController);

    _defineProperty(this, "_setTheme", function (themeName) {
      if (!(0, _has2["default"])(_themes.THEME, themeName)) {
        console.error("Expected valid theme to change to, but received '".concat(themeName, "'"));
        return;
      }

      _this.theme = _themes.THEME[themeName];
    });

    // TODO: the below $elements _should_ be used instead of the inline vars currently in use but
    // take caution when implmenting these because it will break tests currently in place. This is
    // because of the use of $ within lifecycle methods and becuase this is a static class used
    // by many of the files under test.
    // this._$htmlElement = $('html');
    // this._$pauseToggleElement = null;
    // this._$fastForwardElement = null;
    // this._$scoreElement = null;
    this.game = {};
    this.game.focused = true;
    this.game.frequency = 1;
    this.game.events = {};
    this.game.timeouts = [];
    this.game.last_score = 0;
    this.game.score = 0;
    this.game.option = new _GameOptions["default"]();
    this.theme = _themes.THEME.DEFAULT;
    this._eventBus = _EventBus["default"];
  }
  /**
   * @for GameController
   * @method init_pre
   */


  _createClass(GameController, [{
    key: "init_pre",
    value: function init_pre() {
      return this.setupHandlers().createChildren().enable();
    }
    /**
    * Initialize blur functions used during game pausing
    *
    * @for GameController
    * @method setupHandlers
    * @chainable
    */

  }, {
    key: "setupHandlers",
    value: function setupHandlers() {
      this._onWindowBlurHandler = this._onWindowBlur.bind(this);
      this._onWindowFocusHandler = this._onWindowFocus.bind(this);
      return this;
    }
    /**
     * @for GameController
     * @method createChildren
     * @chainable
     */

  }, {
    key: "createChildren",
    value: function createChildren() {
      // see comment in constructor. tl;dr these props should be used but are not because they break tests
      // this._$pauseToggleElement = $(SELECTORS.DOM_SELECTORS.TOGGLE_PAUSE);
      // this._$fastForwardElement = $(SELECTORS.DOM_SELECTORS.FAST_FORWARDS);
      // this._$scoreElement = $(SELECTORS.DOM_SELECTORS.SCORE);
      return this;
    }
    /**
     * @for GameController
     * @method enable
     * @chainable
     */

  }, {
    key: "enable",
    value: function enable() {
      var _this2 = this;

      this._eventBus.on(_eventNames.EVENT.SET_THEME, this._setTheme);

      window.addEventListener('blur', this._onWindowBlurHandler);
      window.addEventListener('focus', this._onWindowFocusHandler); // for when the browser window receives or looses focus

      document.addEventListener('visibilitychange', function () {
        if (document.visibilityState === 'hidden') {
          return _this2._onWindowBlurHandler();
        }

        return _this2._onWindowFocusHandler();
      });
      return this.initializeEventCount();
    }
    /**
     * @for GameController
     * @method disable
     * @chainable
     */

  }, {
    key: "disable",
    value: function disable() {
      this._eventBus.off(_eventNames.EVENT.SET_THEME, this._setTheme);

      return this.destroy();
    }
    /**
     * Destroy instance properties
     *
     * @for GameController
     * @method destroy
     * @chainable
     */

  }, {
    key: "destroy",
    value: function destroy() {
      // this._$htmlElement = $('html');
      // this._$pauseToggleElement = null;
      // this._$fastForwardElement = null;
      // this._$scoreElement = null;
      this.game = {};
      this.game.focused = true; // TODO: remove

      this.game.frequency = 1;
      this.game.events = {};
      this.game.timeouts = [];
      this.game.last_score = 0;
      this.game.score = 0;
      this.game.option = new _GameOptions["default"]();
      this.theme = _themes.THEME.DEFAULT;
      return this;
    }
    /**
     * Initialize `GameController.events` to contain appropriate properties with values of 0
     *
     * @for GameController
     * @method initializeEventCount
     */

  }, {
    key: "initializeEventCount",
    value: function initializeEventCount() {
      var _this3 = this;

      (0, _forEach2["default"])(GAME_EVENTS, function (gameEvent, key) {
        _this3.game.events[key] = 0;
      });
    } // TODO: usages of this method should move to use EventBus

    /**
     * Record a game event to this.game.events, and update this.game.score
     *
     * @for GameController
     * @method events_recordNew
     * @param gameEvent {String} one of the events listed in GAME_EVENTS
     */

  }, {
    key: "events_recordNew",
    value: function events_recordNew(gameEvent) {
      if (!(0, _has2["default"])(GAME_EVENTS, gameEvent)) {
        throw new TypeError("Expected a game event listed in GAME_EVENTS, but instead received ".concat(gameEvent));
      }

      this.game.events[gameEvent] += 1;
      this.game.score += GAME_EVENTS_POINT_VALUES[gameEvent];
      this.game_updateScore();
    }
    /**
     * @for GameController
     * @method game_get_weighted_score
     */

  }, {
    key: "game_get_weighted_score",
    value: function game_get_weighted_score() {
      var hoursPlayed = _TimeKeeper["default"].accumulatedDeltaTime / _globalConstants.TIME.ONE_HOUR_IN_SECONDS;
      var scorePerHour = this.game.score / hoursPlayed;
      return scorePerHour;
    }
    /**
     * @for GameController
     * @method game_reset_score_and_events
     */

  }, {
    key: "game_reset_score_and_events",
    value: function game_reset_score_and_events() {
      var _this4 = this;

      // Reset events
      (0, _forEach2["default"])(this.game.events, function (gameEvent, key) {
        _this4.game.events[key] = 0;
      }); // Reset score

      this.game.score = 0;
      this.game_updateScore();
    }
    /**
     *
     * @for GameController
     * @method updateTimescale
     * @param nextValue {number}
     */

  }, {
    key: "updateTimescale",
    value: function updateTimescale(nextValue) {
      if (nextValue === 0) {
        this.game_timewarp_toggle();
        return;
      }

      _TimeKeeper["default"].updateSimulationRate(nextValue);
    }
    /**
     * Update the visual state of the timewarp control button and call
     * `TimeKeeper.updateTimescalse` with the next timewarp value.
     *
     * This method is called as a result of a user interaction
     *
     * @for GameController
     * @method game_timewarp_toggle
     */

  }, {
    key: "game_timewarp_toggle",
    value: function game_timewarp_toggle() {
      var $fastForwards = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.FAST_FORWARDS);

      if (_TimeKeeper["default"].simulationRate >= 5) {
        _TimeKeeper["default"].updateSimulationRate(1);

        _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'timewarp', '1');

        $fastForwards.removeClass(_selectors.SELECTORS.CLASSNAMES.SPEED_5);
        $fastForwards.prop('title', 'Set time warp to 2');
      } else if (_TimeKeeper["default"].simulationRate === 1) {
        _TimeKeeper["default"].updateSimulationRate(2);

        _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'timewarp', '2');

        $fastForwards.addClass(_selectors.SELECTORS.CLASSNAMES.SPEED_2);
        $fastForwards.prop('title', 'Set time warp to 5');
      } else {
        _TimeKeeper["default"].updateSimulationRate(5);

        _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'timewarp', '5');

        $fastForwards.removeClass(_selectors.SELECTORS.CLASSNAMES.SPEED_2);
        $fastForwards.addClass(_selectors.SELECTORS.CLASSNAMES.SPEED_5);
        $fastForwards.prop('title', 'Reset time warp');
      }
    }
    /**
     * @for GameController
     * @method game_pause
     */

  }, {
    key: "game_pause",
    value: function game_pause() {
      _TimeKeeper["default"].setPause(true);

      var $pauseToggleElement = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_PAUSE);
      $pauseToggleElement.addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
      $pauseToggleElement.attr('title', 'Resume simulation');
      (0, _jquery["default"])('html').addClass(_selectors.SELECTORS.CLASSNAMES.PAUSED);
    }
    /**
     * @for GameController
     * @method game_unpause
     */

  }, {
    key: "game_unpause",
    value: function game_unpause() {
      _TimeKeeper["default"].setPause(false);

      var $pauseToggleElement = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_PAUSE);
      $pauseToggleElement.removeClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
      $pauseToggleElement.attr('title', 'Pause simulation');
      (0, _jquery["default"])('html').removeClass(_selectors.SELECTORS.CLASSNAMES.PAUSED);
    }
    /**
     * @for GameController
     * @method game_pause_toggle
     */

  }, {
    key: "game_pause_toggle",
    value: function game_pause_toggle() {
      if (_TimeKeeper["default"].isPaused) {
        _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'pause', 'false');

        this.game_unpause();
        return;
      }

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'pause', 'true');

      this.game_pause();
    }
    /**
     * @for GameController
     * @method game_paused
     * @return {boolean}
     */

  }, {
    key: "game_paused",
    value: function game_paused() {
      return !this.game.focused || _TimeKeeper["default"].isPaused;
    }
    /**
     * @for GameController
     * @method game_speedup
     * @return {number}
     */

  }, {
    key: "game_speedup",
    value: function game_speedup() {
      return !this.game_paused() ? _TimeKeeper["default"].simulationRate : 0;
    }
    /**
     * @for GameController
     * @method game_timeout
     * @param func {function} called when timeout is triggered
     * @param delay {number} in seconds
     * @param that
     * @param data
     * @return {array} gameTimeout
     */

  }, {
    key: "game_timeout",
    value: function game_timeout(functionToCall, delay, that, data) {
      var timerDelay = _TimeKeeper["default"].accumulatedDeltaTime + delay;
      var gameTimeout = [functionToCall, timerDelay, data, delay, false, that];
      this.game.timeouts.push(gameTimeout);
      return gameTimeout;
    }
    /**
     * @for GameController
     * @method game_interval
     * @param func {function} called when timeout is triggered
     * @param delay {number} in seconds
     * @param that
     * @param data
     * @return {array} to
     */

  }, {
    key: "game_interval",
    value: function game_interval(func, delay, that, data) {
      var to = [func, _TimeKeeper["default"].accumulatedDeltaTime + delay, data, delay, true, that];
      this.game.timeouts.push(to);
      return to;
    }
    /**
     * Destroys a specific timer.
     *
     * @for GameController
     * @method destroyTimer
     * @param timer {array} the timer to destroy
     */

  }, {
    key: "destroyTimer",
    value: function destroyTimer(timer) {
      this.game.timeouts.splice(this.game.timeouts.indexOf(timer), 1);
    }
    /**
     * Destroy all current timers
     *
     * Used when changing airports. any timer is only valid
     * for a specific airport.
     *
     * @for GameController
     * @method destroyTimers
     */

  }, {
    key: "destroyTimers",
    value: function destroyTimers() {
      this.game.timeouts = [];
    }
    /**
     * @for GameController
     * @method game_updateScore
     * @param score {number}
     */

  }, {
    key: "game_updateScore",
    value: function game_updateScore() {
      if (this.game.score === this.game.last_score) {
        return;
      }

      var $scoreElement = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.SCORE);
      $scoreElement.text((0, _core.round)(this.game.score)); // TODO: wait, what? Why not just < 0?

      if (this.game.score < -0.51) {
        $scoreElement.addClass(_selectors.SELECTORS.CLASSNAMES.NEGATIVE);
      } else {
        $scoreElement.removeClass(_selectors.SELECTORS.CLASSNAMES.NEGATIVE);
      }

      this.game.last_score = this.game.score;
    }
    /**
     * @for GameController
     * @method update_pre
     */

  }, {
    key: "update_pre",
    value: function update_pre() {
      var $htmlElement = (0, _jquery["default"])('html');

      if (!this.game_paused() && $htmlElement.hasClass(_selectors.SELECTORS.CLASSNAMES.PAUSED)) {
        $htmlElement.removeClass(_selectors.SELECTORS.CLASSNAMES.PAUSED);
      }

      this.updateTimers();
    }
    /**
     * @for GameController
     * @method updateTimers
     */

  }, {
    key: "updateTimers",
    value: function updateTimers() {
      var currentGameTime = _TimeKeeper["default"].accumulatedDeltaTime;

      for (var i = this.game.timeouts.length - 1; i >= 0; i--) {
        var willRemoveTimerFromList = false;
        var timeout = this.game.timeouts[i];
        var callback = timeout[0];
        var delayFireTime = timeout[1];
        var callbackArguments = timeout[2];
        var delayInterval = timeout[3];
        var shouldRepeat = timeout[4];

        if (currentGameTime > delayFireTime) {
          callback.call(timeout[5], callbackArguments);
          willRemoveTimerFromList = true;

          if (shouldRepeat) {
            timeout[1] = delayFireTime + delayInterval;
            willRemoveTimerFromList = false;
          }
        }

        if (willRemoveTimerFromList) {
          this.game.timeouts.splice(i, 1);
          i -= 1;
        }
      }
    }
    /**
     * @for GameController
     * @method complete
     */

  }, {
    key: "complete",
    value: function complete() {
      _TimeKeeper["default"].setPause(false);
    }
    /**
     * Facade for `game.option.get`
     *
     * Allows for classes that import the `GameController` single-level
     * access to any game option value
     *
     * @for GameController
     * @method getGameOption
     * @param optionName {string}
     * @return {string}
     */

  }, {
    key: "getGameOption",
    value: function getGameOption(optionName) {
      return this.game.option.getOptionByName(optionName);
    }
    /**
     * Check whether or not the trailing distance separator should be drawn.
     *
     * Used by the `CanvasController` to determine whether or not to proceed with
     * `canvas_draw_separation_indicator`.
     *
     * @for GameController
     * @method shouldUseTrailingSeparationIndicator
     * @param aircraft {AircraftModel}
     * @return {boolean}
     */

  }, {
    key: "shouldUseTrailingSeparationIndicator",
    value: function shouldUseTrailingSeparationIndicator(aircraft) {
      var userSettingsValue = this.getGameOption(_gameOptionConstants.GAME_OPTION_NAMES.DRAW_ILS_DISTANCE_SEPARATOR);
      var isIndicatorEnabled = userSettingsValue === 'yes';

      if (userSettingsValue === 'from-theme') {
        isIndicatorEnabled = this.theme.RADAR_TARGET.TRAILING_SEPARATION_INDICATOR_ENABLED;
      }

      return isIndicatorEnabled && aircraft.isArrival();
    }
    /**
     * @for GameController
     * @method _onWindowBlur
     * @param event {UIEvent}
     * @private
     */

  }, {
    key: "_onWindowBlur",
    value: function _onWindowBlur(event) {
      this.game.focused = false; // resetting back to 1 here so when focus returns, we can reliably reset
      // `#game.delta` to 0 to prevent jumpiness

      _TimeKeeper["default"].updateSimulationRate(1);

      _TimeKeeper["default"].setPause(true); // update visual state of the timewarp control button for consistency


      var $fastForwards = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.FAST_FORWARDS);
      $fastForwards.removeClass(_selectors.SELECTORS.CLASSNAMES.SPEED_2);
      $fastForwards.removeClass(_selectors.SELECTORS.CLASSNAMES.SPEED_5);
      $fastForwards.prop('title', 'Set time warp to 2');
    }
    /**
     * @for GameController
     * @method _onWindowFocus
     * @param event {UIEvent}
     * @private
     */

  }, {
    key: "_onWindowFocus",
    value: function _onWindowFocus(event) {
      this.game.focused = true; // if was already manually paused when lost focus, respect that

      if ((0, _jquery["default"])('html').hasClass(_selectors.SELECTORS.CLASSNAMES.PAUSED)) {
        return;
      }

      _TimeKeeper["default"].setPause(false);
    }
    /**
     * Change theme to the specified name
     *
     * This should ONLY be called through the EventBus during a `SET_THEME` event,
     * thus ensuring that the same theme is always in use by all app components.
     *
     * This method must remain an arrow function in order to preserve the scope
     * of `this`, since it is being invoked by an EventBus callback.
     *
     * @for GameController
     * @method _setTheme
     * @param themeName {string}
     */

  }]);

  return GameController;
}();

var _default = new GameController();

exports["default"] = _default;

},{"../EventTracker":259,"../constants/eventNames":308,"../constants/gameOptionConstants":309,"../constants/globalConstants":310,"../constants/selectors":316,"../constants/themes":319,"../constants/trackableEvents":334,"../engine/TimeKeeper":338,"../lib/EventBus":346,"../math/core":349,"./GameOptions":340,"jquery":1,"lodash/forEach":199,"lodash/has":201}],340:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _EventTracker = _interopRequireDefault(require("../EventTracker"));

var _gameOptionConstants = require("../constants/gameOptionConstants");

var _trackableEvents = require("../constants/trackableEvents");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Set, store and retrieve game options.
 *
 * @class GameOptions
 */
var GameOptions =
/*#__PURE__*/
function () {
  /**
   * @for GameOptions
   * @constructor
   */
  function GameOptions() {
    _classCallCheck(this, GameOptions);

    /**
     * @property _eventBus
     * @type EventBus
     * @private
     */
    this._eventBus = _EventBus["default"];
    /**
     * @property _options
     * @type {Object}
     * @default {}
     * @private
     */

    this._options = {};
    /**
     * Model properties will be added for each game option
     * dynamically via `.addGameOptions()`
     *
     * @property {*}
     * @type {string}
     *
     * this[OPTION_NAME] = OPTION_VALUE;
     */

    this.addGameOptions();
  }
  /**
   * Add available game options to `_options` dictionary
   *
   * @for GameOptions
   * @method addGameOptions
   */


  _createClass(GameOptions, [{
    key: "addGameOptions",
    value: function addGameOptions() {
      for (var i = 0; i < _gameOptionConstants.GAME_OPTION_VALUES.length; i++) {
        var option = _gameOptionConstants.GAME_OPTION_VALUES[i];
        this.addOption(option);
      }
    }
    /**
     * @for GameOptions
     * @method addOption
     * @param optionProps {object}
     */

  }, {
    key: "addOption",
    value: function addOption(optionProps) {
      var optionStorageKey = this.buildStorageName(optionProps.name);
      var storedOptionValue = global.localStorage.getItem(optionStorageKey);
      this._options[optionProps.name] = optionProps;
      var optionValue = optionProps.defaultValue;

      if (!(0, _isNil2["default"])(storedOptionValue)) {
        optionValue = storedOptionValue;
      }

      this[optionProps.name] = optionValue;
    }
    /**
     * @for GameOptions
     * @method getDescriptions
     * @return {object}
     */

  }, {
    key: "getDescriptions",
    value: function getDescriptions() {
      return this._options;
    }
    /**
     * Gets the value of a given game option
     *
     * @for GameOptions
     * @method getOptionByName
     * @param name {string}
     * @return {object}
     */

  }, {
    key: "getOptionByName",
    value: function getOptionByName(name) {
      return this[name];
    }
    /**
     * Sets a game option to a given value
     *
     * will fire an event with the `EventBus` is one is registered
     *
     * @for GameOptions
     * @method setOptionByName
     * @param name {string} name of the option to change
     * @param value {string} value to set the option to
     */

  }, {
    key: "setOptionByName",
    value: function setOptionByName(name, value) {
      this[name] = value;
      var optionStorageKey = this.buildStorageName(name);
      global.localStorage.setItem(optionStorageKey, value);

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.SETTINGS, name, value);

      if (this._options[name].onChangeEventHandler) {
        this._eventBus.trigger(this._options[name].onChangeEventHandler, value);
      }

      return value;
    }
    /**
     * Build a string that can be used as a key for localStorage data
     *
     * @for GameOptions
     * @method buildStorageName
     * @param optionName {string}
     * @return {string}
     */

  }, {
    key: "buildStorageName",
    value: function buildStorageName(optionName) {
      return "zlsa.atc.option.".concat(optionName);
    }
  }]);

  return GameOptions;
}();

exports["default"] = GameOptions;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../EventTracker":259,"../constants/gameOptionConstants":309,"../constants/trackableEvents":334,"../lib/EventBus":346,"lodash/isNil":219}],341:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _GameController = _interopRequireWildcard(require("./GameController"));

var _UiController = _interopRequireDefault(require("../ui/UiController"));

var _unitConverters = require("../utilities/unitConverters");

var _eventNames = require("../constants/eventNames");

var _airportConstants = require("../constants/airportConstants");

var _modeControlConstants = require("../aircraft/ModeControl/modeControlConstants");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @class ScoreController
 */
var ScoreController =
/*#__PURE__*/
function () {
  function ScoreController(aircraftController) {
    _classCallCheck(this, ScoreController);

    /**
     * Whether the aircraft has received a clearance to conduct an approach to a runway
     *
     * @for ScoreController
     * @property _aircraftController
     * @type {boolean}
     * @private
     */
    this._aircraftController = aircraftController;
    this.init().setupHandlers().enable();
  }

  _createClass(ScoreController, [{
    key: "init",
    value: function init() {
      return this;
    }
    /**
     * @for ScoreController
     * @method setupHandler
     * @chainable
     */

  }, {
    key: "setupHandlers",
    value: function setupHandlers() {
      this._onTakeoffHandler = this._onTakeoff.bind(this);
      this._onApproachHandler = this._onApproach.bind(this);
      this._onLandingHandler = this._onLanding.bind(this);
      this._onExitAirspaceHandler = this._onExitAirspace.bind(this);
      return this;
    }
    /**
     * @for ScoreController
     * @method enable
     * @chainable
     */

  }, {
    key: "enable",
    value: function enable() {
      _EventBus["default"].on(_eventNames.AIRCRAFT_EVENT.TAKEOFF, this._onTakeoffHandler);

      _EventBus["default"].on(_eventNames.AIRCRAFT_EVENT.APPROACH, this._onApproachHandler);

      _EventBus["default"].on(_eventNames.AIRCRAFT_EVENT.FULLSTOP, this._onLandingHandler);

      _EventBus["default"].on(_eventNames.AIRCRAFT_EVENT.AIRSPACE_EXIT, this._onExitAirspaceHandler);

      return this;
    }
    /**
     * @for ScoreController
     * @method disable
     * @chainable
     */

  }, {
    key: "disable",
    value: function disable() {
      _EventBus["default"].off(_eventNames.AIRCRAFT_EVENT.TAKEOFF, this._onTakeoffHandler);

      _EventBus["default"].off(_eventNames.AIRCRAFT_EVENT.APPROACH, this._onApproachHandler);

      _EventBus["default"].off(_eventNames.AIRCRAFT_EVENT.FULLSTOP, this._onLandingHandler);

      _EventBus["default"].off(_eventNames.AIRCRAFT_EVENT.AIRSPACE_EXIT, this._onExitAirspaceHandler);

      return this;
    }
    /**
     * @for ScoreController
     * @method _onTakeoff
     * @param aircraftModel {AircraftModel}
     * @param runwayModel {RunwayModel}
     */

  }, {
    key: "_onTakeoff",
    value: function _onTakeoff(aircraftModel, runwayModel) {
      this._scoreWind(aircraftModel, 'taking off');

      this._scoreRunwaySeparation(aircraftModel, runwayModel, 'taking off');
    }
    /**
     * @for ScoreController
     * @method _onApproach
     * @param aircraftModel {AircraftModel}
     */

  }, {
    key: "_onApproach",
    value: function _onApproach(aircraftModel) {
      this._penalizeLocalizerInterceptAltitude(aircraftModel); // TODO: How can we evaluate the intercept angle?
      // if () {
      //     this._penalizeLocalizerInterceptAngle();
      // }

    }
    /**
     * @for ScoreController
     * @method _onLanding
     * @param aircraftModel {AircraftModel}
     * @param runwayModel {RunwayModel}
     */

  }, {
    key: "_onLanding",
    value: function _onLanding(aircraftModel, runwayModel) {
      this._scoreWind(aircraftModel, 'landed');

      this._scoreRunwaySeparation(aircraftModel, runwayModel, 'landed');
    }
    /**
     * @for ScoreController
     * @method _onExitAirspace
     * @param aircraftModel {AircraftModel}
     */

  }, {
    key: "_onExitAirspace",
    value: function _onExitAirspace(aircraftModel) {
      if (aircraftModel.isArrival()) {
        this._onAirspaceExitForArrival(aircraftModel);

        return;
      }

      if (aircraftModel.mcp.headingMode !== _modeControlConstants.MCP_MODE.HEADING.LNAV) {
        this._onAirspaceExitWithoutClearance(aircraftModel);

        return;
      }

      this._onAirspaceExitWithClearance(aircraftModel);
    }
    /**
     * An arriving aircraft is exiting the airpsace
     *
     * @for ScoreController
     * @method _onAirspaceExitForArrival
     * @param aircraftModel {AircraftModel}
     * @private
     */

  }, {
    key: "_onAirspaceExitForArrival",
    value: function _onAirspaceExitForArrival(aircraftModel) {
      aircraftModel.radioCall('leaving radar coverage as arrival', _airportConstants.AIRPORT_CONTROL_POSITION_NAME.APPROACH, true);

      _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.AIRSPACE_BUST);
    }
    /**
     * @for ScoreController
     * @method _onAirspaceExitWithClearance
     * @param aircraftModel {AircraftModel}
     * @private
     */

  }, {
    key: "_onAirspaceExitWithClearance",
    value: function _onAirspaceExitWithClearance(aircraftModel) {
      aircraftModel.radioCall('switching to center, good day', _airportConstants.AIRPORT_CONTROL_POSITION_NAME.DEPARTURE);

      _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.DEPARTURE);
    }
    /**
     * @for ScoreController
     * @method _onAirspaceExitWithoutClearance
     * @param aircraftModel {AircraftModel}
     * @private
     */

  }, {
    key: "_onAirspaceExitWithoutClearance",
    value: function _onAirspaceExitWithoutClearance(aircraftModel) {
      aircraftModel.radioCall('leaving airspace without being on our route', _airportConstants.AIRPORT_CONTROL_POSITION_NAME.DEPARTURE, true);

      _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.NOT_CLEARED_ON_ROUTE);
    }
    /**
     * @for ScoreController
     * @method _scoreWind
     * @param aircraftModel {AircraftModel}
     * @param action {string}
     */

  }, {
    key: "_scoreWind",
    value: function _scoreWind(aircraftModel, action) {
      var isWarning = true;
      var wind = aircraftModel.getWindComponents(); // TODO: these two if blocks could be done in a single switch statement

      if (wind.cross >= 20) {
        _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.EXTREME_CROSSWIND_OPERATION);

        _UiController["default"].ui_log("".concat(aircraftModel.callsign, " ").concat(action, " with major crosswind"), isWarning);
      } else if (wind.cross >= 10) {
        _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.HIGH_CROSSWIND_OPERATION);

        _UiController["default"].ui_log("".concat(aircraftModel.callsign, " ").concat(action, " with crosswind"), isWarning);
      }

      if (wind.head <= -10) {
        _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.EXTREME_TAILWIND_OPERATION);

        _UiController["default"].ui_log("".concat(aircraftModel.callsign, " ").concat(action, " with major tailwind"), isWarning);
      } else if (wind.head <= -5) {
        _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.HIGH_TAILWIND_OPERATION);

        _UiController["default"].ui_log("".concat(aircraftModel.callsign, " ").concat(action, " with tailwind"), isWarning);
      }
    }
    /**
     * @for ScoreController
     * @method _scoreRunwaySeparation
     * @param aircraftModel {AircraftModel}
     * @param runwayModel {RunwayModel}
     * @param action {string}
     */

  }, {
    key: "_scoreRunwaySeparation",
    value: function _scoreRunwaySeparation(aircraftModel, runwayModel, action) {
      var previousAircraft = this._aircraftController.findAircraftByCallsign(runwayModel.lastDepartedAircraftCallsign);

      if (!previousAircraft) {
        return;
      }

      var actualDistance = (0, _unitConverters.nm_ft)(aircraftModel.distanceToAircraft(previousAircraft));
      var requiredDistance = aircraftModel.model.calculateSameRunwaySeparationDistanceInFeet(previousAircraft.model);

      if (actualDistance < requiredDistance || previousAircraft.isOnGround()) {
        var isWarning = true;

        _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.NO_TAKEOFF_SEPARATION);

        _UiController["default"].ui_log("".concat(aircraftModel.callsign, " ").concat(action, " without adequate separation from another aircraft using the same runway"), isWarning);
      }
    }
    /**
     * Display a waring and record an illegal glideslope intercept event
     *
     * @for ScoreController
     * @method _penalizeLocalizerInterceptAltitude
     * @param aircraftModel {AircraftModel}
     */

  }, {
    key: "_penalizeLocalizerInterceptAltitude",
    value: function _penalizeLocalizerInterceptAltitude(aircraftModel) {
      if (!aircraftModel.isAboveGlidepath()) {
        return;
      }

      var isWarning = true;

      _UiController["default"].ui_log("".concat(aircraftModel.callsign, " intercepted localizer above glideslope"), isWarning);

      _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.LOCALIZER_INTERCEPT_ABOVE_GLIDESLOPE);
    }
    /**
     * Display a waring and record an illegal approach event
     *
     * @for ScoreController
     * @method _penalizeLocalizerInterceptAngle
     * @param aircraftModel {AircraftModel}
     */

  }, {
    key: "_penalizeLocalizerInterceptAngle",
    value: function _penalizeLocalizerInterceptAngle(aircraftModel) {
      var isWarning = true;

      _UiController["default"].ui_log("".concat(aircraftModel.callsign, " approach course intercept angle was greater than 30 degrees"), isWarning);

      _GameController["default"].events_recordNew(_GameController.GAME_EVENTS.ILLEGAL_APPROACH_CLEARANCE);
    }
  }]);

  return ScoreController;
}();

exports["default"] = ScoreController;

},{"../aircraft/ModeControl/modeControlConstants":273,"../constants/airportConstants":305,"../constants/eventNames":308,"../lib/EventBus":346,"../ui/UiController":385,"../utilities/unitConverters":391,"./GameController":339}],342:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _lowerCase2 = _interopRequireDefault(require("lodash/lowerCase"));

var _App = _interopRequireDefault(require("./App"));

var _airportConstants = require("./constants/airportConstants");

var _storageKeys = require("./constants/storageKeys");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

require('raf').polyfill();

function _isAirportIcaoInLoadList(icao, airportLoadList) {
  if ((0, _isNil2["default"])(icao)) {
    return false;
  }

  return airportLoadList.some(function (airport) {
    return airport.icao === icao;
  });
}

function getInitialAirport(airportLoadList) {
  var airportName = _airportConstants.DEFAULT_AIRPORT_ICAO;
  var previousAirportIcaoFromLocalStorage = localStorage[_storageKeys.STORAGE_KEY.ATC_LAST_AIRPORT];

  if (_isAirportIcaoInLoadList(previousAirportIcaoFromLocalStorage, airportLoadList)) {
    airportName = (0, _lowerCase2["default"])(localStorage[_storageKeys.STORAGE_KEY.ATC_LAST_AIRPORT]);
  }

  return airportName;
}
/**
 * Entry point for the application.
 *
 * Provides a way to grab the `body` element of the document and pass it to the app.
 */


var _default = function () {
  var airportLoadList = window.AIRPORT_LOAD_LIST;
  var initialAirportToLoad = getInitialAirport(airportLoadList);
  var $body = (0, _jquery["default"])('body'); // eslint-disable-next-line no-unused-vars

  var app = new _App["default"]($body, airportLoadList, initialAirportToLoad);
}();

exports["default"] = _default;

},{"./App":257,"./constants/airportConstants":305,"./constants/storageKeys":318,"jquery":1,"lodash/isNil":219,"lodash/lowerCase":230,"raf":256}],343:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _generalUtilities = require("../utilities/generalUtilities");

var _unitConverters = require("../utilities/unitConverters");

var _AirportController = _interopRequireDefault(require("../airport/AirportController"));

var _SimClockController = _interopRequireDefault(require("./SimClockController"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _globalConstants = require("../constants/globalConstants");

var _eventNames = require("../constants/eventNames");

var _airportInfoTemplate = require("./airportInfoTemplate");

var _aircraftConstants = require("../constants/aircraftConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @property INFO_VIEW_SELECTORS
 * @type {object<string, string>}
 * @final
 */
var INFO_VIEW_SELECTORS = {
  CLOCK_LABEL: '.js-airportInfo-clock-label',
  CLOCK_VALUE: '.js-airportInfo-clock-value',
  WIND_LABEL: '.js-airportInfo-wind-label',
  WIND_VALUE: '.js-airportInfo-wind-value',
  ALTIMETER_LABEL: '.js-airportInfo-altimeter-label',
  ALTIMETER_VALUE: '.js-airportInfo-altimeter-value',
  ELEVATION_LABEL: '.js-airportInfo-elevation-label',
  ELEVATION_VALUE: '.js-airportInfo-elevation-value'
};
/**
 * Gets information about the current airport, specifically
 * the airport's elevation, wind speed and direction, and altimeter.
 *
 * @class AirportInfoController
 */

var AirportInfoController =
/*#__PURE__*/
function () {
  /**
   * @for AirportInfoController
   * @constructor
   * @param {jQuery|HTML element}
   */
  function AirportInfoController($element) {
    _classCallCheck(this, AirportInfoController);

    /**
     * Root DOM element
     *
     * @for AirportInfoController
     * @property $element
     * @type {jQuery|HTML element}
     */
    this.$element = $element;
    /**
     * Information div
     *
     * @for AirportInfoController
     * @property $template
     * @type {jQuery|HTML element}
     */

    this.$template = null;
    /**
     * Information div
     *
     * @for AirportInfoController
     * @property $altimeterView
     * @type {jQuery|HTML element}
     */

    this.$altimeterView = null;
    /**
     * Information div
     *
     * @for AirportInfoController
     * @property $clockView
     * @type {jQuery|HTML element}
     */

    this.$clockView = null;
    /**
     * Information div
     *
     * @for AirportInfoController
     * @property $elevationView
     * @type {jQuery|HTML element}
     */

    this.$elevationView = null;
    /**
     * Information div
     *
     * @for AirportInfoController
     * @property $windView
     * @type {jQuery|HTML element}
     */

    this.$windView = null;
    /**
     * @for AirportInfoController
     * @property altimeter
     * @type {Number}
     */

    this.altimeter = _globalConstants.INVALID_NUMBER;
    /**
     * @for AirportInfoController
     * @property elevation
     * @type {String}
     */

    this.elevation = '';
    /**
     * @for AirportInfoController
     * @property icao
     * @type {String}
     */

    this.icao = '';
    /**
     * @for AirportInfoController
     * @property simClockController
     */

    this.simClockController = null;
    /**
     * @for AirportInfoController
     * @property wind
     * @type {String}
     */

    this.wind = '';
    /**
     * Local reference of the event bus
     *
     * @for AirportInfoController
     * @property _eventBus
     * @type {EventBus}
     */

    this._eventBus = _EventBus["default"];
    return this.init()._createChildren()._setupHandlers().enable().onAirportChange();
  } // ------------------------------ LIFECYCLE ------------------------------

  /**
   * @for AirportInfoController
   * @method init
   * @chainable
   */


  _createClass(AirportInfoController, [{
    key: "init",
    value: function init() {
      this.$template = (0, _jquery["default"])(_airportInfoTemplate.AIRPORT_INFO_TEMPLATE);
      this.$altimeterView = this.$template.find(INFO_VIEW_SELECTORS.ALTIMETER_VALUE);
      this.$clockView = this.$template.find(INFO_VIEW_SELECTORS.CLOCK_VALUE);
      this.$elevationView = this.$template.find(INFO_VIEW_SELECTORS.ELEVATION_VALUE);
      this.$windView = this.$template.find(INFO_VIEW_SELECTORS.WIND_VALUE);
      this.altimeter = _globalConstants.INVALID_NUMBER;
      this.elevation = '';
      this.icao = '';
      this.simClockController = new _SimClockController["default"]();
      this.wind = '';
      this._eventBus = _EventBus["default"];
      return this;
    }
    /**
     * Set initial element references
     *
     * Should be run once only on instantiation
     *
     * @for StripViewModel
     * @method _createChildren
     * @chainable
     * @private
     */

  }, {
    key: "_createChildren",
    value: function _createChildren() {
      this.$element.append(this.$template);
      return this;
    }
    /**
     * @for AirportInfoController
     * @method _setupHandlers
     * @chainable
     * @private
     */

  }, {
    key: "_setupHandlers",
    value: function _setupHandlers() {
      this._onAirportChangeHandler = this.onAirportChange.bind(this);
      return this;
    }
    /**
     * Enable all event handlers
     *
     * @for AirportInfoController
     * @method _enable
     * @chainable
     */

  }, {
    key: "enable",
    value: function enable() {
      this._eventBus.on(_eventNames.EVENT.AIRPORT_CHANGE, this._onAirportChangeHandler);

      return this;
    }
    /**
     * Disable all event handlers
     *
     * @for AirportInfoController
     * @method _disable
     * @chainable
     */

  }, {
    key: "disable",
    value: function disable() {
      this._eventBus.off(_eventNames.EVENT.AIRPORT_CHANGE, this._onAirportChangeHandler);

      return this;
    }
    /**
     * @for AirportInfoController
     * @method reset
     * @chainable
     */

  }, {
    key: "reset",
    value: function reset() {
      this.$element = null;
      this.$template = null;
      this.altimeter = null;
      this.elevation = null;
      this.icao = null;
      this.simClockController = null;
      this.wind = null;
      this._eventBus = null;
      return this;
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Updates the information taken from the AirportModel: the wind, the altimeter,
     * and the elevation. Triggered on airport change.
     *
     * @for AirportInfoController
     * @method onAirportChange
     */

  }, {
    key: "onAirportChange",
    value: function onAirportChange() {
      var airport = _AirportController["default"].airport_get();

      var windAngle = Math.round((0, _unitConverters.radiansToDegrees)(airport.wind.angle));
      this.wind = this._buildWindAndGustReadout({
        speed: airport.wind.speed,
        angle: windAngle
      });
      this.altimeter = this._generateHighAltimeterReading(airport.wind.speed);
      this.elevation = "".concat(airport.elevation);
      this.icao = airport.icao.toUpperCase();

      this._render();
    }
    /**
     * Updates the clock, called from `AppController#update_pre`
     *
     * @for AirportInfoController
     * @method updateClock
     */

  }, {
    key: "updateClock",
    value: function updateClock() {
      var readout = this.simClockController.buildClockReadout();
      this.$clockView.text(readout);
    } // ------------------------------ PRIVATE ------------------------------

    /**
     * Formats the wind angle and speed from object into a string,
     * in the format `${newAngle} ${newSpeed}G${gustSpeed}`.
     *
     * Example output: 270 10G18
     *
     * @for AirportGameInfoView
     * @method _buildWindAndGustReadout
     * @param {Object} wind
     * @returns {String} formatted string
     * @private
     */

  }, {
    key: "_buildWindAndGustReadout",
    value: function _buildWindAndGustReadout(wind) {
      var minGustStrength = 5;
      var speed = wind.speed;
      var angle = wind.angle;
      var newAngle = (0, _generalUtilities.leftPad)(angle || 360, 3);
      var newSpeed = (0, _generalUtilities.leftPad)(speed, 2); // Creates a fake "gusting" speed

      var gustStrength = speed * Math.random();
      var gustSpeed = (0, _generalUtilities.leftPad)(Math.round(speed + gustStrength), 2);

      if (gustStrength < minGustStrength) {
        return "".concat(newAngle, " ").concat(newSpeed);
      }

      return "".concat(newAngle, " ").concat(newSpeed, " G").concat(gustSpeed);
    }
    /**
     * Creates an 'altimeter' reading for the info view
     *
     * @for AirportInfoController
     * @method _generateHighAltimeterReading
     * @param {Number} windSpeed
     * @returns {Number} the altimeter value (29.92 or above)
     * @private
     */

  }, {
    key: "_generateHighAltimeterReading",
    value: function _generateHighAltimeterReading(windSpeed) {
      var pressure = _aircraftConstants.PERFORMANCE.DEFAULT_ALTIMETER_IN_INHG + windSpeed * Math.random() / 100;
      return pressure.toFixed(2);
    }
    /**
     * Sets the values from the updated airport info.
     *
     * @for AirportInfoController
     * @method _render
     * @private
     */

  }, {
    key: "_render",
    value: function _render() {
      this.$windView.text("".concat(this.icao, " ").concat(this.wind));
      this.$altimeterView.text("".concat(this.icao, " ").concat(this.altimeter));
      this.$elevationView.text("".concat(this.icao, " ").concat(this.elevation));
    }
  }]);

  return AirportInfoController;
}();

exports["default"] = AirportInfoController;

},{"../airport/AirportController":284,"../constants/aircraftConstants":303,"../constants/eventNames":308,"../constants/globalConstants":310,"../lib/EventBus":346,"../utilities/generalUtilities":387,"../utilities/unitConverters":391,"./SimClockController":344,"./airportInfoTemplate":345,"jquery":1}],344:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _TimeKeeper = _interopRequireDefault(require("../engine/TimeKeeper"));

var _radioUtilities = require("../utilities/radioUtilities");

var _globalConstants = require("../constants/globalConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Manages a clock that stays in sync with the current game time
 * @class SimClockController
 */
var SimClockController =
/*#__PURE__*/
function () {
  /**
   * @for SimClockController
   * @constructor
   */
  function SimClockController() {
    _classCallCheck(this, SimClockController);

    /**
     * @for SimClockController
     * @property startTime
     * @type {Number}
     * @default 0
     */
    this.startTime = 0;
    return this._init();
  }
  /**
   * @for SimClockController
   * @method _init
   * @private
   */


  _createClass(SimClockController, [{
    key: "_init",
    value: function _init() {
      this.startTime = this.realWorldCurrentZuluTime;
      return this;
    }
    /**
     * Get current time in the user's time zone
     *
     *  @for SimClockController
     * @property realWorldCurrentLocalTime
     * @return {number} ms since 01/01/1970, 00:00:00 (user's time zone)
     */

  }, {
    key: "reset",

    /**
     * @for SimClockController
     * @method reset
     * @chainable
     */
    value: function reset() {
      this.startTime = 0;
      return this;
    }
    /**
     * Generates a string of the current game time in a human-readable format
     *
     * @for SimClockController
     * @method buildClockReadout
     * @return clockTime {string} current game time formatted like '03:44:17'
     */

  }, {
    key: "buildClockReadout",
    value: function buildClockReadout() {
      var elapsedTimeInMilliseconds = _TimeKeeper["default"].accumulatedDeltaTime * _globalConstants.TIME.ONE_SECOND_IN_MILLISECONDS;
      var clockDate = new Date(this.startTime + elapsedTimeInMilliseconds);
      var hours = (0, _radioUtilities.digits_integer)(clockDate.getHours(), 2);
      var minutes = (0, _radioUtilities.digits_integer)(clockDate.getMinutes(), 2);
      var seconds = (0, _radioUtilities.digits_integer)(clockDate.getSeconds(), 2);
      var clockTime = "".concat(hours).concat(minutes, "/").concat(seconds);
      return clockTime;
    }
  }, {
    key: "realWorldCurrentLocalTime",
    get: function get() {
      return new Date().getTime();
    }
    /**
     * Get current zulu time in milliseconds
     *
     * @for SimClockController
     * @property realWorldCurrentZuluTime
     * @return utc {number} ms since 01/01/1970, 00:00:00 UTC
     */

  }, {
    key: "realWorldCurrentZuluTime",
    get: function get() {
      var date = new Date();

      var utc = date.getTime() + date.getTimezoneOffset() * _globalConstants.TIME.ONE_MINUTE_IN_MILLISECONDS;

      return utc;
    }
  }]);

  return SimClockController;
}();

exports["default"] = SimClockController;

},{"../constants/globalConstants":310,"../engine/TimeKeeper":338,"../utilities/radioUtilities":389}],345:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AIRPORT_INFO_TEMPLATE = void 0;

/**
 * HTML template for the airport info view and clock.
 *
 * @property AIRPORT_INFO_TEMPLATE
 * @type {String|HTML Element}
 * @final
 */
var AIRPORT_INFO_TEMPLATE = '' + '<div id="airportInfo" class="notSelectable">' + '    <div class="airportInfo-line">' + '        <div class="airportInfo-label js-airportInfo-clock-label">TIME</div>' + '        <div class="airportInfo-value js-airportInfo-clock-value"></div>' + '    </div>' + '    <div class="airportInfo-line">' + '        <div class="airportInfo-label js-airportInfo-wind-label">WIND</div>' + '        <div class="airportInfo-value js-airportInfo-wind-value"></div>' + '    </div>' + '    <div class="airportInfo-line">' + '        <div class="airportInfo-label js-airportInfo-altimeter-label">ALTIM</div>' + '        <div class="airportInfo-value js-airportInfo-altimeter-value"></div>' + '    </div>' + '    <div class="airportInfo-line">' + '        <div class="airportInfo-label js-airportInfo-elevation-label">ELEV</div>' + '        <div class="airportInfo-value js-airportInfo-elevation-value"></div>' + '    </div>' + '</div>';
exports.AIRPORT_INFO_TEMPLATE = AIRPORT_INFO_TEMPLATE;

},{}],346:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _has2 = _interopRequireDefault(require("lodash/has"));

var _EventModel = _interopRequireDefault(require("./EventModel"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Creates a static class that should be used for cross class communication.
 *
 * This alleviates the need for direct imports between classes. Instead, the class
 * that performs an action need only `trigger` and any listening classes can respond
 * with their own internal callback.
 *
 * As a rule, when this class is used it should be reassigned to an instance property `#eventBus`.
 *
 * Example:
 * - triggering class `this.eventBus.trigger('EVENT_NAME', DATA_TO_PASS)`
 * - responding class `this.eventBus.on('EVENT_NAME', this.onEventCallback)`
 *
 * @class EventBus
 */
var EventBus =
/*#__PURE__*/
function () {
  /**
   * @constructor
   */
  function EventBus() {
    _classCallCheck(this, EventBus);

    /**
     * Dictionary of `eventNames`
     *
     * @property _events
     * @type {object<string, EventModel>}
     * @default {}
     * @private
     */
    this._events = {};
  }
  /**
   * @for EventBus
   * @method destroy
   */


  _createClass(EventBus, [{
    key: "destroy",
    value: function destroy() {
      this._events = {};
    }
    /**
     * Register an event with a callback
     *
     * If an eventName already exists, add the observer to the observers list
     *
     * @for EventBus
     * @method on
     * @param eventName {string}   the name of an event
     * @param callback {function}  function to be called when an event is triggered
     */

  }, {
    key: "on",
    value: function on(eventName, callback) {
      if (this.has(eventName)) {
        this._events[eventName].addObserver(callback);

        return;
      }

      this._events[eventName] = new _EventModel["default"](eventName);

      this._addObserver(eventName, callback);
    }
    /**
     * Remove a callback from the observers list
     *
     * When multiple observers exist, remove only the one callback from that list
     *
     * When `eventName` is the only observer, the event will be destroyed
     * and removed from `#_events`.
     *
     * @for EventBus
     * @method off
     * @param eventName {string}   the name of an event
     * @param callback {function}  function to remove from an events observers list
     */

  }, {
    key: "off",
    value: function off(eventName, callback) {
      if (!this.has(eventName)) {
        return;
      }

      this._removeObserver(eventName, callback);

      if (this._events[eventName].observers.length < 1) {
        this._removeEventKey(eventName);
      }
    }
    /**
     * Trigger an event
     *
     * Will result in calling all of the observers listed for a particular
     * event with the provided argument(s)
     *
     * @for EventBus
     * @method trigger
     * @param eventName {string}
     * @param args {rest parameter}
     */

  }, {
    key: "trigger",
    value: function trigger(eventName) {
      if (!this.has(eventName)) {
        return;
      }

      var observers = this._events[eventName].observers;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      for (var i = 0; i < observers.length; i++) {
        observers[i].apply(observers, args);
      }
    }
    /**
     * Boolean helper used to determine if `eventName` exists within `#_events`
     *
     * @for EventBus
     * @method has
     * @return {boolean}
     */

  }, {
    key: "has",
    value: function has(eventName) {
      return (0, _has2["default"])(this._events, eventName);
    }
    /**
     * Add an observer to an event's observer list
     *
     * @for EventBus
     * @method _addObserver
     * @param eventName {string}
     * @param callback {function}
     * @private
     */

  }, {
    key: "_addObserver",
    value: function _addObserver(eventName, callback) {
      this._events[eventName].addObserver(callback);
    }
    /**
     * Remove an observer from an event's observer list
     *
     * @for EventBus
     * @method _removeObserver
     * @param eventName {string}
     * @param callback {function}
     * @private
     */

  }, {
    key: "_removeObserver",
    value: function _removeObserver(eventName, callback) {
      this._events[eventName].removeObserver(callback);
    }
    /**
     * Remove a key from `#_events`
     *
     * This should only be called after the removal of the last observer
     * for an `eventName`.
     *
     * @for EventBus
     * @method _removeEventKey
     * @param eventName {string}
     * @private
     */

  }, {
    key: "_removeEventKey",
    value: function _removeEventKey(eventName) {
      delete this._events[eventName];
    }
  }]);

  return EventBus;
}();

var _default = new EventBus();

exports["default"] = _default;

},{"./EventModel":347,"lodash/has":201}],347:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _globalConstants = require("../constants/globalConstants");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Defines an event and an event's observers
 *
 * Should be used by the `EventBus` when defining new events
 *
 * @class EventModel
 */
var EventModel =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param name {string}
   */
  function EventModel(name) {
    _classCallCheck(this, EventModel);

    /**
     * The name of an event
     *
     * @property name
     * @type {string}
     * @default ''
     */
    this.name = '';
    /**
     * Functions that will be called when this event is triggered
     *
     * @property observers
     * @type {*[]}
     * @default []
     */

    this.observers = [];
    this.init(name);
  }
  /**
   * @for EventModel
   * @method init
   * @param  name {string}
   */


  _createClass(EventModel, [{
    key: "init",
    value: function init(name) {
      this.name = name;
    }
    /**
     * @for EventModel
     * @method destroy
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.name = '';
      this.observers = [];
    }
    /**
     * add a callback(s) that fires when an event is triggered
     *
     * @for EventModel
     * @method addObserver
     * @param observer
     */

  }, {
    key: "addObserver",
    value: function addObserver(observer) {
      if (this.hasObserver(observer)) {
        return;
      }

      this.observers.push(observer);
    }
    /**
     * remove an observer from the observers list
     *
     * @for EventModel
     * @method removeObserver
     * @param  observer
     */

  }, {
    key: "removeObserver",
    value: function removeObserver(observer) {
      if (!this.hasObserver(observer)) {
        return;
      }

      var index = this.observers.indexOf(observer);
      this.observers.splice(index, 1);
    }
    /**
     * Determine if a passed observer exists within the current observer list
     *
     * @for EventModel
     * @method hasObserver
     * @param observer {function}
     * @return {boolean}
     */

  }, {
    key: "hasObserver",
    value: function hasObserver(observer) {
      return this.observers.indexOf(observer) !== _globalConstants.INVALID_INDEX;
    }
  }]);

  return EventModel;
}();

exports["default"] = EventModel;

},{"../constants/globalConstants":310}],348:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distanceToPoint = exports.radians_normalize = exports.degrees_normalize = exports.angle_offset = exports.tau = void 0;

var _core = require("./core");

var _unitConverters = require("../utilities/unitConverters");

/**
 * 2x Pi
 *
 * @function tau
 * @return {number}
 */
var tau = function tau() {
  return Math.PI * 2;
};
/**
 * Returns the angle difference between two headings
 *
 * @function angle_offset
 * @param {number} a     heading, in radians
 * @param {number} b     heading, in radians
 * @return {number}
 */


exports.tau = tau;

var angle_offset = function angle_offset(a, b) {
  a = (0, _unitConverters.radiansToDegrees)(a);
  b = (0, _unitConverters.radiansToDegrees)(b);
  var invert = false;

  if (b > a) {
    invert = true;
    var temp = a;
    a = b;
    b = temp;
  }

  var offset = (0, _core.mod)(a - b, 360);

  if (offset > 180) {
    offset -= 360;
  }

  if (invert) {
    offset *= -1;
  }

  offset = (0, _unitConverters.degreesToRadians)(offset);
  return offset;
};
/**
 * normalize angles to within 0° - 360°
 * @param  {number} degrees an angle
 * @return {number}         an angle within [0,360]
 */


exports.angle_offset = angle_offset;

var degrees_normalize = function degrees_normalize(degrees) {
  if (degrees >= 0) {
    return degrees % 360;
  }

  return 360 + degrees % 360;
};
/**
 * normalize angles to within 0 - 2π
 * @param  {number} radians an angle
 * @return {number}         an angle within [0,2π]
 */


exports.degrees_normalize = degrees_normalize;

var radians_normalize = function radians_normalize(radians) {
  if (radians >= 0) {
    return radians % tau();
  }

  return tau() + radians % tau();
};
/**
 * Calculate the distance between two lat/long coordinates in km
 *
 * This is a javascript implementation of the Haversine Formula
 *
 * for more information on the math see:
 * - http://www.movable-type.co.uk/scripts/latlong.html
 * - http://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula
 *
 * @function distanceToPoint
 * @param startLatitude {number}
 * @param startLongitude {number}
 * @param endLatitude {number}
 * @param endLongitude {number}
 * return {number}
 */


exports.radians_normalize = radians_normalize;

var distanceToPoint = function distanceToPoint(startLatitude, startLongitude, endLatitude, endLongitude) {
  // TODO: add to global constants
  var EARTH_RADIUS_KM = 6371;
  var startLatitudeRadians = (0, _unitConverters.degreesToRadians)(startLatitude);
  var endLatitudeRadians = (0, _unitConverters.degreesToRadians)(endLatitude);
  var distanceLatitude = (0, _unitConverters.degreesToRadians)(startLatitude - endLatitude);
  var distanceLongitude = (0, _unitConverters.degreesToRadians)(startLongitude - endLongitude); // the square of half the chord length between points

  var a = Math.pow(Math.sin(distanceLatitude / 2), 2) + Math.cos(startLatitudeRadians) * Math.cos(endLatitudeRadians) * Math.pow(Math.sin(distanceLongitude / 2), 2);
  var angularDistanceInRadians = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return angularDistanceInRadians * EARTH_RADIUS_KM;
}; // /**
//  *
//  * @function distEuclid
//  * @param
//  * @param
//  * @return
//  */
// export const distEuclid = (lat1, lon1, lat2, lon2) => {
//     // TODO: add to global constants
//     const EARTH_RADIUS_KM = 6371;
//     const lat1 = degreesToRadians(lat1);
//     const lat2 = degreesToRadians(lat2);
//     const dlat = degreesToRadians(lat2 - lat1);
//     const dlon = degreesToRadians(lon2 - lon1);
//
//     const a = Math.sin(dlat / 2) * Math.sin(dlat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlon / 2) * Math.sin(dlon / 2);
//     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
//     const d = EARTH_RADIUS_KM * c;
//
//     return d; // distance, in kilometers
// };


exports.distanceToPoint = distanceToPoint;

},{"../utilities/unitConverters":391,"./core":349}],349:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.round = round;
exports.abs = abs;
exports.sin = sin;
exports.cos = cos;
exports.tan = tan;
exports.fl = fl;
exports.randint = randint;
exports.s = s;
exports.isWithin = isWithin;
exports.isWithinEpsilon = isWithinEpsilon;
exports.calculateMiddle = calculateMiddle;
exports.mod = mod;
exports.clamp = clamp;
exports.spread = spread;
exports.extrapolate_range_clamp = extrapolate_range_clamp;
exports.generateRandomOctalWithLength = generateRandomOctalWithLength;

var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));

var _random2 = _interopRequireDefault(require("lodash/random"));

var _generalUtilities = require("../utilities/generalUtilities");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * @function round
 * @return {number}
 */
function round(n) {
  var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return Math.round(n / factor) * factor;
}
/**
 * @function abs
 * @return {number}
 */


function abs(n) {
  return Math.abs(n);
}
/**
 * @function sin
 * @return {number}
 */


function sin(a) {
  return Math.sin(a);
}
/**
 * @function cos
 * @return {number}
 */


function cos(a) {
  return Math.cos(a);
}
/**
 * @function tan
 * @return {number}
 */


function tan(a) {
  return Math.tan(a);
} // TODO: rename to floor,

/**
 * @function fl
 * @return {number}
 */


function fl(n) {
  var number = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return Math.floor(n / number) * number;
} // TODO: rename to randomInteger

/**
 * @function randint
 * @return {number}
 */


function randint(low, high) {
  return Math.floor(Math.random() * (high - low + 1)) + low;
} // TODO: rename to pluralize

/**
 * @function s
 * @return {number}
 */


function s(i) {
  return i === 1 ? '' : 's';
}
/**
 * Checks whether or not a given value is between (inclusive) two given values
 *
 * Note: The more efficient order is to pass (value, minimum, maximum), but if the
 * relative values are not known, the function will still conduct the comparison
 * correctly.
 *
 * @function isWithin
 * @param value {number}    the value in question
 * @param limit1 {number}   constraining value (inclusive)
 * @param limit2 {number}   constraining value (inclusive)
 * @return {boolean}
 */


function isWithin(value, limit1, limit2) {
  if (limit1 > limit2) {
    var oldLimit1 = limit1;
    limit1 = limit2;
    limit2 = oldLimit1;
  }

  return limit1 <= value && value <= limit2;
}
/**
 * Test if a value is within EPSILON of an expected value
 *
 * this is necessary because of approximation due to the floating point arithmetics (i think)
 * For example: Math.cos(Math.PI/2) returns 6.123233995736766e-17 instead of 0
 * In this case iswithinEpsilon(Math.cos(Math.PI/2), 0) would return true
 *
 * @param {number}   value            the value we want to test
 * @param {number}   expectedValue    the value we want to test against
 * @return boolean  true if the value is within EPSILON of the expected value, false otherwise
 */


function isWithinEpsilon(value, expectedValue) {
  var lowerBound = expectedValue - Number.EPSILON;
  var upperBound = expectedValue + Number.EPSILON;
  return isWithin(value, lowerBound, upperBound);
} // TODO: add a divisor paramater that defaults to `2`

/**
 * Given a number, find the middle value.
 *
 * @method calculateMiddle
 * @param  {number} value
 * @return {number}
 */


function calculateMiddle() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  if (!(0, _isNumber2["default"])(value)) {
    throw new TypeError("Invalid parameter, expected a number but found ".concat(_typeof(value)));
  }

  return round(value / 2);
}
/**
 *
 * @function mod
 * @param firstValue {number}
 * @param secondValue {number}
 * @return {number}
 */


function mod(firstValue, secondValue) {
  return (firstValue % secondValue + secondValue) % secondValue;
} // TODO: Reorder as (valueToClamp, min, max) to maintain uniformity with the lodash equivalent

/**
 * Clamp a value to be within a certain range
 * Note: For the opposite, see `spread()`
 *
 * @function clamp
 * @param min {number}
 * @param valueToClamp {number}
 * @param max {number} (optional)
 * @return {number}
 */


function clamp(min, valueToClamp) {
  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
  var temp;

  if (!(0, _isNumber2["default"])(valueToClamp)) {
    throw new TypeError('Invalid parameter. Expected `valueToClamp` to be a number');
  }

  if (max === Infinity) {
    if (min > valueToClamp) {
      return min;
    }

    return valueToClamp;
  }

  if (min > max) {
    temp = max;
    max = min;
    min = temp;
  }

  if (min > valueToClamp) {
    return min;
  }

  if (max < valueToClamp) {
    return max;
  }

  return valueToClamp;
}
/**
 * Spread a value to be OUTSIDE OF a certain range
 * Note: For the opposite, see `clamp()`
 *
 * @function spread
 * @param value {number} the value in question
 * @param lowerLimit {number} the minimum value that is considered unacceptable
 * @param upperLimit {number} the maximum value that is considered unacceptable
 * @return {number}
 */


function spread(value, lowerLimit, upperLimit) {
  var averageOfLimits = (lowerLimit + upperLimit) / 2;

  if (value <= lowerLimit || value >= upperLimit) {
    return value;
  }

  if (value < averageOfLimits) {
    return lowerLimit;
  }

  return upperLimit;
}
/**
 * Takes a value's position relative to a given range, and extrapolates to another range.
 *
 * Note: Return will be outside range2 if target_val is outside range1.
 *       If you wish to clamp it within range2, use extrapolate_range_clamp.
 *
 * @function extrapolate_range
 * @param  {number} range1_min minimum value of range 1
 * @param  {number} target_val target value within range 1
 * @param  {number} range1_max maximum value of range 1
 * @param  {number} range2_min minimum value of range 2
 * @param  {number} range2_max maximum value of range 2
 * @return {number}            target value wihtin range 2
 */


function extrapolate_range(range1_min, target_val, range1_max, range2_min, range2_max) {
  return range2_min + (range2_max - range2_min) * (target_val - range1_min) / (range1_max - range1_min);
}
/**
 * Take a value's location relative to a given range then extrapolate to (and clamp within) another range.
 *
 * Note: Return will be clamped within range2, even if target_val is outside range1.
 *       If you wish to allow extrapolation beyond the bounds of range2, us extrapolate_range.
 *
 * @function extrapolate_range_clamp
 * @param  {number} range1Min       minimum value of range1
 * @param  {number} targetValue     target value relative to range1
 * @param  {number} range1Max       maximum value of range1
 * @param  {number} range2Min       minimum value of range2
 * @param  {number} range2Max       maximum value of range2
 * @return {number}                 target value within range2
 */


function extrapolate_range_clamp(range1Min, targetValue, range1Max, range2Min, range2Max) {
  var extrapolationResult = extrapolate_range(range1Min, targetValue, range1Max, range2Min, range2Max);
  return clamp(extrapolationResult, range2Min, range2Max);
}
/**
 * Generate a random number with each digit between 0-7
 *
 * @function generateRandomOctalWithLength
 * @return {string}                         number with digits between 0-7
 */


function generateRandomOctalWithLength() {
  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  var value = [];

  for (var i = 0; i < length; i++) {
    var randomOctal = (0, _random2["default"])(0, 7);
    value.push(randomOctal);
  }

  return (0, _generalUtilities.leftPad)(value.join(''), length);
}

},{"../utilities/generalUtilities":387,"lodash/isNumber":220,"lodash/random":237}],350:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distance2d = void 0;

/**
 * Calculate distance in a 2d plane between two points
 *
 * @function distance2d
 * @param a {array}
 * @param b {array}
 * return {number}
 */
var distance2d = function distance2d(a, b) {
  var x = a[0] - b[0];
  var y = a[1] - b[1];
  return Math.sqrt(x * x + y * y);
};

exports.distance2d = distance2d;

},{}],351:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcTurnRadiusByBankAngle = calcTurnRadiusByBankAngle;
exports.calcTurnRadiusByTurnRate = calcTurnRadiusByTurnRate;
exports.calcTurnInitiationDistanceNm = calcTurnInitiationDistanceNm;
exports.bearingToPoint = bearingToPoint;
exports.getOffset = getOffset;
exports.calculateTurnInitiationDistance = calculateTurnInitiationDistance;
exports.calculateCrosswindAngle = calculateCrosswindAngle;

var _core = require("./core");

var _circle = require("./circle");

var _vector = require("./vector");

var _unitConverters = require("../utilities/unitConverters");

var _aircraftConstants = require("../constants/aircraftConstants");

/**
 * Calculate the radius of turn of the aircraft, given its groundspeed
 *
 * Reference:
 * http://www.flightlearnings.com/2009/08/26/radius-of-turn/
 * https://en.wikipedia.org/wiki/Banked_turn#Banked_turn_in_aeronautics
 *
 * Possible conversion factor constants:
 *    - 68416 (yields nautical miles)
 *    - 11.26 (yields feet)
 *
 * @function calcTurnRadiusByBankAngle
 * @param speed {number} aircraft groundspeed, in knots
 * @param bankAngle {number} bank angle to use, in radians
 * @return {number} radius of turn, in nautical miles
 */
function calcTurnRadiusByBankAngle(speed, bankAngle) {
  var conversionFactor = 68416; // yields radius in nautical miles

  return speed * speed / (conversionFactor * Math.tan(bankAngle));
}
/**
 * Calculate the radius of turn of the aircraft, given its groundspeed and
 * its turn rate
 *
 * R = speedInKnots / (turnRateInDegreePerSecond * 20 * PI)
 *
 * https://en.wikipedia.org/wiki/Standard_rate_turn#Formulae
 *
 * @function calcTurnRadiusByTurnRate
 * @param speed {number} aircraft groundspeed, in knots
 * @param turnRate {number} in radians per second
 * @return {number} radius of turn, in nautical miles
 */


function calcTurnRadiusByTurnRate(speed, turnRate) {
  return speed / (turnRate * 180 * 20);
}
/**
 * The turn initiation distance is the distance that is necessary to complete
 * a turn before reaching of a fly-by turn.
 *
 * @function calcTurnInitiationDistanceNm
 * @param speed {number}        current speed of the aircraft in knots
 * @param turnRate {number}     turn rate of the aircraft in radian per second
 * @param courseChange {number} angular difference, in radians
 * @return {number}
 */


function calcTurnInitiationDistanceNm(speed, turnRate, courseChange) {
  var turnRadiusNm = calcTurnRadiusByTurnRate(speed, turnRate);
  return turnRadiusNm * Math.tan(courseChange * 0.5);
}
/**
 * Returns the bearing from `startPosition` to `endPosition`
 * @function bearingToPoint
 * @param startPosition {array}     positional array, start point
 * @param endPosition {array}       positional array, end point
 * @return {number}
 */


function bearingToPoint(startPosition, endPosition) {
  return (0, _vector.vradial)((0, _vector.vsub)(endPosition, startPosition));
} // TODO: this may be better suited to live in an Aircraft model somewhere.
// TODO: This is goofy like this. Should be changed to accept (PositionModel, PositionModel, heading)

/**
 * Returns an offset array showing how far [fwd/bwd, left/right] 'aircraft' is of 'target'
 *
 * @param aircraft {AircraftModel}      the aircraft in question
 * @param target {array}                        positional array of the targeted position [x,y]
 * @param headingThruTarget {number} (optional) The heading the aircraft should
 *                                              be established on when passing the target.
 *                                              Default value is the aircraft's heading.
 * @returns {array}                             [0] is the lateral offset, in km
 *                                              [1] is the longitudinal offset, in km
 *                                              [2] is the hypotenuse (straight-line distance), in km
 */


function getOffset(aircraft, target) {
  var headingThruTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!headingThruTarget) {
    headingThruTarget = aircraft.heading;
  }

  var offset = [0, 0, 0];
  var vector = (0, _vector.vsub)(target, aircraft.relativePosition); // vector from aircraft pointing to target

  var bearingToTarget = (0, _vector.vradial)(vector);
  offset[2] = (0, _vector.vlen)(vector);
  offset[0] = offset[2] * (0, _core.sin)(headingThruTarget - bearingToTarget);
  offset[1] = offset[2] * (0, _core.cos)(headingThruTarget - bearingToTarget);
  return offset;
}
/**
 * @function _calculateNominalNewCourse
 * @param nextWaypointRelativePosition {array}
 * @param currentWaypointRelativePosition {array}
 * @return nominalNewCourse {number}
 * */


function _calculateNominalNewCourse(nextWaypointRelativePosition, currentWaypointRelativePosition) {
  var nominalNewCourse = (0, _vector.vradial)((0, _vector.vsub)(nextWaypointRelativePosition, currentWaypointRelativePosition)); // normalize angle within 0 to 2pi

  if (nominalNewCourse < 0) {
    nominalNewCourse += (0, _circle.tau)();
  }

  return nominalNewCourse;
}
/**
 * @function _calculateCourseChangeInRadians
 * @param currentHeading {number}
 * @param nominalNewCourse {number}
 * @return {number}
 */


function _calculateCourseChangeInRadians(currentHeading, nominalNewCourse) {
  var courseChange = (0, _core.abs)((0, _unitConverters.radiansToDegrees)(currentHeading) - (0, _unitConverters.radiansToDegrees)(nominalNewCourse));

  if (courseChange > 180) {
    courseChange = 360 - courseChange;
  }

  return (0, _unitConverters.degreesToRadians)(courseChange);
}
/**
 * Calculate the turn initiation distance for an aircraft to navigate between two fixes.
 *
 * References:
 * - http://www.ohio.edu/people/uijtdeha/ee6900_fms_00_overview.pdf, Fly-by waypoint
 * - The Avionics Handbook, ch 15
 *
 * @function calculateTurnInitiationDistance
 * @param aircraft {AircraftModel}
 * @param currentWaypointPosition {StaticPositionModel}
 * @return {number} distance before fix to initiate turn to level out on route, in nautical miles
 */


function calculateTurnInitiationDistance(aircraft, currentWaypointPosition) {
  var nextWaypointModel = aircraft.fms.nextWaypoint;

  if (!aircraft.fms.hasNextWaypoint() || nextWaypointModel.isVectorWaypoint) {
    return 0;
  } // use the target heading instead of the actual heading to take into account
  // that we might be already turning and there might be no need to initiate
  // a turn at the moment. see #935


  var targetHeading = aircraft.targetHeading;

  if (targetHeading < 0) {
    targetHeading += (0, _circle.tau)();
  }

  var turnRate = _aircraftConstants.PERFORMANCE.TURN_RATE;

  var nominalNewCourse = _calculateNominalNewCourse(nextWaypointModel.relativePosition, currentWaypointPosition.relativePosition);

  var courseChange = _calculateCourseChangeInRadians(targetHeading, nominalNewCourse);

  var turnInitiationDistanceNm = calcTurnInitiationDistanceNm(aircraft.groundSpeed, turnRate, courseChange);
  return turnInitiationDistanceNm;
}
/**
 * @function calculateCrosswindAngle
 * @param runwayAngle {number}
 * @param windAngle {number}
 * @return {number}
 */


function calculateCrosswindAngle(runwayAngle, windAngle) {
  return (0, _core.abs)((0, _circle.angle_offset)(runwayAngle, windAngle));
}

},{"../constants/aircraftConstants":303,"../utilities/unitConverters":391,"./circle":348,"./core":349,"./vector":352}],352:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildPolyPositionModels = buildPolyPositionModels;
exports.positive_intersection_with_rect = exports.point_in_area = exports.area_to_poly = exports.point_to_mpoly = exports.point_in_poly = exports.distance_to_poly = exports.raysIntersect = exports.vturn = exports.vscale = exports.vadd = exports.vectorize2dFromDegrees = exports.vectorize2dFromRadians = exports.vnorm = exports.vsub = exports.vradial = exports.vlen = void 0;

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _core = require("./core");

var _circle = require("./circle");

var _unitConverters = require("../utilities/unitConverters");

var _StaticPositionModel = _interopRequireDefault(require("../base/StaticPositionModel"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/**
 * Computes length of 2D vector
 *
 * @function vlen
 */
var vlen = function vlen(v) {
  try {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  } catch (err) {
    console.error("call to vlen() failed. v:".concat(v, " | Err:").concat(err));
  }
};
/**
 * Compute angle of 2D vector, in radians
 *
 * @function vradial
 * @param v {}
 * @return {number}
 */


exports.vlen = vlen;

var vradial = function vradial(v) {
  return Math.atan2(v[0], v[1]);
};
/**
 * Subtracts Vectors (all dimensions)
 *
 * @fuction vsub
 * @param v1 {number}
 * @param v2 {number}
 * @return {number}
 */


exports.vradial = vradial;

var vsub = function vsub(v1, v2) {
  try {
    var v = [];
    var limit = Math.min(v1.length, v2.length); // TODO: this is easie rwith _map()

    for (var i = 0; i < limit; i++) {
      v.push(v1[i] - v2[i]);
    }

    return v;
  } catch (err) {
    console.error("call to vsub() failed. v1: ".concat(v1, " | v2:").concat(v2, " | Err: ").concat(err));
  }
}; // ************************ VECTOR FUNCTIONS ************************
// For more info, see http://threejs.org/docs/#Reference/Math/Vector3
// Remember: [x,y] convention is used, and doesn't match [lat,lon]

/**
 * Normalize a 2D vector
 * eg scaling elements such that net length is 1
 * Turns vector 'v' into a 'unit vector'
 */


exports.vsub = vsub;

var vnorm = function vnorm(v, length) {
  var x = v[0];
  var y = v[1];
  var angle = Math.atan2(x, y);

  if (!length) {
    length = 1;
  }

  return [(0, _core.sin)(angle) * length, (0, _core.cos)(angle) * length];
};
/**
 * Get a 2D unit vector corresponding to a heading in radians
 *
 * @param  heading_angle    float    the heading angle, in radians
 * @return array    an array of the x and y components of the vector
 */


exports.vnorm = vnorm;

var vectorize2dFromRadians = function vectorize2dFromRadians(heading_angle) {
  // normalize the angle beetween 0 and 2*PI
  heading_angle = (0, _circle.radians_normalize)(heading_angle);
  return [(0, _core.sin)(heading_angle), (0, _core.cos)(heading_angle)];
};
/**
 * Get a 2D unit vector corresponding to a heading in degrees
 *
 * @param  heading_angle    float    the heading angle, in degrees
 * @return array    an array of the x and y components of the vector
 */


exports.vectorize2dFromRadians = vectorize2dFromRadians;

var vectorize2dFromDegrees = function vectorize2dFromDegrees(heading_angle) {
  return vectorize2dFromRadians((0, _unitConverters.degreesToRadians)(heading_angle));
};
/**
 * Adds Vectors (all dimensions)
 */


exports.vectorize2dFromDegrees = vectorize2dFromDegrees;

var vadd = function vadd(v1, v2) {
  // TODO: why try/catch?
  try {
    var v = [];
    var limit = Math.min(v1.length, v2.length); // TODO: this can be done with a _map()

    for (var i = 0; i < limit; i++) {
      v.push(v1[i] + v2[i]);
    }

    return v;
  } catch (err) {
    console.error("call to vadd() failed. v1:".concat(v1, " | v2:").concat(v2, " | Err:").concat(err));
  }
};
/**
 * Multiplies Vectors (all dimensions)
 */
// const vmul = (v1, v2) => {
//     // TODO: why try/catch?
//     try {
//         const v = [];
//         const limit = Math.min(v1.length, v2.length);
//
//         // TODO: this can be done with a _map()
//         for (let i = 0; i < limit; i++) {
//             v.push(v1[i] * v2[i]);
//         }
//
//         return v;
//     } catch (err) {
//         console.error(`call to vmul() failed. v1:${v1} | v2:${v2} | Err:${err}`);
//     }
// };

/**
 * Divides Vectors (all dimensions)
 */
// const vdiv = (v1, v2) => {
//     // TODO: why try/catch?
//     try {
//         const v = [];
//         const lim = Math.min(v1.length, v2.length);
//
//         // TODO: this can be done with a _map()
//         for (let i = 0; i < lim; i++) {
//             v.push(v1[i] / v2[i]);
//         }
//
//         return v;
//     } catch (err) {
//         console.error(`call to vdiv() failed. v1:${v1} | v2:${v2} | Err:${err}`);
//     }
// };

/**
 * Scales vectors in magnitude (all dimensions)
 */


exports.vadd = vadd;

var vscale = function vscale(vectors, factor) {
  return (0, _map2["default"])(vectors, function (v) {
    return v * factor;
  });
};
/**
 * Vector dot product (all dimensions)
 */
// const vdp = (v1, v2) => {
//     let n = 0;
//     const lim = Math.min(v1.length, v2.length);
//
//     // TODO: mabye use _map() here?
//     for (let i = 0; i < lim; i++) {
//         n += v1[i] * v2[i];
//     }
//
//     return n;
// };

/**
 * Compute determinant of 2D/3D vectors
 * Remember: May return negative values (undesirable in some situations)
 */


exports.vscale = vscale;

var vdet = function vdet(v1, v2,
/* optional */
v3) {
  if (Math.min(v1.length, v2.length) === 2) {
    // 2x2 determinant
    return v1[0] * v2[1] - v1[1] * v2[0];
  } else if (Math.min(v1.length, v2.length, v3.length) === 3 && v3) {
    // 3x3 determinant
    return v1[0] * vdet([v2[1], v2[2]], [v3[1], v3[2]]) - v1[1] * vdet([v2[0], v2[2]], [v3[0], v3[2]]) + v1[2] * vdet([v2[0], v2[1]], [v3[0], v3[1]]);
  }
};
/**
 * Vector cross product (3D/2D*)
 * Passing 3D vector returns 3D vector
 * Passing 2D vector (classically improper) returns z-axis SCALAR
 * *Note on 2D implementation: http://stackoverflow.com/a/243984/5774767
 */


var vcp = function vcp(v1, v2) {
  if (Math.min(v1.length, v2.length) === 2) {
    // for 2D vector (returns z-axis scalar)
    return vcp([v1[0], v1[1], 0], [v2[0], v2[1], 0])[2];
  }

  if (Math.min(v1.length, v2.length) === 3) {
    // for 3D vector (returns 3D vector)
    return [vdet([v1[1], v1[2]], [v2[1], v2[2]]), -vdet([v1[0], v1[2]], [v2[0], v2[2]]), vdet([v1[0], v1[1]], [v2[0], v2[1]])];
  }
};
/**
 * Returns vector rotated by "radians" radians
 */


var vturn = function vturn(radians, v) {
  if (!v) {
    v = [0, 1];
  }

  var x = v[0];
  var y = v[1];
  var cs = (0, _core.cos)(-radians);
  var sn = (0, _core.sin)(-radians);
  return [x * cs - y * sn, x * sn + y * cs];
};
/**
 * Determines if and where two rays will intersect. All angles in radians.
 * Variation based on http://stackoverflow.com/a/565282/5774767
 */


exports.vturn = vturn;

var raysIntersect = function raysIntersect(pos1, dir1, pos2, dir2, deg_allowance) {
  if (!deg_allowance) {
    // degrees divergence still considered 'parallel'
    deg_allowance = 0;
  }

  var p = pos1;
  var q = pos2;
  var r = vectorize2dFromRadians(dir1);
  var s = vectorize2dFromRadians(dir2);
  var t = (0, _core.abs)(vcp(vsub(q, p), s) / vcp(r, s));
  var t_norm = (0, _core.abs)(vcp(vsub(vnorm(q), vnorm(p)), s) / vcp(r, s));
  var u_norm = (0, _core.abs)(vcp(vsub(vnorm(q), vnorm(p)), r) / vcp(r, s));

  if ((0, _core.abs)(vcp(r, s)) < (0, _core.abs)(vcp([0, 1], vectorize2dFromRadians((0, _unitConverters.degreesToRadians)(deg_allowance))))) {
    // parallel (within allowance)
    var crossProduct = vcp(vsub(vnorm(q), vnorm(p)), r);

    if (crossProduct === 0) {
      // collinear
      return true;
    } // parallel, non-intersecting


    return false;
  } else if (t_norm >= 0 && t_norm <= 1 && u_norm >= 0 && u_norm <= 1) {
    // rays intersect here
    return vadd(p, vscale(r, t));
  } // diverging, non-intersecting


  return false;
};
/**
 * 'Flips' vector's Y component in direction
 * Helper function for culebron's poly edge vector functions
 */


exports.raysIntersect = raysIntersect;

var vflipY = function vflipY(v) {
  return [-v[1], v[0]];
};
/**
 *
 *
 * solution by @culebron
 * turn poly edge into a vector.
 * the edge vector scaled by j and its normal vector scaled by i meet
 * if the edge vector points between the vertices,
 * then normal is the shortest distance.
 * --------
 * x1 + x2 * i == x3 + x4 * j
 * y1 + y2 * i == y3 + y4 * j
 * 0 < j < 1
 * --------
 *
 * i == (y3 + j y4 - y1) / y2
 * x1 + x2 y3 / y2 + j x2 y4 / y2 - x2 y1 / y2 == x3 + j x4
 * j x2 y4 / y2 - j x4 == x3 - x1 - x2 y3 / y2 + x2 y1 / y2
 * j = (x3 - x1 - x2 y3 / y2 + x2 y1 / y2) / (x2 y4 / y2 - x4)
 * i = (y3 + j y4 - y1) / y2
 *
 * i == (x3 + j x4 - x1) / x2
 * y1 + y2 x3 / x2 + j y2 x4 / x2 - y2 x1 / x2 == y3 + j y4
 * j y2 x4 / x2 - j y4 == y3 - y1 - y2 x3 / x2 + y2 x1 / x2
 * j = (y3 - y1 - y2 x3 / x2 + y2 x1 / x2) / (y2 x4 / x2 - y4)
 * i = (x3 + j x4 - x1) / x2
 *
 * @fnuction distance_to_poly
 * @param point {array}
 * @param poly {array}
 * @return number
 */


var distance_to_poly = function distance_to_poly(point, poly) {
  var dists = (0, _map2["default"])(poly, function (vertex1, i) {
    var prev = (i === 0 ? poly.length : i) - 1;
    var vertex2 = poly[prev];
    var edge = vsub(vertex2, vertex1);

    if (vlen(edge) === 0) {
      return vlen(vsub(point, vertex1));
    } // point + normal * i == vertex1 + edge * j


    var norm = vflipY(edge);
    var x1 = point[0];
    var x2 = norm[0];
    var x3 = vertex1[0];
    var x4 = edge[0];
    var y1 = point[1];
    var y2 = norm[1];
    var y3 = vertex1[1];
    var y4 = edge[1];
    var k;
    var j;

    if (y2 !== 0) {
      j = (x3 - x1 - x2 * y3 / y2 + x2 * y1 / y2) / (x2 * y4 / y2 - x4);
      k = (y3 + j * y4 - y1) / y2;
    } else if (x2 !== 0) {
      // normal can't be zero unless the edge has 0 length
      j = (y3 - y1 - y2 * x3 / x2 + y2 * x1 / x2) / (y2 * x4 / x2 - y4);
      k = (x3 + j * x4 - x1) / x2;
    }

    if (j < 0 || j > 1 || !j) {
      return Math.min(vlen(vsub(point, vertex1)), vlen(vsub(point, vertex2)));
    }

    return vlen(vscale(norm, k));
  });
  return Math.min.apply(Math, _toConsumableArray(dists));
}; // source: https://github.com/substack/point-in-polygon/


exports.distance_to_poly = distance_to_poly;

var point_in_poly = function point_in_poly(point, vs) {
  // ray-casting algorithm based on
  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
  var x = point[0];
  var y = point[1];
  var j = vs.length - 1;
  var inside = false; // poly might not be the correct term here

  (0, _forEach2["default"])(vs, function (poly, i) {
    var xi = poly[0];
    var yi = poly[1];
    var xj = vs[j][0];
    var yj = vs[j][1];
    var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;

    if (intersect) {
      inside = !inside;
    }

    j = i;
  });
  return inside;
};
/**
 *
 * @function point_to_mpoly
 * @param point {array}
 * @param mpoly {array}
 * @return {object}
 */


exports.point_in_poly = point_in_poly;

var point_to_mpoly = function point_to_mpoly(point, mpoly) {
  // returns: boolean inside/outside & distance to the polygon
  var inside = false;
  (0, _forEach2["default"])(mpoly, function (ring, k) {
    // ring = mpoly[k];
    if (point_in_poly(point, ring)) {
      if (k === 0) {
        // if inside outer ring, remember that and wait till the end
        inside = true;
      } // if by change in one of inner rings, it's out of poly, return distance to the inner ring


      return {
        inside: false,
        distance: distance_to_poly(point, ring)
      };
    }
  }); // if not matched to inner circles, return the match to outer and distance to it

  return {
    inside: inside,
    distance: distance_to_poly(point, mpoly[0])
  };
};
/**
 * Converts an 'area' to a 'poly'
 *
 * @param area {array<array>}  The #perimeter property of an `AirspaceModel`
 */


exports.point_to_mpoly = point_to_mpoly;

var area_to_poly = function area_to_poly(area) {
  return (0, _map2["default"])(area.poly, function (v) {
    return v.relativePosition;
  });
};
/**
 * Checks to see if a point is in an area
 */


exports.area_to_poly = area_to_poly;

var point_in_area = function point_in_area(point, area) {
  return point_in_poly(point, area_to_poly(area));
}; // TODO: this might be best accomplished with a Rectangle class, with this function working as the middleman
// creating the class and asking if there is an intersection.

/**
 * Compute a point of intersection of a ray with a rectangle.
 *
 * Args:
 *   pos: array of 2 numbers, representing ray source.
 *   dir: array of 2 numbers, representing ray direction.
 *   rectPos: array of 2 numbers, representing rectangle corner position.
 *   rectSize: array of 2 positive numbers, representing size of the rectangle.
 *
 * Returns:
 * - undefined, if pos is outside of the rectangle.
 * - undefined, in case of a numerical error.
 * - array of 2 numbers on a rectangle boundary, in case of an intersection.
 */


exports.point_in_area = point_in_area;

var positive_intersection_with_rect = function positive_intersection_with_rect(pos, dir, rectPos, rectSize) {
  var left = rectPos[0];
  var right = rectPos[0] + rectSize[0];
  var top = rectPos[1];
  var bottom = rectPos[1] + rectSize[1];
  var t;
  var x;
  var y;
  dir = vnorm(dir); // Check if pos is outside of rectangle.

  if ((0, _core.clamp)(left, pos[0], right) !== pos[0] || (0, _core.clamp)(top, pos[1], bottom) !== pos[1]) {
    return undefined;
  } // Check intersection with top segment.


  if (dir[1] < 0) {
    t = (top - pos[1]) / dir[1];
    x = pos[0] + dir[0] * t;

    if ((0, _core.clamp)(left, x, right) === x) {
      return [x, top];
    }
  } // Check intersection with bottom segment.


  if (dir[1] > 0) {
    t = (bottom - pos[1]) / dir[1];
    x = pos[0] + dir[0] * t;

    if ((0, _core.clamp)(left, x, right) === x) {
      return [x, bottom];
    }
  } // Check intersection with left segment.


  if (dir[0] < 0) {
    t = (left - pos[0]) / dir[0];
    y = pos[1] + dir[1] * t;

    if ((0, _core.clamp)(top, y, bottom) === y) {
      return [left, y];
    }
  } // Check intersection with right segment.


  if (dir[0] > 0) {
    t = (right - pos[0]) / dir[0];
    y = pos[1] + dir[1] * t;

    if ((0, _core.clamp)(top, y, bottom) === y) {
      return [right, y];
    }
  } // Failed to compute intersection due to numerical precision.


  return undefined;
};
/**
 * Create a StaticPositionModel for each poly
 *
 * If the last entry is the same as the first, remove it because the path will be closed automatically.
 *
 * @method buildPolyPositionModels
 * @param polyList {array}
 * @param airportPosition {StaticPositionModel}
 * @param magneticNorth {number}
 * @return polyPositionModels {array}
 */


exports.positive_intersection_with_rect = positive_intersection_with_rect;

function buildPolyPositionModels(polyList, airportPosition, magneticNorth) {
  var polyPositionModels = (0, _map2["default"])(polyList, function (poly) {
    return new _StaticPositionModel["default"](poly, airportPosition, magneticNorth);
  }); // TODO: Though its reusability is not real likely, this might as well be made into an external helper
  // shape shouldn't fully close; will draw with 'cc.closepath()' so we remove the last item

  var firstIndex = 0;
  var lastIndex = polyPositionModels.length - 1;
  var firstIndexRelativePosition = polyPositionModels[firstIndex].relativePosition;
  var lastIndexRelativePosition = polyPositionModels[lastIndex].relativePosition;

  if ((0, _isEqual2["default"])(firstIndexRelativePosition, lastIndexRelativePosition)) {
    polyPositionModels.pop();
  }

  return polyPositionModels;
}

},{"../base/StaticPositionModel":297,"../utilities/unitConverters":391,"./circle":348,"./core":349,"lodash/forEach":199,"lodash/isEqual":214,"lodash/map":231}],353:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _circle = require("../math/circle");

var _flightMath = require("../math/flightMath");

var _distance = require("../math/distance");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Describes a single leg of a path being measured, used by the
 * `MeasureTool` to draw the path on the `CanvasController`
 *
 * These form a doubly linked list, that allows each leg to reference
 * the `#previous` and `#next` legs.
 */
var MeasureLegModel =
/*#__PURE__*/
function () {
  /**
   * @for MeasureLeg
   * @constructor
   * @param endPoint {array<number>}
   * @param previousLeg {MeasureLegModel|null}
   */
  function MeasureLegModel(endPoint) {
    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var previousLeg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, MeasureLegModel);

    /**
     * The bearing along the leg (in radians)
     *
     * @for MeasureLegModel
     * @property _bearing
     * @type {number}
     * @default null
     * @private
     */
    this._bearing = null;
    /**
     * The end point of the leg
     *
     * @for MeasureLegModel
     * @property endPoint
     * @type {array<number>}
     * @default endPoint
     */

    this.endPoint = endPoint;
    /**
     * The length of the leg (in km)
     *
     * @for MeasureLegModel
     * @property _distance
     * @type {number}
     * @default null
     * @private
     */

    this._distance = null;
    /**
     * The list of text labels to be displayed
     *
     * @for MeasureLegModel
     * @property labels
     * @type {labels}
     * @default null;
     */

    this.labels = null;
    /**
     * The end point of the leg
     *
     * @for MeasureLegModel
     * @property _midPoint
     * @type {array<number>|null}
     * @default null
     * @private
     */

    this._midPoint = null;
    /**
     * The midpoint of this leg
     *
     * @for MeasureLegModel
     * @property _next
     * @type {MeasureLegModel}
     * @default null;
     * @private
     */

    this._next = null;
    /**
     * The previous leg
     *
     * @for MeasureLegModel
     * @property _previous
     * @type {MeasureLegModel}
     * @default previousLeg
     * @private
     */

    this._previous = previousLeg;
    /**
     * The turn radius (in km)
     *
     * @for MeasureLegModel
     * @property _radius
     * @type {number}
     * @default radius
     * @private
     */

    this._radius = radius;

    this._init(previousLeg);
  }
  /**
   * The bearing along the leg (in radians)
   *
   * @for MeasureLegModel
   * @property bearing
   * @type {number}
   */


  _createClass(MeasureLegModel, [{
    key: "_init",
    // ------------------------------ LIFECYCLE ------------------------------

    /**
     * @for MeasureLegModel
     * @method _init
     * @param previousLeg {MeasureLegModel|null}
     * @private
     */
    value: function _init(previousLeg) {
      if (previousLeg !== null) {
        previousLeg._next = this;

        this._calculateLegParameters();
      }
    } // ------------------------------ PUBLIC ------------------------------
    // ------------------------------ PRIVATE ------------------------------

    /**
     * Calculates the metrics of the leg, `#_midPoint`, `#_distance`, `#_bearing`
     *
     * @for MeasureLegTool
     * @method _calculateLegParameters
     * @private
     */

  }, {
    key: "_calculateLegParameters",
    value: function _calculateLegParameters() {
      var start = this.startPoint;
      var end = this.endPoint;
      this._midPoint = [(start[0] + end[0]) / 2, (start[1] + end[1]) / 2];
      this._bearing = (0, _flightMath.bearingToPoint)(start, end);
      this._distance = (0, _distance.distance2d)(start, end);
    }
    /**
     * Returns a flag that indicates whether the radius is valid for this leg
     *
     * The arcTo command gives strange results when the relative radius is too large
     *
     * @for MeasureLegMode
     * @method _hasValidRadius
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_hasValidRadius",
    value: function _hasValidRadius() {
      var nextLeg = this.next;

      if (nextLeg === null) {
        return false;
      } // Test if the angle required to fillet the corner (ensuring the fillet
      // doesn't extend pass the midpoint of the shortest line) is smaller
      // than the angle between the two lines


      var a1 = this.bearing;
      var a2 = this.next.bearing + Math.PI;
      var halfLength = Math.min(this.distance, nextLeg.distance) / 2;
      var angularDifference = Math.abs((0, _circle.angle_offset)(a1, a2));
      var filletAngle = 2 * Math.atan2(this._radius, halfLength);
      return angularDifference >= filletAngle;
    }
  }, {
    key: "bearing",
    get: function get() {
      return this._bearing;
    }
    /**
     * The length of the leg (in km)
     *
     * @for MeasureLegModel
     * @property distance
     * @type {number}
     */

  }, {
    key: "distance",
    get: function get() {
      return this._distance;
    }
    /**
     * The midpoint of this leg
     *
     * @for MeasureLegModel
     * @property midPoint
     * @type {array<number>|null}
     */

  }, {
    key: "midPoint",
    get: function get() {
      return this._midPoint;
    }
    /**
     * The next leg
     *
     * @for MeasureLegModel
     * @property next
     * @type {MeasureLegModel}
     */

  }, {
    key: "next",
    get: function get() {
      return this._next;
    }
    /**
     * The previous leg
     *
     * @for MeasureLegModel
     * @property next
     * @type {MeasureLegModel}
     */

  }, {
    key: "previous",
    get: function get() {
      return this._previous;
    }
    /**
     * The turn radius (in km)
     *
     * @for MeasureLegModel
     * @property radius
     * @type {number}
     */

  }, {
    key: "radius",
    get: function get() {
      var radius = this._radius; // No point in validating if the radius is empty

      if (radius === 0) {
        return radius;
      }

      return this._hasValidRadius() ? radius : 0;
    }
    /**
     * The start point of this leg
     *
     * @for MeasureLegModel
     * @property startPoint
     * @type {array<number>|null}
     */

  }, {
    key: "startPoint",
    get: function get() {
      return this._previous === null ? null : this._previous.endPoint;
    }
  }]);

  return MeasureLegModel;
}();

exports["default"] = MeasureLegModel;

},{"../math/circle":348,"../math/distance":350,"../math/flightMath":351}],354:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _round2 = _interopRequireDefault(require("lodash/round"));

var _circle = require("../math/circle");

var _flightMath = require("../math/flightMath");

var _distance = require("../math/distance");

var _unitConverters = require("../utilities/unitConverters");

var _MeasureLegModel = _interopRequireDefault(require("./MeasureLegModel"));

var _AircraftModel = _interopRequireDefault(require("../aircraft/AircraftModel"));

var _FixModel = _interopRequireDefault(require("../navigationLibrary/FixModel"));

var _inputConstants = require("../constants/inputConstants");

var _globalConstants = require("../constants/globalConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Defines a `MeasurePath`
 *
 * The `MeasurePath` is used by the `MeasureTool` to keep
 * track of the points in a path being meaured and to
 * generate a path to be drawn by the `CanvasController`
 *
 * A `MeasurePath` is designed to only be used internally
 * by the `MeasureTool`
 */
var MeasurePath =
/*#__PURE__*/
function () {
  /**
   * @for MeasurePath
   * @constructor
   * @param startPoint {AircraftModel|FixModel|array<number>}
   * @param style {MEASURE_TOOL_STYLE}
   */
  function MeasurePath(style) {
    _classCallCheck(this, MeasurePath);

    /**
     * The list of points that make up the path being measured
     * This can be an object with a `#relativePosition` property,
     * or a array of numbers that represent a `relativePosition`
     *
     * @for MeasurePath
     * @property _points
     * @type {AircraftModel|FixModel|array<number>}
     * @default []
     * @private
     */
    this._points = [];
    /**
     * The style of how the path is rendered
     *
     * @for MeasurePath
     * @property style
     * @type {MEASURE_TOOL_STYLE}
     * @default null;
     * @private
     */

    this._style = style;

    this._init();
  }
  /** Gets the aircraft at the beginning of the path
   *
   * @for MeasurePath
   * @property aircraft
   * @type {AircraftModel|null}
   */


  _createClass(MeasurePath, [{
    key: "_init",
    // ------------------------------ LIFECYCLE ------------------------------

    /**
     * @for MeasurePath
     * @method _init
     * @private
     */
    value: function _init() {} // ------------------------------ PUBLIC ------------------------------

    /**
     * Adds a point to the path being measured
     *
     * The value can be an object with a `#relativePosition` property,
     * or a array of numbers that represent a `relativePosition`
     *
     * @for MeasurePath
     * @method addPoint
     * @param value {AircraftModel|FixModel|array<number>}
     */

  }, {
    key: "addPoint",
    value: function addPoint(value) {
      this._throwIfPointInvalid(value);

      this._points.push(value);
    }
    /**
     * Gets the information for the path that should be drawn on the `CanvasController`
     *
     * @for MeasurePath
     * @method buildPathInfo
     * @returns {object}
     */

  }, {
    key: "buildPathInfo",
    value: function buildPathInfo() {
      var _this = this;

      if (!this.hasLegs) {
        return null;
      } // Ground speed is only known if the first point is an AircraftModel


      var aircraft = this.aircraft;
      var groundSpeed = aircraft === null ? null : aircraft.groundSpeed;

      var initialTurn = this._buildInitialTurnParameters();

      var pointsList = _toConsumableArray(this._points); // Shallow copy as the first point may be replaced


      var radius = 0;

      if (initialTurn !== null && this.hasStyleArced) {
        radius = initialTurn.turnRadius;
      } // These are the values used when reducing the points array


      var initialValues = {
        previousLeg: null,
        totalDistance: 0,
        totalDuration: 0
      }; // If there is an initialTurn (eg. a turn onto the first leg), then the exit point is used
      // as the first point in the path

      if (initialTurn !== null) {
        var exitPoint = initialTurn.exitPoint;
        initialValues.lastPoint = exitPoint;
        pointsList[0] = exitPoint;
      } // The initial leg is just an end point


      var firstPoint = this._getRelativePosition(pointsList.shift());

      var initialLeg = new _MeasureLegModel["default"](firstPoint);
      initialValues.previousLeg = initialLeg;
      pointsList.reduce(function (lastValues, point, index) {
        var previousLeg = lastValues.previousLeg;
        var totalDistance = lastValues.totalDistance,
            totalDuration = lastValues.totalDuration;
        var leg = new _MeasureLegModel["default"](_this._getRelativePosition(point), radius, previousLeg);
        var bearing = (0, _unitConverters.heading_to_string)(leg.bearing);
        var distance = (0, _unitConverters.nm)(leg.distance);
        var duration = 0; // If there's an initial turn, include the length of that in the first leg

        if (index === 0 && initialTurn !== null) {
          distance += (0, _unitConverters.nm)(initialTurn.arcLength);
        }

        if (groundSpeed !== null) {
          duration = (0, _round2["default"])(distance / groundSpeed * _globalConstants.TIME.ONE_HOUR_IN_MINUTES, 1);
        } // We only want labels that have a distance


        if (distance > 1) {
          var labels = [_this._buildLabel(distance, duration, bearing)];
          totalDistance += distance;
          totalDuration = (0, _round2["default"])(totalDuration + duration, 1);

          if (totalDistance !== distance) {
            labels.push(_this._buildLabel(totalDistance, totalDuration));
          }

          leg.labels = labels;
        }

        return {
          previousLeg: leg,
          totalDistance: totalDistance,
          totalDuration: totalDuration
        };
      }, initialValues);
      return {
        initialTurn: initialTurn,
        firstLeg: initialLeg.next
      };
    }
    /**
     * Removes the last point from the path
     * Note: This "last" point is the one that follows the cursor position
     *
     * @for MeasurePath
     * @method removeLastPoint
     */

  }, {
    key: "removeLastPoint",
    value: function removeLastPoint() {
      this._points.pop();
    }
    /**
     * Removes the second-to-last point from the path
     *
     * @for MeasurePath
     * @method removePreviousPoint
     */

  }, {
    key: "removePreviousPoint",
    value: function removePreviousPoint() {
      // The "last" point is actually the 2nd last item in _points
      // This means the path will end at the cursor position when redrawn
      var length = this._points.length;

      if (length > 2) {
        this._points.splice(length - 2, 1);
      }
    }
    /**
     * Sets the style that should be used for path generation and rendering
     *
     * If an invalid valid for MEASURE_TOOL_STYLE is passed, it will default to
     * `MEASURE_TOOL_STYLE.STRAIGHT`
     *
     * @for MeasurePath
     * @method setStyle
     * @param style {MEASURE_TOOL_STYLE}
     */

  }, {
    key: "setStyle",
    value: function setStyle(style) {
      this._style = style;
    }
    /**
     * Updates the last point in the path
     *
     * The value can be an object with a `#relativePosition` property,
     * or a array of numbers that represent a `relativePosition`
     *
     * @for MeasurePath
     * @method updateEndPoint
     * @param value {AircraftModel|FixModel|array<number>}
     */

  }, {
    key: "updateLastPoint",
    value: function updateLastPoint(value) {
      this._throwIfPointInvalid(value);

      if (!this.hasStarted) {
        return;
      }

      if (!this.hasLegs) {
        this.addPoint(value);
        return;
      }

      this._points[this._points.length - 1] = value;
    } // ------------------------------ PRIVATE ------------------------------

    /**
     * Builds the initial turn parameters that are needed to fly to the first fix
     *
     * @for MeasurePath
     * @method _buildInitialTurnParameters
     * @returns {object}
     * @private
     */

  }, {
    key: "_buildInitialTurnParameters",
    value: function _buildInitialTurnParameters() {
      if (!this.hasStyleInitialTurn) {
        return null;
      }

      var aircraft = this.aircraft;

      if (aircraft === null) {
        return null;
      }

      var groundSpeed = aircraft.groundSpeed,
          groundTrack = aircraft.groundTrack;
      var turnRate = 3; // Turn rate seems fixed at 3°/sec // groundSpeed > 250 ? 1.5 : 3;

      var turnRadius = (0, _unitConverters.km)(groundSpeed / (turnRate * 20 * Math.PI));
      var start = aircraft.relativePosition;

      var fix = this._getRelativePositionAtIndex(1); // Get the turn direction by using the basic bearing to the next point


      var bearingToFix = (0, _flightMath.bearingToPoint)(start, fix);
      var isRHT = (0, _circle.radians_normalize)(bearingToFix - groundTrack) < Math.PI;
      var direction = isRHT ? 1 : -1; // The centre of the turn circle is offset to the left or right by 90°

      var bearingToCenter = groundTrack + direction * Math.PI / 2;
      var center = [start[0] + turnRadius * Math.sin(bearingToCenter), start[1] + turnRadius * Math.cos(bearingToCenter)]; // Turn exit (tangent from turn circle to the fix)

      var centerToFixBearing = (0, _flightMath.bearingToPoint)(center, fix);
      var centerToFixDistance = (0, _distance.distance2d)(center, fix);
      var outboundCourse = centerToFixBearing + direction * Math.asin(turnRadius / centerToFixDistance); // Entry and exit angles

      var entryAngle = bearingToCenter + Math.PI;
      var exitAngle = outboundCourse - direction * Math.PI / 2; // The exit point is the point on the turn circle at the exit angle

      var exitPoint = [center[0] + turnRadius * Math.sin(exitAngle), center[1] + turnRadius * Math.cos(exitAngle)]; // Length around the arc

      var turnAngle;

      if (isRHT) {
        turnAngle = exitAngle - entryAngle;
      } else {
        turnAngle = entryAngle - exitAngle;
      }

      var arcLength = turnRadius * (0, _circle.radians_normalize)(turnAngle);
      return {
        isRHT: isRHT,
        turnRadius: turnRadius,
        arcLength: arcLength,
        entryAngle: entryAngle,
        exitAngle: exitAngle,
        center: center,
        exitPoint: exitPoint
      };
    }
    /**
     * Builds the text label that displays the distance and
     * optional duration and bearings
     *
     * @for MeasurePath
     * @method _buildLabel
     * @param distance {number} The distance (in NM) that the leg covers
     * @param duration {number} The length of time (in minutes) that flying the leg will take
     * @param bearing {number|null} The bearing (degrees magnetic) along the leg
     * @private
     */

  }, {
    key: "_buildLabel",
    value: function _buildLabel(distance, duration) {
      var bearing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var label = "".concat(distance.toPrecision(3), " NM");

      if (duration !== 0) {
        label += ", ".concat(duration.toFixed(1), " min");
      }

      if (bearing !== null) {
        label += ", ".concat(bearing, "\xB0 M");
      }

      return label;
    }
    /**
     * Gets the relative position for the point at the specified index.
     *
     * @for MeasurePath
     * @method _getRelativePositionAtIndex
     * @param index {number}
     * @returns {array<number>}
     */

  }, {
    key: "_getRelativePositionAtIndex",
    value: function _getRelativePositionAtIndex(index) {
      var point = this._points[index];
      return this._getRelativePosition(point);
    }
    /**
     * Gets the relative position for the point at the specified index.
     *
     * @for MeasurePath
     * @method _getRelativePosition
     * @param point {AircraftModel|FixModel|array<number>}
     * @returns {array<number>}
     */

  }, {
    key: "_getRelativePosition",
    value: function _getRelativePosition(point) {
      return point.relativePosition || point;
    }
    /**
     * Facade for throwing a TypeError if a point value is not a valid type
     *
     * @for MeasurePath
     * @method _throwIfPointInvalid
     * @param value {AircraftModel|FixModel|array<number>}
    */

  }, {
    key: "_throwIfPointInvalid",
    value: function _throwIfPointInvalid(value) {
      if (!(value instanceof Array || value instanceof _AircraftModel["default"] || value instanceof _FixModel["default"])) {
        throw new TypeError("value cannot be ".concat(_typeof(value), ". An Array, AircraftModel or FixModel is expected."));
      }
    }
  }, {
    key: "aircraft",
    get: function get() {
      if (!this.hasStarted || !(this._points[0] instanceof _AircraftModel["default"])) {
        return null;
      }

      return this._points[0];
    }
    /**
     * Indicates whether there are any valid legs
     *
     * @for MeasurePath
     * @property hasLegs
     * @type {boolean}
     */

  }, {
    key: "hasLegs",
    get: function get() {
      return this._points.length > 1;
    }
    /**
     * Indicates the `MeasurePath` has started measuring
     * eg. the path has at least one point
     *
     * @for MeasurePath
     * @property hasLegs
     * @type {boolean}
     */

  }, {
    key: "hasStarted",
    get: function get() {
      return this._points.length !== 0;
    }
    /**
     * Gets a flag indicating whether the '#style' indicates that
     * the initial turn should be used when building the path
     *
     * @for MeasurePath
     * @property hasStyleInitialTurn
     * @returns {boolean}
     */

  }, {
    key: "hasStyleInitialTurn",
    get: function get() {
      return this._style === _inputConstants.MEASURE_TOOL_STYLE.ARC_TO_NEXT || this._style === _inputConstants.MEASURE_TOOL_STYLE.ALL_ARCED;
    }
    /**
     * Gets a flag indicating whether the '#style' indicates that
     * the arcs should be used when building the path
     *
     * @for MeasurePath
     * @property hasStyleArced
     * @returns {boolean}
     */

  }, {
    key: "hasStyleArced",
    get: function get() {
      return this._style === _inputConstants.MEASURE_TOOL_STYLE.ALL_ARCED;
    }
  }]);

  return MeasurePath;
}();

exports["default"] = MeasurePath;

},{"../aircraft/AircraftModel":265,"../constants/globalConstants":310,"../constants/inputConstants":311,"../math/circle":348,"../math/distance":350,"../math/flightMath":351,"../navigationLibrary/FixModel":358,"../utilities/unitConverters":391,"./MeasureLegModel":353,"lodash/round":239}],355:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _MeasurePath = _interopRequireDefault(require("./MeasurePath"));

var _GameController = _interopRequireDefault(require("../game/GameController"));

var _eventNames = require("../constants/eventNames");

var _inputConstants = require("../constants/inputConstants");

var _gameOptionConstants = require("../constants/gameOptionConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Defines a `MeasureTool`
 *
 * The `MeasureTool` is used by the `InputController` to
 * accept user input and build a list of `MeasurePath`s
 * which calculate distances, durations and bearings
 */
var MeasureTool =
/*#__PURE__*/
function () {
  /**
   * @for MeasureLeg
   * @constructor
   */
  function MeasureTool() {
    _classCallCheck(this, MeasureTool);

    /**
     * The current path being measured
     *
     * @for MeasureTool
     * @property _currentPath
     * @type {MeasurePath}
     * @default null
     * @private
     */
    this._currentPath = null;
    /**
     * @for MeasureTool
     * @property _eventBus
     * @type {EventBus}
     * @private
     */

    this._eventBus = _EventBus["default"];
    /**
     * The list of `MeasurePath` objects that the tools is
     * measuring
     *
     * @for MeasureTool
     * @property _paths
     * @type {array<MeasurePath>}
     * @default []
     * @private
     */

    this._paths = [];
    /**
     * The style of how the path is rendered
     *
     * @for MeasureTool
     * @property _style
     * @type {MEASURE_TOOL_STYLE}
     * @default null;
     * @private
     */

    this._style = null;

    this._init()._setupHandlers().enable();
  }
  /**
   * Indicates whether the `MeasureTool` has any paths
   *
   * @for MeasureTool
   * @property hasPaths
   * @type {boolean}
   */


  _createClass(MeasureTool, [{
    key: "_init",
    // ------------------------------ LIFECYCLE ------------------------------

    /**
     * @for MeasureTool
     * @method _init
     * @chainable
     * @private
     */
    value: function _init() {
      this.setStyle(_GameController["default"].getGameOption(_gameOptionConstants.GAME_OPTION_NAMES.MEASURE_TOOL_PATH));
      return this;
    }
    /**
     * @for MeasureTool
     * @method _setupHandlers
     * @chainable
     * @private
     */

  }, {
    key: "_setupHandlers",
    value: function _setupHandlers() {
      this._onMeasureTooltyleChangeHandler = this._onMeasureTooltyleChange.bind(this);
      return this;
    }
    /**
     * @for MeasureTool
     * @method disable
     * @chainable
     */

  }, {
    key: "disable",
    value: function disable() {
      this._eventBus.off(_eventNames.EVENT.MEASURE_TOOL_STYLE_CHANGE, this._onMeasureTooltyleChangeHandler);

      return this;
    }
    /**
     * @for MeasureTool
     * @method enable
     * @chainable
     */

  }, {
    key: "enable",
    value: function enable() {
      this._eventBus.on(_eventNames.EVENT.MEASURE_TOOL_STYLE_CHANGE, this._onMeasureTooltyleChangeHandler);

      return this;
    }
    /**
     * @for MeasureTool
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this._paths = [];
      this._currentPath = null;
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Adds a point to the current path being measured
     *
     * The value can be an object with a `#relativePosition` property,
     * or a array of numbers that represent a `relativePosition`
     *
     * @for MeasureTool
     * @method addPoint
     * @param value {AircraftModel|FixModel|array<number>}
     */

  }, {
    key: "addPoint",
    value: function addPoint(value) {
      this._throwIfNotMeasuring();

      this._currentPath.addPoint(value);
    }
    /**
     * Gets the information for the paths that should be drawn on the `CanvasController`
     *
     * @for MeasureTool
     * @method buildPathInfo
     * @returns {array<object>}
     */

  }, {
    key: "buildPathInfo",
    value: function buildPathInfo() {
      return this._paths.reduce(function (list, path) {
        if (path.hasLegs) {
          list.push(path.buildPathInfo());
        }

        return list;
      }, []);
    }
    /**
     * Signals that the editing the current path has finished
     *
     * @for MeasureTool
     * @method endPath
     */

  }, {
    key: "endPath",
    value: function endPath() {
      this._throwIfNotMeasuring(); // Discard the point which is attached to the cursor, and keep
      // only those points which have been clicked into place


      this._currentPath.removeLastPoint(); // If the path isn't valid, then don't keep it


      if (!this._currentPath.hasLegs) {
        this._paths.pop();
      }

      this._currentPath = null;
    }
    /**
     * Removes the second-to-last point from the current path
     *
     * @for MeasureTool
     * @method removePreviousPoint
     */

  }, {
    key: "removePreviousPoint",
    value: function removePreviousPoint() {
      this._throwIfNotMeasuring();

      this._currentPath.removePreviousPoint();
    }
    /**
     * Signals that a new path should be created for measurement
     *
     * @for MeasureTool
     * @method startNewPath
     */

  }, {
    key: "startNewPath",
    value: function startNewPath() {
      if (this.isMeasuring) {
        throw new Error('Cannot start a new path. The current path hasn\'t been ended.');
      }

      var path = new _MeasurePath["default"](this._style);

      this._paths.push(path);

      this._currentPath = path;
    }
    /**
     * Sets the style that should be used for path generation and rendering
     *
     * If an invalid valid for MEASURE_TOOL_STYLE is passed, it will default to
     * `MEASURE_TOOL_STYLE.STRAIGHT`
     *
     * @for MeasureTool
     * @method setStyle
     * @param style {MEASURE_TOOL_STYLE}
     */

  }, {
    key: "setStyle",
    value: function setStyle(style) {
      var isValid = Object.keys(_inputConstants.MEASURE_TOOL_STYLE).some(function (k) {
        return _inputConstants.MEASURE_TOOL_STYLE[k] === style;
      });
      this._style = isValid ? style : _inputConstants.MEASURE_TOOL_STYLE.STRAIGHT;

      this._paths.forEach(function (path) {
        return path.setStyle(style);
      });
    }
    /**
     * Updates the last point in the path
     *
     * The value can be an object with a `#relativePosition` property,
     * or a array of numbers that represent a `relativePosition`
     *
     * @for MeasureTool
     * @method updateEndPoint
     * @param value {AircraftModel|FixModel|array<number>}
     */

  }, {
    key: "updateLastPoint",
    value: function updateLastPoint(value) {
      this._throwIfNotMeasuring();

      this._currentPath.updateLastPoint(value);
    } // ------------------------------ PRIVATE ------------------------------

    /**
     * Update the `#_style` property
     *
     * This method should only be called via the `EventBus`
     *
     * @for MeasureTool
     * @method _onMeasureTooltyleChange
     * @param style {MEASURE_TOOL_STYLE}
     * @private
     */

  }, {
    key: "_onMeasureTooltyleChange",
    value: function _onMeasureTooltyleChange(style) {
      this.setStyle(style);
    }
    /**
     * Facade for throwing an Error if the `#isMeasuring` flag is not set
     *
     * @for MeasureTool
     * @method _throwIfNotMeasuring
     */

  }, {
    key: "_throwIfNotMeasuring",
    value: function _throwIfNotMeasuring() {
      if (!this.isMeasuring) {
        throw Error("Cannot add point when MeasureTool.isMeasuring is ".concat(this.isMeasuring));
      }
    }
  }, {
    key: "hasPaths",
    get: function get() {
      return this._paths.length !== 0;
    }
    /**
     * Indicates the `MeasureTool`s current path has started measuring
     * eg. the path has at least one point
     *
     * @for MeasureTool
     * @property hasLegs
     * @type {boolean}
     */

  }, {
    key: "hasStarted",
    get: function get() {
      return this.isMeasuring && this._currentPath.hasStarted;
    }
    /**
     * Indicates whether the tool should be receiving input
     *
     * @for MeasureTool
     * @property isMeasuring
     * @type {boolean}
     */

  }, {
    key: "isMeasuring",
    get: function get() {
      return this._currentPath !== null;
    }
  }]);

  return MeasureTool;
}();
/**
 * The static instance of the `MeasureTool` class
 */


var _default = new MeasureTool();

exports["default"] = _default;

},{"../constants/eventNames":308,"../constants/gameOptionConstants":309,"../constants/inputConstants":311,"../game/GameController":339,"../lib/EventBus":346,"./MeasurePath":354}],356:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _NavigationLibrary = _interopRequireDefault(require("./NavigationLibrary"));

var _WaypointModel = _interopRequireDefault(require("../aircraft/FlightManagementSystem/WaypointModel"));

var _globalConstants = require("../constants/globalConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AirwayModel =
/*#__PURE__*/
function () {
  function AirwayModel(icao, fixNames) {
    _classCallCheck(this, AirwayModel);

    if ((0, _isEmpty2["default"])(icao)) {
      throw new TypeError('Expected airway to have a non-empty name, but no airway name was given');
    }

    if ((0, _isEmpty2["default"])(fixNames)) {
      throw new TypeError("Expected a list of fix names for airway \"".concat(icao, "\", but received none"));
    }

    this._fixNameCollection = [];
    this._icao = '';
    this.init(icao, fixNames);
  }
  /**
   * Return the #_fixNameCollection
   *
   * @for AirwayModel
   * @property fixNameCollection
   * @type {array<string>}
   */


  _createClass(AirwayModel, [{
    key: "init",
    // ------------------------------ LIFECYCLE ------------------------------
    value: function init(icao, fixNames) {
      this._fixNameCollection = fixNames;
      this._icao = icao;

      this._verifyFixNamesExistInNavigationLibrary(fixNames);

      return this;
    }
  }, {
    key: "reset",
    value: function reset() {
      this._fixNameCollection = [];
      this._icao = '';
      return this;
    }
  }, {
    key: "_verifyFixNamesExistInNavigationLibrary",
    value: function _verifyFixNamesExistInNavigationLibrary(fixNames) {
      var _this = this;

      (0, _forEach2["default"])(fixNames, function (fixName) {
        if (!_NavigationLibrary["default"].hasFixName(fixName)) {
          throw new TypeError("Expected to find fix \"".concat(fixName, "\" for ") + "airway \"".concat(_this._icao, "\", but it is not a defined fix!"));
        }
      });
    } // ------------------------------ PUBLIC ------------------------------

  }, {
    key: "getWaypointModelsForEntryAndExit",
    value: function getWaypointModelsForEntryAndExit(entryName, exitName) {
      if (entryName === exitName) {
        console.error('Expected use of airway to include at least two fixes');
        return;
      }

      var indexOfEntryFix = this._fixNameCollection.indexOf(entryName);

      var indexOfExitFix = this._fixNameCollection.indexOf(exitName);

      if (indexOfEntryFix === _globalConstants.INVALID_INDEX) {
        console.error("Expected valid entry of \"".concat(this._icao, "\" airway, but received \"").concat(entryName, "\""));
        return;
      }

      if (indexOfExitFix === _globalConstants.INVALID_INDEX) {
        console.error("Expected valid exit of \"".concat(this._icao, "\" airway, but received \"").concat(exitName, "\""));
        return;
      }

      var fixNames = this._getFixNamesFromIndexToIndex(indexOfEntryFix, indexOfExitFix);

      var waypointModels = (0, _map2["default"])(fixNames, function (fixName) {
        return new _WaypointModel["default"](fixName);
      });
      return waypointModels;
    }
    /**
     * Returns whether the specified fix name is on the airway
     *
     * @for AirwayModel
     * @method hasFixName
     * @return {boolean}
     */

  }, {
    key: "hasFixName",
    value: function hasFixName(fixName) {
      return this._fixNameCollection.indexOf(fixName) !== _globalConstants.INVALID_INDEX;
    } // ------------------------------ PRIVATE ------------------------------

  }, {
    key: "_getFixNamesFromIndexToIndex",
    value: function _getFixNamesFromIndexToIndex(startIndex, endIndex) {
      if (startIndex === endIndex) {
        throw new TypeError('Expected use of airway to include at least two fixes');
      }

      var numberOfFixes = Math.abs(endIndex - startIndex) + 1;

      if (endIndex > startIndex) {
        return this._fixNameCollection.slice().splice(startIndex, numberOfFixes);
      }

      return this._fixNameCollection.slice().splice(endIndex, numberOfFixes).reverse();
    }
  }, {
    key: "fixNameCollection",
    get: function get() {
      return this._fixNameCollection;
    }
  }, {
    key: "icao",
    get: function get() {
      return this._icao;
    }
  }]);

  return AirwayModel;
}();

exports["default"] = AirwayModel;

},{"../aircraft/FlightManagementSystem/WaypointModel":271,"../constants/globalConstants":310,"./NavigationLibrary":361,"lodash/forEach":199,"lodash/isEmpty":213,"lodash/map":231}],357:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _find2 = _interopRequireDefault(require("lodash/find"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _BaseCollection2 = _interopRequireDefault(require("../base/BaseCollection"));

var _distance = require("../math/distance");

var _FixModel = _interopRequireDefault(require("./FixModel"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * A collection of all the `FixModel`s defined in an airport json file.
 *
 * This is built as a static class, so there is only ever once instance.
 * We use a static class here because the methods contained herein are needed by several
 * different classes. This provides a single source of truth for all the `FixModel`s
 * belonging to an Airport.
 *
 * @class FixCollection
 * @extends BaseCollection
 */
var FixCollection =
/*#__PURE__*/
function (_BaseCollection) {
  _inherits(FixCollection, _BaseCollection);

  function FixCollection() {
    _classCallCheck(this, FixCollection);

    return _possibleConstructorReturn(this, _getPrototypeOf(FixCollection).apply(this, arguments));
  }

  _createClass(FixCollection, [{
    key: "addItems",

    /**
     * Lifecycle method. Should be run only once on instantiation.
     *
     * @for FixCollection
     * @method addItems
     * @param fixList {object}
     * @param referencePosition {StaticPositionModel}
     */
    value: function addItems(fixList, referencePosition) {
      if (this.length !== 0) {
        // you made it here because an airport has changed.
        // in `AirportModel.init()` this method is called with the fix data for the new airport. We don't want
        // or need to keep the fixes from a previous airport so if `_items` has a length, we need to reset that
        // property before we begin to add fixes for the new airport.
        this.removeItems();
      }

      this._buildFixModelsFromList(fixList, referencePosition);
    }
    /**
     * Destroy the current instance
     *
     * @for FixCollection
     * @method removeItems
     */

  }, {
    key: "removeItems",
    value: function removeItems() {
      this._resetFixModels();

      this._items = [];
    }
    /**
     * Add a `FixModel` to the collection
     *
     * @for FixCollection
     * @method addFixToCollection
     * @param fixToAdd {FixModel}
     */

  }, {
    key: "addFixToCollection",
    value: function addFixToCollection(fixToAdd) {
      if (!(fixToAdd instanceof _FixModel["default"])) {
        throw new TypeError('Expected fixToAdd to be an instance of FixModel');
      }

      this._items.push(fixToAdd);
    }
    /**
     * Find a `FixModel` by `name` if it exists within the collection.
     *
     * @for FixCollection
     * @method findFixByName
     * @param fixName {string}
     * @return {FixModel|null}
     */

  }, {
    key: "findFixByName",
    value: function findFixByName(fixName) {
      if (!fixName) {
        return null;
      }

      var fixModel = (0, _find2["default"])(this._items, {
        name: fixName.toUpperCase()
      }); // if a fix is not found, _find() returns `undefined` so we specifically return null here if a fix is not found

      return fixModel || null;
    }
    /**
     * @for FixCollection
     * @method getFixRelativePosition
     * @param fixName {string}
     * @return {array<number>}
     */

  }, {
    key: "getFixRelativePosition",
    value: function getFixRelativePosition(fixName) {
      var fixModel = this.findFixByName(fixName);

      if (!fixModel) {
        return null;
      }

      return fixModel.relativePosition;
    }
    /**
     * Returns the nearest fix to the specified position
     *
     * @for FixCollection
     * @method getNearestFix
     * @param position {array<number>} These are x, y canvas units (km)
     * @param hiddenFixes {boolean} A flag indicating whether hidden fixes should be used
     */

  }, {
    key: "getNearestFix",
    value: function getNearestFix(position) {
      var hiddenFixes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return this._items.reduce(function (lastResult, fix) {
        var _lastResult = _slicedToArray(lastResult, 2),
            nearest = _lastResult[0],
            distance = _lastResult[1];

        var d = (0, _distance.distance2d)(fix.relativePosition, position);

        if ((fix.isRealFix || hiddenFixes) && d < distance) {
          nearest = fix;
          distance = d;
        }

        return [nearest, distance];
      }, [null, Infinity]);
    }
    /**
     * Return the position model for the specified fix, if that fix exists
     *
     * @for FixCollection
     * @method getPositionModelForFixName
     * @param fixName {string}
     * @return {StaticPositionModel}
     */

  }, {
    key: "getPositionModelForFixName",
    value: function getPositionModelForFixName(fixName) {
      var fixModel = this.findFixByName(fixName);

      if (!fixModel) {
        return null;
      }

      return fixModel.positionModel;
    }
    /**
     * Find a list of all `FixModel`s within the collection that have a name that does not start with an underscore.
     *
     * @for FixCollection
     * @method findRealFixes
     * @return {array<FixModel>}
     */

  }, {
    key: "findRealFixes",
    value: function findRealFixes() {
      return this._items.filter(function (fix) {
        return fix.isRealFix;
      });
    }
    /**
     * Loop through each fix provided in the fix list, create a new `FixModel` instance, then send it off
     * to be added to the collection.
     *
     * @for FixCollection
     * @method _buildFixModelsFromList
     * @param fixList {object}
     * @param referencePosition {StaticPositionModel}
     * @private
     */

  }, {
    key: "_buildFixModelsFromList",
    value: function _buildFixModelsFromList(fixList, referencePosition) {
      var _this = this;

      (0, _forEach2["default"])(fixList, function (fixCoordinates, fixName) {
        var fixModel = new _FixModel["default"](fixName, fixCoordinates, referencePosition); // const fixModel = modelSourceFactory.getModelSourceForType('FixModel', fixName, fixCoordinates, referencePosition);

        _this.addFixToCollection(fixModel);
      });
    }
    /**
     * @for FixCollection
     * @method _resetFixModels
     * @private
     */

  }, {
    key: "_resetFixModels",
    value: function _resetFixModels() {
      (0, _forEach2["default"])(this._items, function (fixModel) {
        fixModel.reset(); // modelSourceFactory.returnModelToPool(fixModel);
      });
    }
  }]);

  return FixCollection;
}(_BaseCollection2["default"]);

var _default = new FixCollection();

exports["default"] = _default;

},{"../base/BaseCollection":294,"../math/distance":350,"./FixModel":358,"lodash/find":191,"lodash/forEach":199}],358:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _BaseModel2 = _interopRequireDefault(require("../base/BaseModel"));

var _StaticPositionModel = _interopRequireDefault(require("../base/StaticPositionModel"));

var _waypointConstants = require("../constants/waypointConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Defines a navigational `FixModel`
 *
 * A `FixModel` can be used as part of a `StandardRoute` or as a naviagtional aid.
 * Not all `FixModel`s are a part of a `StandardRoute`.
 *
 * @class FixModel
 */
var FixModel =
/*#__PURE__*/
function (_BaseModel) {
  _inherits(FixModel, _BaseModel);

  /**
   * @for FixModel
   * @constructor
   * @param fixName {string}
   * @param fixCoordinate {array}
   * @param referencePosition {StaticPositionModel}
   */
  function FixModel(fixName, fixCoordinate, referencePosition) {
    var _this;

    _classCallCheck(this, FixModel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FixModel).call(this));
    /**
     * Name of the Fix
     *
     * @property name
     * @type {string}
     * @default ''
     */

    _this.name = '';
    /**
     * Coordinates of the fix
     *
     * @property _positionModel
     * @type {StaticPositionModel}
     * @default null
     */

    _this._positionModel = null;

    _this.init(fixName, fixCoordinate, referencePosition);

    return _this;
  }
  /**
   * Indicates whether the fix is a real fix, not an RNAV fix
   * (prefixed with an underscore)
   *
   * @property isRealFix
   * @return {boolean}
   */


  _createClass(FixModel, [{
    key: "init",

    /**
     * Lifecycle method. Should be run only once on instantiation.
     *
     * @for FixModel
     * @method init
     * @param fixName {string}
     * @param fixCoordinate {array}
     * @param referencePosition {StaticPositionModel}
     * @chainable
     */
    value: function init(fixName, fixCoordinate, referencePosition) {
      // TODO: should this be a throwing instead of returning early?
      if (!fixName || !fixCoordinate || !referencePosition) {
        return;
      }

      this.name = fixName.toUpperCase();
      this._positionModel = new _StaticPositionModel["default"](fixCoordinate, referencePosition, referencePosition.magneticNorth);
      return this;
    }
    /**
     * reset the current instance
     *
     * @for FixModel
     * @method reset
     * @chainable
     */

  }, {
    key: "reset",
    value: function reset() {
      this.name = '';
      this._positionModel = null;
      return this;
    }
    /**
     * Returns a clone of an instance's `_positionModel` property.
     *
     * It is important to note that this is a _clone_ and not a copy. Any changes made to this instance will
     * not be reflected in the clone. This creates an entirely new instance of the `_positionModel` property,
     * and after creation is completely independant of this instance.
     *
     * This is used with `StandardRouteWaypointModel` objects to obtain the position of a fix. This method
     * provides easy access to the `StaticPositionModel` that already exists here.
     *
     * @for FixModel
     * @return {StaticPositionModel}  a clone of the current `_positionModel` property
     */

  }, {
    key: "clonePosition",
    value: function clonePosition() {
      return (0, _cloneDeep2["default"])(this._positionModel);
    }
  }, {
    key: "isRealFix",
    get: function get() {
      return this.name[0] !== _waypointConstants.RNAV_WAYPOINT_PREFIX;
    }
    /**
     * Provides access to the position data of the instance
     *
     * @property positionModel
     * @return {array}
     */

  }, {
    key: "positionModel",
    get: function get() {
      return this._positionModel;
    }
    /**
     * Fascade to access relative position
     *
     * @for FixModel
     * @return {array<number>} [kilometersNorth, kilometersEast]
     */

  }, {
    key: "relativePosition",
    get: function get() {
      return this._positionModel.relativePosition;
    }
  }]);

  return FixModel;
}(_BaseModel2["default"]);

exports["default"] = FixModel;

},{"../base/BaseModel":295,"../base/StaticPositionModel":297,"../constants/waypointConstants":335,"lodash/cloneDeep":183}],359:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _HoldModel = _interopRequireDefault(require("./HoldModel"));

var _BaseCollection2 = _interopRequireDefault(require("../base/BaseCollection"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Collection of `HoldModel`s
 *
 * Provides methods to create `HoldModel`s, used by `AirportModel`
 * and `WaypointModel` for configuring hold
 *
 * @class HoldCollection
 * @extends BaseCollection
 */
var HoldCollection =
/*#__PURE__*/
function (_BaseCollection) {
  _inherits(HoldCollection, _BaseCollection);

  /**
   * @constructor
   * @param holdJson {object}
   */
  function HoldCollection(holdJson) {
    var _this;

    _classCallCheck(this, HoldCollection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HoldCollection).call(this)); // holdsJson is permitted to be null/undefined/empty, but if valid must be an object

    if (holdJson != null && !(0, _isObject2["default"])(holdJson)) {
      throw new TypeError("Invalid holdJson parameter passed to HoldCollection. Expected an object but found ".concat(_typeof(holdJson)));
    }
    /**
     * @inherited
     * @memberof BaseCollection
     * @property _items
     * @type {array<HoldModel>}
     * @default []
     */

    /**
     * @inherited
     * @memberof BaseCollection
     * @property length
     * @type {number}
     * @default #_items.length
     */


    _this._init(holdJson);

    return _this;
  }
  /**
   * Public fascade for `#_items`
   *
   * @for HoldCollection
   * @property holds
   * @return {array<HoldModel>}
   */


  _createClass(HoldCollection, [{
    key: "_init",
    // ------------------------------ LIFECYCLE ------------------------------

    /**
     * Initialize the instance
     *
     * @for HoldCollection
     * @method _init
     * @param holdJson {object}
     */
    value: function _init(holdJson) {
      this.populateHolds(holdJson);
    }
    /**
     * @for HoldCollection
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this.holds.forEach(function (item) {
        return item.reset();
      });
      this._items = [];
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Returns a flag indicating whether the `fixName` exists within the collection
     *
     * @for HoldCollection
     * @method containsHoldForFix
     * @param fixName {string}
     * @return {boolean}
     */

  }, {
    key: "containsHoldForFix",
    value: function containsHoldForFix(fixName) {
      if (!fixName) {
        return false;
      }

      fixName = fixName.toUpperCase();
      return this._items.some(function (hold) {
        return hold.fixName === fixName;
      });
    }
    /**
     * Find holdParameters by `fixName` if it exists within the collection
     *
     * @for HoldCollection
     * @method findHoldParametersByFix
     * @param fixName {string}
     * @return {object|null}
     */

  }, {
    key: "findHoldParametersByFix",
    value: function findHoldParametersByFix(fixName) {
      if (!fixName) {
        return null;
      }

      fixName = fixName.toUpperCase();

      var model = this._items.find(function (hold) {
        return hold.fixName === fixName;
      });

      return model ? model.holdParameters : null;
    }
    /**
     * Populates the hold collection with the specified holds object
     *
     * @for HoldCollection
     * @method populateHolds
     * @param holdJson {object}
     */

  }, {
    key: "populateHolds",
    value: function populateHolds(holdJson) {
      var _this2 = this;

      if (!holdJson) {
        return;
      } // Check for duplicate fixName as multiple collections may have to be combined
      // by the `NavigationLibrary` in the future


      Object.keys(holdJson).forEach(function (fixName) {
        if (_this2.containsHoldForFix(fixName)) {
          return;
        }

        _this2._items.push(new _HoldModel["default"](fixName, holdJson[fixName]));
      });
    }
  }, {
    key: "holds",
    get: function get() {
      return this._items;
    }
  }]);

  return HoldCollection;
}(_BaseCollection2["default"]);

exports["default"] = HoldCollection;

},{"../base/BaseCollection":294,"./HoldModel":360,"lodash/isObject":221}],360:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _BaseModel2 = _interopRequireDefault(require("../base/BaseModel"));

var _circle = require("../math/circle");

var _argumentValidators = require("../parsers/aircraftCommandParser/argumentValidators");

var _argumentParsers = require("../parsers/aircraftCommandParser/argumentParsers");

var _navigationUtilities = require("../utilities/navigationUtilities");

var _unitConverters = require("../utilities/unitConverters");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Defines a navigational `HoldModel`
 *
 * A `HoldModel` is used to specify how a hold executed at
 * a specific fix
 *
 * @class HoldModel
 */
var HoldModel =
/*#__PURE__*/
function (_BaseModel) {
  _inherits(HoldModel, _BaseModel);

  /**
   * @for HoldModel
   * @constructor
   * @param fixName {string}
   * @param holdString {string}
   */
  function HoldModel(fixName, holdString) {
    var _this;

    _classCallCheck(this, HoldModel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HoldModel).call(this));

    if (!(0, _isString2["default"])(fixName)) {
      throw new TypeError("Invalid parameter, fixName must be a string, but found ".concat(_typeof(fixName)));
    } else if (!(0, _isString2["default"])(holdString)) {
      throw new TypeError("Invalid parameter, holdString must be a string, but found ".concat(_typeof(holdString)));
    }
    /**
     * Name of the Fix
     *
     * @property fixName
     * @type {string}
     * @default ''
     */


    _this.fixName = '';
    /**
     * The parameters of the hold
     *
     * @property holdParameters
     * @type {object}
     * @default null
     */

    _this.holdParameters = null;

    _this._init(fixName, holdString);

    return _this;
  } // ------------------------------ LIFECYCLE ------------------------------

  /**
   * Initialize the model
   *
   * @for HoldModel
   * @method _init
   * @param fixName {string}
   * @param holdString {string}
   * @private
   */


  _createClass(HoldModel, [{
    key: "_init",
    value: function _init(fixName, holdString) {
      this.fixName = fixName;
      this.holdParameters = this._buildHoldParameters(holdString);
      return this;
    }
    /**
     * @for MapModel
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this.fixName = '';
      this.holdParameters = null;
    } // ------------------------------ LIFECYCLE ------------------------------

    /**
     * Builds the HoldParameters from the specified string
     *
     * @for HoldModel
     * @method _buildHoldParameters
     * @param holdString {string}
     * @returns {object}
     * @private
     */

  }, {
    key: "_buildHoldParameters",
    value: function _buildHoldParameters(holdString) {
      var _this2 = this;

      var holdParameters = {};
      holdString.split('|').forEach(function (item) {
        if (holdParameters.inboundHeading == null && (0, _argumentValidators.isValidCourseString)(item)) {
          holdParameters.inboundHeading = (0, _circle.radians_normalize)((0, _unitConverters.degreesToRadians)(180 + parseInt(item, 10)));
          return;
        }

        if (holdParameters.turnDirection == null && (0, _argumentValidators.isValidDirectionString)(item)) {
          holdParameters.turnDirection = (0, _argumentParsers.directionNormalizer)(item);
          return;
        }

        if (holdParameters.legLength == null && (0, _argumentParsers.isLegLengthArg)(item)) {
          holdParameters.legLength = item;
          return;
        } // The speed limit can be optional, but it tends to imply ICAO speed restrictions


        var _parseSpeedRestrictio = (0, _navigationUtilities.parseSpeedRestriction)(item),
            _parseSpeedRestrictio2 = _slicedToArray(_parseSpeedRestrictio, 2),
            value = _parseSpeedRestrictio2[0],
            limit = _parseSpeedRestrictio2[1];

        if (value != null) {
          if (limit !== '-') {
            throw new Error("Invalid speedMaximum parameter for Fix '".concat(_this2.fixName, "': ").concat(item, " is not valid"));
          }

          holdParameters.speedMaximum = value;
          return;
        }

        throw new Error("Unexpected parameter for Fix '".concat(_this2.fixName, "': ").concat(item));
      });

      if (holdParameters.inboundHeading == null) {
        throw new Error("Missing radial parameter for Fix '".concat(this.fixName, "': ").concat(holdString));
      }

      if (holdParameters.turnDirection == null) {
        throw new Error("Missing turnDirection parameter for Fix '".concat(this.fixName, "': ").concat(holdString));
      }

      if (holdParameters.legLength == null) {
        throw new Error("Missing legLength parameter for Fix '".concat(this.fixName, "': ").concat(holdString));
      }

      return holdParameters;
    }
  }]);

  return HoldModel;
}(_BaseModel2["default"]);

exports["default"] = HoldModel;

},{"../base/BaseModel":295,"../math/circle":348,"../parsers/aircraftCommandParser/argumentParsers":368,"../parsers/aircraftCommandParser/argumentValidators":369,"../utilities/navigationUtilities":388,"../utilities/unitConverters":391,"lodash/isString":224}],361:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _filter2 = _interopRequireDefault(require("lodash/filter"));

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _without2 = _interopRequireDefault(require("lodash/without"));

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _AirwayModel = _interopRequireDefault(require("./AirwayModel"));

var _FixCollection = _interopRequireDefault(require("./FixCollection"));

var _HoldCollection = _interopRequireDefault(require("./HoldCollection"));

var _ProcedureModel = _interopRequireDefault(require("./ProcedureModel"));

var _StaticPositionModel = _interopRequireDefault(require("../base/StaticPositionModel"));

var _routeConstants = require("../constants/routeConstants");

var _unitConverters = require("../utilities/unitConverters");

var _globalConstants = require("../constants/globalConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 *
 *
 * @class NavigationLibrary
 */
var NavigationLibrary =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @for NavigationLibrary
   * @param airportJson {object}
   */
  function NavigationLibrary() {
    _classCallCheck(this, NavigationLibrary);

    this._airwayCollection = {};
    /**
     * Collection of all `HoldModel`s for the airport region
     *
     * @property holdCollection
     * @type {HoldCollection}
     * @default HoldCollection()
     */

    this._holdCollection = new _HoldCollection["default"](); // /**
    //  *
    //  *
    //  * @property _sidCollection
    //  * @type {StandardRoute}
    //  * @default null
    //  */
    // this._sidCollection = null;
    //
    // /**
    //  *
    //  *
    //  * @property _starCollection
    //  * @type {StandardRoute}
    //  * @default null
    //  */
    // this._starCollection = null;

    /**
     *
     *
     * @property _procedureCollection
     * @type {array}
     * @default {}
     */

    this._procedureCollection = {};
    /**
     *
     *
     * @property _referencePosition
     * @type {StaticPositionModel}
     * @default null
     */

    this._referencePosition = null;
    /**
     * additional information to draw the procedures on the screen
     *
     * @property _procedureLines
     * @type {array}
     * @default {}
     */

    this._procedureLines = {};
  }
  /**
   *
   * @for NavigationLibrary
   * @property hasSids
   * @type {boolean}
   */


  _createClass(NavigationLibrary, [{
    key: "init",

    /**
     * Set initial instance properties
     *
     * May be run multiple times on an instance. Subsequent calls to this method
     * should happen only after a call to `.reset()`
     *
     * @for NavigationLibrary
     * @method init
     */
    value: function init(airportJson) {
      var airways = airportJson.airways,
          fixes = airportJson.fixes,
          holds = airportJson.holds,
          sids = airportJson.sids,
          stars = airportJson.stars;

      this._initializeReferencePosition(airportJson);

      this._initializeFixCollection(fixes);

      this._initializeAirwayCollection(airways);

      this._initializeHoldCollection(holds);

      this._initializeProcedureCollection(sids, stars);

      this._initializeSidLines();

      this._initializeStarLines();

      this._showConsoleWarningForUndefinedFixes();
    }
    /**
     *
     * @for NavigationLibrary
     * @method _initializeAirwayCollection
     * @param airways {object} - airways to add to the collection.
     */

  }, {
    key: "_initializeAirwayCollection",
    value: function _initializeAirwayCollection(airways) {
      var _this = this;

      (0, _forEach2["default"])(airways, function (fixNames, airwayName) {
        if (airwayName in _this._airwayCollection) {
          throw new TypeError("Expected single definition for \"".concat(airwayName, "\" airway, but received multiple"));
        }

        _this._airwayCollection[airwayName] = new _AirwayModel["default"](airwayName, fixNames, _this);
      });
    }
    /**
     *
     * @for NavigationLibrary
     * @method _initializeFixCollection
     * @param fixes {object} - fixes to add to the collection.
     */

  }, {
    key: "_initializeFixCollection",
    value: function _initializeFixCollection(fixes) {
      _FixCollection["default"].addItems(fixes, this._referencePosition);
    }
    /**
     *
     * @for NavigationLibrary
     * @method _initializeHoldCollection
     * @param holds {object} - non-procedural holds to add to the collection.
     */

  }, {
    key: "_initializeHoldCollection",
    value: function _initializeHoldCollection(holds) {
      this._holdCollection.populateHolds(holds);
    }
    /**
     *
     * @for NavigationLibrary
     * @method _initializeProcedureCollection
     * @param sids {object} - SIDs to add to the collection
     * @param stars {object} - STARs to add to the collection
     */

  }, {
    key: "_initializeProcedureCollection",
    value: function _initializeProcedureCollection(sids, stars) {
      var _this2 = this;

      (0, _forEach2["default"])(sids, function (sid, sidId) {
        if (sidId in _this2._procedureCollection) {
          throw new TypeError("Expected single definition for '".concat(sidId, "' procedure, but received multiple"));
        }

        _this2._procedureCollection[sidId] = new _ProcedureModel["default"](_routeConstants.PROCEDURE_TYPE.SID, sid);
      });
      (0, _forEach2["default"])(stars, function (star, starId) {
        if (starId in _this2._procedureCollection) {
          throw new TypeError("Expected single definition for '".concat(starId, "' procedure, but received multiple"));
        }

        _this2._procedureCollection[starId] = new _ProcedureModel["default"](_routeConstants.PROCEDURE_TYPE.STAR, star);
      });
    }
    /**
     *
     * @for NavigationLibrary
     * @method _initializeReferencePosition
     * @param airportJson {object}
     */

  }, {
    key: "_initializeReferencePosition",
    value: function _initializeReferencePosition(airportJson) {
      this._referencePosition = new _StaticPositionModel["default"](airportJson.position, null, (0, _unitConverters.degreesToRadians)(airportJson.magnetic_north));
    }
    /**
     * Generate lines for SIDs and add them to the procedure lines
     *
     * @for NavigationLibrary
     * @method _initializeSidLines
     */

  }, {
    key: "_initializeSidLines",
    value: function _initializeSidLines() {
      var sids = this.getProceduresByType(_routeConstants.PROCEDURE_TYPE.SID);
      this._procedureLines[_routeConstants.PROCEDURE_TYPE.SID] = this._buildProcedureLine(sids);
    }
    /**
     * Generate lines for STARs and add them to the procedure lines
     *
     * @for NavigationLibrary
     * @method _initializeStarLines
     */

  }, {
    key: "_initializeStarLines",
    value: function _initializeStarLines() {
      var stars = this.getProceduresByType(_routeConstants.PROCEDURE_TYPE.STAR);
      this._procedureLines[_routeConstants.PROCEDURE_TYPE.STAR] = this._buildProcedureLine(stars);
    }
    /**
     * Generate lines for prodecures and return the resulting lines.
     *
     * @for NavigationLibrary
     * @method _buildProcedureLine
     * @param procedures {array<ProcedureModel>}
     * @return {array<object>}
     */

  }, {
    key: "_buildProcedureLine",
    value: function _buildProcedureLine(procedures) {
      var procedureLines = []; // TODO: simplify/rector these nested loops.

      for (var i = 0; i < procedures.length; i++) {
        var procedure = procedures[i];
        var lines = [];
        var exits = [];
        var firstFixName = null;
        var mostRecentFixName = '';

        for (var j = 0; j < procedure.draw.length; j++) {
          var fixList = procedure.draw[j];
          var positions = [];

          for (var k = 0; k < fixList.length; k++) {
            var fixName = fixList[k];
            mostRecentFixName = fixName;

            if (fixName.indexOf('*') !== _globalConstants.INVALID_INDEX) {
              mostRecentFixName = fixName.replace('*', '');
              exits.push(mostRecentFixName);
            }

            var fixPosition = this.getFixRelativePosition(mostRecentFixName);

            if (!fixPosition) {
              console.warn("Unable to draw line to '".concat(fixName, "' because its position is not defined!"));
              continue;
            }

            if (firstFixName === null) {
              firstFixName = mostRecentFixName;
            }

            positions.push(fixPosition);
          }

          if (positions.length > 1) {
            lines.push(positions);
          }
        }

        procedureLines.push({
          identifier: procedure.icao,
          lines: lines,
          firstFixName: firstFixName,
          lastFixName: mostRecentFixName,
          exits: exits
        });
      }

      return procedureLines;
    }
    /**
     * Tear down the instance
     *
     * @for NavigationLibrary
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      _FixCollection["default"].removeItems();

      this._holdCollection.reset();

      this._airwayCollection = {};
      this._procedureCollection = {};
      this._referencePosition = null;
      this._procedureLines = {};
    } // /**
    //  * Given a `procedureRouteSegment`, find and assemble a list
    //  * of `WaypointModel` objects to be used with a `LegModel`
    //  * in the Fms.
    //  *
    //  * @for NavigationLibrary
    //  * @method buildWaypointModelsForProcedure
    //  * @param procedureRouteSegment {string}  of the shape `ENTRY.PROCEDURE_NAME.EXIT`
    //  * @param runway {string}                 assigned runway
    //  * @param flightPhase {string}            current phase of flight
    //  * @return {array<WaypointModel>}
    //  */
    // buildWaypointModelsForProcedure(procedureRouteSegment, runway, flightPhase) {
    //     const routeModel = new RouteModel(procedureRouteSegment);
    //     let standardRouteWaypointModelList;
    //
    //     if (this.isGroundedFlightPhase(flightPhase)) {
    //         standardRouteWaypointModelList = this.sidCollection.generateFmsWaypointModelsForRoute(
    //             routeModel.procedure,
    //             runway,
    //             routeModel.exit
    //         );
    //     } else {
    //         standardRouteWaypointModelList = this.starCollection.generateFmsWaypointModelsForRoute(
    //             routeModel.procedure,
    //             routeModel.entry,
    //             runway
    //         );
    //     }
    //
    //     return standardRouteWaypointModelList;
    // }
    //
    // /**
    //  * Find the `StandardRouteWaypointModel` objects for a given route.
    //  *
    //  * @for NavigationLibrary
    //  * @method findWaypointModelsForSid
    //  * @param id {string}
    //  * @param runway {string}
    //  * @param exit {string}
    //  * @return {array<StandardWaypointModel>}
    //  */
    // findWaypointModelsForSid(id, runway, exit) {
    //     return this.sidCollection.findRouteWaypointsForRouteByEntryAndExit(id, runway, exit);
    // }
    //
    // /**
    //  * Find the `StandardRouteWaypointModel` objects for a given route.
    //  *
    //  * @for NavigationLibrary
    //  * @method findWaypointModelsForStar
    //  * @param id {string}
    //  * @param entry {string}
    //  * @param runway {string}
    //  * @param isPreSpawn {boolean} flag used to determine if distances between waypoints should be calculated
    //  * @return {array<StandardWaypointModel>}
    //  */
    // findWaypointModelsForStar(id, entry, runway, isPreSpawn = false) {
    //     return this.starCollection.findRouteWaypointsForRouteByEntryAndExit(id, entry, runway, isPreSpawn);
    // }
    //
    // /**
    //  * Finds the collectionName a given `procedureId` belongs to.
    //  *
    //  * This is useful when trying to find a particular route without
    //  * knowing, first, what collection it may be a part of. Like when
    //  * validating a user entered route.
    //  *
    //  * @for NavigationLibrary
    //  * @method findCollectionNameForProcedureId
    //  * @param procedureId {string}
    //  * @return collectionName {string}
    //  */
    // findCollectionNameForProcedureId(procedureId) {
    //     let collectionName = '';
    //
    //     if (this.sidCollection.hasRoute(procedureId)) {
    //         collectionName = 'sidCollection';
    //     } else if (this.starCollection.hasRoute(procedureId)) {
    //         collectionName = 'starCollection';
    //     }
    //
    //     return collectionName;
    // }

    /**
     * Facade for `HoldCollection.findHoldParametersByFix`
     *
     * @for NavigationLibrary
     * @method findHoldParametersByFix
     * @param fixName {string}
     * @return {object|null}
     */

  }, {
    key: "findHoldParametersByFix",
    value: function findHoldParametersByFix(fixName) {
      return this._holdCollection.findHoldParametersByFix(fixName);
    }
    /**
     * Fascade Method
     *
     * @for NavigationLibrary
     * @method findFixByName
     * @param fixName {string}
     * @return {FixModel|undefined}
     */

  }, {
    key: "findFixByName",
    value: function findFixByName(fixName) {
      return _FixCollection["default"].findFixByName(fixName);
    }
    /**
     * Return the corresponding AirwayModel with the specified identifier
     *
     * @for NavigationLibrary
     * @method getAirway
     * @return {AirwayModel}
     */

  }, {
    key: "getAirway",
    value: function getAirway(airwayId) {
      if (!this.hasAirway(airwayId)) {
        return null;
      }

      return this._airwayCollection[airwayId];
    }
    /**
     * Return the corresponding ProcedureModel with the specified identifier
     *
     * @for NavigationLibrary
     * @method getProcedure
     * @param procedureId {string}
     * @return {ProcedureModel}
     */

  }, {
    key: "getProcedure",
    value: function getProcedure(procedureId) {
      if (!this.hasProcedure(procedureId)) {
        return null;
      }

      return this._procedureCollection[procedureId];
    }
    /**
    * Return a list of ProcedureModel with the specified procedure type
    *
    * @for NavigationLibrary
    * @method getProceduresByType
    * @param procedureType {string}
    * @return {array<ProcedureModel>}
    */

  }, {
    key: "getProceduresByType",
    value: function getProceduresByType(procedureType) {
      return (0, _filter2["default"])(this._procedureCollection, function (procedureModel) {
        return !(0, _isEmpty2["default"])(procedureModel) && procedureModel.procedureType === procedureType;
      });
    }
    /**
     * Fascade Method
     *
     * @for NavigationLibrary
     * @method getFixRelativePosition
     * @param fixName {string}
     * @return {array<number>}
     */

  }, {
    key: "getFixRelativePosition",
    value: function getFixRelativePosition(fixName) {
      return _FixCollection["default"].getFixRelativePosition(fixName);
    }
    /**
     *
     *
     * @for NavigationLibrary
     * @method getProcedureLines
     * @param procedureId {string}
     * @return {array}
     */

  }, {
    key: "getProcedureLines",
    value: function getProcedureLines(procedureId) {
      return this._procedureLines[procedureId];
    }
    /**
     * Return whether the specified airway identifier is listed in the #_airwayCollection
     *
     * @for NavigationLibrary
     * @method hasAirway
     * @param airwayId {string}
     * @return {boolean}
     */

  }, {
    key: "hasAirway",
    value: function hasAirway(airwayId) {
      return airwayId in this._airwayCollection;
    }
    /**
    * Provides a way to check the `FixCollection` for the existence
    * of a specific `fixName`.
    *
    * @for NavigationLibrary
    * @method hasFixName
    * @param fixName {string}
    * @return {boolean}
    */

  }, {
    key: "hasFixName",
    value: function hasFixName(fixName) {
      var fixOrNull = this.findFixByName(fixName);
      return !(0, _isNil2["default"])(fixOrNull);
    }
    /**
    * Provides a way to check for the existence
    * of a specific `procedureId`.
    *
    * @for NavigationLibrary
    * @method hasProcedure
    * @param procedureId {string}
    * @return {boolean}
    */

  }, {
    key: "hasProcedure",
    value: function hasProcedure(procedureId) {
      return procedureId in this._procedureCollection;
    }
    /**
     * Check all fixes used in procedures, and gather a list of any fixes that are
     * not defined in the `fixes` section of the airport file, then sort and print
     * that list to the console.
     *
     * @for NavigationLibrary
     * @method _showConsoleWarningForUndefinedFixes
     */

  }, {
    key: "_showConsoleWarningForUndefinedFixes",
    value: function _showConsoleWarningForUndefinedFixes() {
      var allFixNames = this._getAllFixNamesInUse();

      var missingFixes = allFixNames.filter(function (fix) {
        return !_FixCollection["default"].findFixByName(fix);
      });

      if (missingFixes.length < 1) {
        return;
      }

      console.warn("The following fixes have yet to be defined in the \"fixes\" section: \n".concat(missingFixes));
    }
    /**
     * Gathers a unique, sorted list of all fixes used in all known procedures
     *
     * @for NavigationLibrary
     * @method _getAllFixNamesInUse
     * @return {array<string>} ['fixxa', 'fixxb', 'fixxc', ...]
     * @private
     */

  }, {
    key: "_getAllFixNamesInUse",
    value: function _getAllFixNamesInUse() {
      var airwayFixes = (0, _map2["default"])(this._airwayCollection, function (airwayModel) {
        return airwayModel.fixNameCollection;
      });
      var fixGroups = (0, _map2["default"])(this._procedureCollection, function (procedureModel) {
        return procedureModel.getAllFixNamesInUse();
      });
      var uniqueFixNames = (0, _without2["default"])((0, _uniq2["default"])((0, _flatten2["default"])([].concat(_toConsumableArray(airwayFixes), _toConsumableArray(fixGroups)))), undefined);
      return uniqueFixNames.sort();
    }
  }, {
    key: "hasSids",
    get: function get() {
      var sidProcedureModels = (0, _filter2["default"])(this._procedureCollection, function (procedure) {
        return procedure.procedureType === _routeConstants.PROCEDURE_TYPE.SID;
      });
      return sidProcedureModels.length > 0;
    }
    /**
     *
     * @for NavigationLibrary
     * @property hasStars
     * @type {boolean}
     */

  }, {
    key: "hasStars",
    get: function get() {
      var starProcedureModels = (0, _filter2["default"])(this._procedureCollection, function (procedure) {
        return procedure.procedureType === _routeConstants.PROCEDURE_TYPE.STAR;
      });
      return starProcedureModels.length > 0;
    } // get sidCollection() {
    //     return _filter(this._procedureCollection, (procedure) => procedure.procedureType === PROCEDURE_TYPE.SID);
    // }
    //
    // get starCollection() {
    //     return _filter(this._procedureCollection, (procedure) => procedure.procedureType === PROCEDURE_TYPE.STAR);
    // }

    /**
     *
     * @for NavigationLibrary
     * @property realFixes
     * @type {array<FixModel>}
     */

  }, {
    key: "realFixes",
    get: function get() {
      return _FixCollection["default"].findRealFixes();
    }
  }]);

  return NavigationLibrary;
}();

var _default = new NavigationLibrary();

exports["default"] = _default;

},{"../base/StaticPositionModel":297,"../constants/globalConstants":310,"../constants/routeConstants":314,"../utilities/unitConverters":391,"./AirwayModel":356,"./FixCollection":357,"./HoldCollection":359,"./ProcedureModel":362,"lodash/filter":190,"lodash/flatten":197,"lodash/forEach":199,"lodash/isEmpty":213,"lodash/isNil":219,"lodash/map":231,"lodash/uniq":249,"lodash/without":252}],362:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _random2 = _interopRequireDefault(require("lodash/random"));

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _WaypointModel = _interopRequireDefault(require("../aircraft/FlightManagementSystem/WaypointModel"));

var _HoldCollection = _interopRequireDefault(require("./HoldCollection"));

var _routeConstants = require("../constants/routeConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Generic class for instrument procedures of multiple types, such as SIDs/STARs
 *
 * Used by FMS to generate waypoints from instrument procedures outlined in an
 * airport's JSON file. The FMS is given a route on spawn, or a reroute by a
 * controller, and if it contains a procedure, it will look up the associated
 * `ProcedureModel`, and request the waypoints for that procedure at
 * the planned entry and exit points, which are then consumed by the FMS for
 * navigation purposes.
 *
 * @class ProcedureModel
 */
var ProcedureModel =
/*#__PURE__*/
function () {
  /**
   * @for ProcedureModel
   * @constructor
   * @param procedureType {string} must belong to the `PROCEDURE_TYPE` enum
   * @param data {object} JSON data from airport file
   */
  function ProcedureModel(procedureType, data) {
    _classCallCheck(this, ProcedureModel);

    if ((0, _isNil2["default"])(data)) {
      throw new TypeError("Expected valid procedure data, but received '".concat(data, "'"));
    }
    /**
     * Body segment of the procedure
     *
     * All possible routes will contain all waypoints from the body, regardless
     * of where they enter or exit the procedure. Does not necessarily contain
     * any waypoints, provided that no combination of entry/exit would result
     * in fewer than two waypoints.
     *
     * @property _body
     * @type {array<array<string>|<string>>}
     * @default []
     * @private
     */


    this._body = [];
    /**
     * 2D array describing the lines needed to be drawn between fixes in order
     * to properly depict the procedure's path on the scope
     *
     * [
     *     ['FIXXA', 'FIXXB', 'FIXXC'],
     *     ['FIXXA', 'FIXXC']
     * ]
     *
     * @property _draw
     * @type {array<array<string>>}
     * @default []
     * @private
     */

    this._draw = [];
    /**
     * All fixes where aircraft may enter the procedure
     *
     * Each entry fix is a key in this property, whose value is a list of (restrictable)
     * fixes to follow on that entry in order to join the body of the procedure.
     *
     * @property _entryPoints
     * @type {array<array<string>|<string>>}
     * @default {}
     * @private
     */

    this._entryPoints = {};
    /**
     * All fixes where aircraft may exit the procedure
     *
     * Each exit fix is a key in this property, whose value is a list of (restrictable)
     * fixes to follow on that exit in order to leave the procedure.
     *
     * @property _exitPoints
     * @type {array<array<string>|<string>>}
     * @default {}
     * @private
     */

    this._exitPoints = {};
    /**
     * The ICAO identifier for this procedure
     *
     * @property _icao
     * @type {string}
     * @default ''
     * @private
     */

    this._icao = '';
    /**
     * The collection of holds for this procedure
     *
     * @property _holdCollection
     * @type {HoldCollection}
     * @default null
     * @private
     */

    this._holdCollection = null;
    /**
     * The verbally spoken name of the procedure
     *
     * Nonstandard spellings may be used to achieve the desired pronunciations,
     * since this is only used for speech synthesis.
     *
     * @property _name
     * @type {string}
     * @default ''
     * @private
     */

    this._name = '';
    /**
     * The type of instrument procedure (must be one of `PROCEDURE_TYPE`)
     *
     * @property _procedureType
     * @type {string}
     * @default ''
     * @private
     */

    this._procedureType = '';
    /**
     * The initial climb clearance (only for SIDs)
     *
     * @property _altitude
     * @type {number}
     * @default null
     * @private
     */

    this._altitude = null;
    this.init(procedureType, data);
  }
  /**
   * Return value of `#_draw`
   *
   * @for ProcedureModel
   * @property draw
   * @type {array}
   */


  _createClass(ProcedureModel, [{
    key: "init",
    // ------------------------------ LIFECYCLE ------------------------------

    /**
     * Initialize instance properties
     *
     * @for ProcedureModel
     * @method init
     * @param procedureType {string} must belong to the `PROCEDURE_TYPE` enum
     * @param data {object} JSON data from airport file
     * @chainable
     */
    value: function init(procedureType, data) {
      this._body = data.body;
      this._draw = data.draw;
      this._holdCollection = new _HoldCollection["default"](data.holds);
      this._icao = data.icao;
      this._name = data.name;
      this._altitude = data.altitude;
      this._procedureType = procedureType;

      if (this._procedureType === _routeConstants.PROCEDURE_TYPE.SID) {
        return this._initEntriesAndExitsForSid(data);
      } else if (this._procedureType === _routeConstants.PROCEDURE_TYPE.STAR) {
        return this._initEntriesAndExitsForStar(data);
      }

      throw new TypeError('Expected procedure definition with known type, ' + "but received unknown type '".concat(this._procedureType, "'"));
    }
    /**
     * Reset instance properties
     *
     * @for ProcedureModel
     * @method reset
     * @chainable
     */

  }, {
    key: "reset",
    value: function reset() {
      this._body = [];
      this._draw = [];
      this._entryPoints = {};
      this._exitPoints = {};
      this._icao = '';
      this._name = '';
      this._procedureType = '';
      this._altitude = null;
      return this;
    }
    /**
     * Initialize `#_entryPoints` and `#_exitPoints` for 'SID' procedure
     *
     * @for ProcedureModel
     * @method _initEntriesAndExitsForSid
     * @param data {object} JSON data from airport file
     * @private
     * @chainable
     */

  }, {
    key: "_initEntriesAndExitsForSid",
    value: function _initEntriesAndExitsForSid(data) {
      this._entryPoints = data.rwy;
      this._exitPoints = data.exitPoints;
      return this;
    }
    /**
     * Initialize `#_entryPoints` and `#_exitPoints` for 'STAR' procedure
     *
     * @for ProcedureModel
     * @method _initEntriesAndExitsForStar
     * @param data {object} JSON data from airport file
     * @private
     * @chainable
     */

  }, {
    key: "_initEntriesAndExitsForStar",
    value: function _initEntriesAndExitsForStar(data) {
      this._entryPoints = data.entryPoints;
      this._exitPoints = data.rwy;
      return this;
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Return an array of names of all fixes existing in any segment of this procedure
     *
     * @for ProcedureModel
     * @method getAllFixNamesInUse
     * @return {array<string>}
     */

  }, {
    key: "getAllFixNamesInUse",
    value: function getAllFixNamesInUse() {
      if (!(0, _isArray2["default"])(this._draw[0])) {
        throw new TypeError("Invalid data set in draw segment of the ".concat(this._icao, " procedure. Expected a 2D ") + 'array: `[[FIXXA, FIXXB*], [FIXXC, FIXXD*]]`. Please see airport documentation for more information ' + '(https://github.com/openscope/openscope/blob/develop/documentation/airport-format.md#sids).');
      }

      var entryFixNames = this._getFixNamesFromEntries();

      var bodyFixNames = this._getFixNamesFromBody();

      var exitFixNames = this._getFixNamesFromExits();

      var drawFixNames = this._getFixNamesFromDraw();

      var allFixNames = [].concat(_toConsumableArray(entryFixNames), _toConsumableArray(bodyFixNames), _toConsumableArray(exitFixNames), _toConsumableArray(drawFixNames));
      var uniqueFixNames = (0, _uniq2["default"])(allFixNames);
      return uniqueFixNames;
    }
    /**
     * Return the name of a randomly selected exit point
     *
     * @for ProcedureModel
     * @method getRandomExitPoint
     * @return {string}
     */

  }, {
    key: "getRandomExitPoint",
    value: function getRandomExitPoint() {
      var exitNames = Object.keys(this._exitPoints);
      var maxIndex = exitNames.length - 1;
      var randomIndex = (0, _random2["default"])(0, maxIndex);
      return exitNames[randomIndex];
    }
    /**
     * Return the name of the first entry point in the list
     *
     * NOTE: Since this will return whichever element appears first in the object,
     * it should only really be useful when we are trying to get ANY valid entry point.
     *
     * The above is exactly the use case for which this was created: When given a clearance
     * with a route that is invalid for the planned departure runway, we need to apply that
     * route using ANY runway which is valid. When the aircraft is taxiied to a runway and
     * cleared for takeoff, they will verify the procedure's compatibility with that runway.
     *
     * @for ProcedureModel
     * @method getFirstEntryPoint
     * @return {string}
     */

  }, {
    key: "getFirstEntryPoint",
    value: function getFirstEntryPoint() {
      var entryNames = Object.keys(this._entryPoints);

      if (entryNames.length === 0) {
        return null;
      }

      return entryNames[0];
    }
    /**
     * Return the name of the first entry point if there is exactly one entry point.
     *
     * @for ProcedureModel
     * @method getUniqueEntryPoint
     * @return {string}
     */

  }, {
    key: "getUniqueEntryPoint",
    value: function getUniqueEntryPoint() {
      var entryNames = Object.keys(this._entryPoints);

      if (entryNames.length !== 1) {
        return '';
      }

      return entryNames[0];
    }
    /**
    * Given an entry point and exit point, return a list of all applicable waypoints
    *
    * @for ProcedureModel
    * @method getWaypointModelsForEntryAndExit
    * @param entry {string} name of the requested entry point
    * @param exit {string} name of the requested exit point
    * @return {array<WaypointModel>}
    */

  }, {
    key: "getWaypointModelsForEntryAndExit",
    value: function getWaypointModelsForEntryAndExit(entry, exit) {
      if (!(entry in this._entryPoints)) {
        console.error("Expected valid entry of ".concat(this._icao, ", but received ").concat(entry));
        return;
      }

      if (!(exit in this._exitPoints)) {
        console.error("Expected valid exit of ".concat(this._icao, ", but received ").concat(exit));
        return;
      }

      var entryWaypointModels = this._generateWaypointsForEntry(entry);

      var bodyWaypointModels = this._generateWaypointsForBody();

      var exitWaypointModels = this._generateWaypointsForExit(exit);

      return [].concat(_toConsumableArray(entryWaypointModels), _toConsumableArray(bodyWaypointModels), _toConsumableArray(exitWaypointModels));
    }
    /**
     * Return whether this procedure contains an entry point with the specified name
     *
     * @for ProcedureModel
     * @method hasEntry
     * @return {boolean}
     */

  }, {
    key: "hasEntry",
    value: function hasEntry(entryName) {
      return entryName in this._entryPoints;
    }
    /**
     * Return whether this procedure contains an exit point with the specified name
     *
     * @for ProcedureModel
     * @method hasExit
     * @return {boolean}
     */

  }, {
    key: "hasExit",
    value: function hasExit(exitName) {
      return exitName in this._exitPoints;
    }
    /**
     * Returns whether this procedure is a SID
     *
     * @for ProcedureModel
     * @method isSid
     * @return {Boolean}
     */

  }, {
    key: "isSid",
    value: function isSid() {
      return this._procedureType === _routeConstants.PROCEDURE_TYPE.SID;
    }
    /**
     * Returns whether this procedure is a STAR
     *
     * @for ProcedureModel
     * @method isStar
     * @return {Boolean}
     */

  }, {
    key: "isStar",
    value: function isStar() {
      return this._procedureType === _routeConstants.PROCEDURE_TYPE.STAR;
    } // ------------------------------ PRIVATE ------------------------------

    /**
     * Generate a `WaypointModel` for the specified data
     *
     * @for ProcedureModel
     * @method _generateWaypoint
     * @param data {string|array<string>}
     * @returns {WaypointModel}
     * @private
     */

  }, {
    key: "_generateWaypoint",
    value: function _generateWaypoint(data) {
      var waypoint = new _WaypointModel["default"](data);

      var holdParameters = this._holdCollection.findHoldParametersByFix(waypoint.name);

      if (holdParameters != null) {
        waypoint.setDefaultHoldParameters(holdParameters);
      }

      return waypoint;
    }
    /**
    * Generate new `WaypointModel`s for the body portion of the procedure
    *
    * @for ProcedureModel
    * @method _generateWaypointsForBody
    * @return {array<WaypointModel>}
    * @private
    */

  }, {
    key: "_generateWaypointsForBody",
    value: function _generateWaypointsForBody() {
      var _this = this;

      return (0, _map2["default"])(this._body, function (waypoint) {
        return _this._generateWaypoint(waypoint);
      });
    }
    /**
    * Generate new `WaypointModel`s for the specified entry
    *
    * @for ProcedureModel
    * @method _generateWaypointsForEntry
    * @param entryPoint {string} name of the requested entry point
    * @return {array<WaypointModel>}
    * @private
    */

  }, {
    key: "_generateWaypointsForEntry",
    value: function _generateWaypointsForEntry(entryPoint) {
      var _this2 = this;

      if (!(entryPoint in this._entryPoints)) {
        throw new TypeError("Expected valid entry of ".concat(this._icao, ", but received ").concat(entryPoint));
      }

      return (0, _map2["default"])(this._entryPoints[entryPoint], function (waypoint) {
        return _this2._generateWaypoint(waypoint);
      });
    }
    /**
    * Generate new `WaypointModel`s for the specified exit
    *
    * @for ProcedureModel
    * @method _generateWaypointsForEntry
    * @param exitPoint {string} name of the requested exit point
    * @return {array<WaypointModel>}
    * @private
    */

  }, {
    key: "_generateWaypointsForExit",
    value: function _generateWaypointsForExit(exitPoint) {
      var _this3 = this;

      if (!(exitPoint in this._exitPoints)) {
        throw new TypeError("Expected valid exit of ".concat(this._icao, ", but received ").concat(exitPoint));
      }

      return (0, _map2["default"])(this._exitPoints[exitPoint], function (waypoint) {
        return _this3._generateWaypoint(waypoint);
      });
    }
    /**
     * Return an array containing names of all fixes existing in the body
     *
     * @for ProcedureModel
     * @method _getFixNamesFromBody
     * @return {array<string>}
     * @private
     */

  }, {
    key: "_getFixNamesFromBody",
    value: function _getFixNamesFromBody() {
      var _this4 = this;

      return (0, _map2["default"])(this._body, function (restrictedFix) {
        return _this4._getFixNameFromRestrictedFixArray(restrictedFix);
      });
    }
    /**
     * Return an array containing names of all fixes existing in the draw array
     *
     * @for ProcedureModel
     * @method _getFixNamesFromDraw
     * @return {array<string>}
     * @private
     */

  }, {
    key: "_getFixNamesFromDraw",
    value: function _getFixNamesFromDraw() {
      var drawFixNames = this._draw.reduce(function (fixList, lineSegment) {
        return fixList.concat(lineSegment);
      });

      var drawFixNamesWithoutAsterisks = drawFixNames.map(function (fixName) {
        return fixName.replace('*', '');
      });
      return drawFixNamesWithoutAsterisks;
    }
    /**
     * Return an array containing names of all fixes existing in any entry
     *
     * @for ProcedureModel
     * @method _getFixNamesFromEntries
     * @return {array<string>}
     * @private
     */

  }, {
    key: "_getFixNamesFromEntries",
    value: function _getFixNamesFromEntries() {
      var _this5 = this;

      var fixNames = [];
      (0, _forEach2["default"])(this._entryPoints, function (segment) {
        var fixesInSegment = (0, _map2["default"])(segment, function (restrictedFix) {
          return _this5._getFixNameFromRestrictedFixArray(restrictedFix);
        });
        fixNames = fixNames.concat(fixesInSegment);
      });
      return (0, _uniq2["default"])(fixNames);
    }
    /**
     * Return an array containing names of all fixes existing in any exit
     *
     * @for ProcedureModel
     * @method _getFixNamesFromExits
     * @return {array<string>}
     * @private
     */

  }, {
    key: "_getFixNamesFromExits",
    value: function _getFixNamesFromExits() {
      var _this6 = this;

      var fixNames = [];
      (0, _forEach2["default"])(this._exitPoints, function (segment) {
        var fixesInSegment = (0, _map2["default"])(segment, function (restrictedFix) {
          return _this6._getFixNameFromRestrictedFixArray(restrictedFix);
        });
        fixNames = fixNames.concat(fixesInSegment);
      });
      return (0, _uniq2["default"])(fixNames);
    }
    /**
     * Return the name of a fix from a restrited-fix array
     *
     * Ex:    ['FIXXA', 'A100']    -->    'FIXXA'
     *
     * @for ProcedureModel
     * @method _getFixNameFromRestrictedFixArray
     * @param restrictedFix {array<string>}
     * @return {string}
     * @private
     */

  }, {
    key: "_getFixNameFromRestrictedFixArray",
    value: function _getFixNameFromRestrictedFixArray(restrictedFix) {
      if ((0, _isArray2["default"])(restrictedFix)) {
        restrictedFix = restrictedFix[0];
      }

      if (restrictedFix.indexOf('#') !== -1) {
        return;
      }

      return restrictedFix.replace('^', '').replace('@', '');
    }
  }, {
    key: "draw",
    get: function get() {
      return this._draw;
    }
    /**
     * Return value of `#_icao`
     *
     * @for ProcedureModel
     * @property icao
     * @type {string}
     */

  }, {
    key: "icao",
    get: function get() {
      return this._icao;
    }
    /**
     * Return value of `#_name`
     *
     * @for ProcedureModel
     * @property name
     * @type {string}
     */

  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
    /**
     * Return value of `#_procedureType`
     *
     * @for ProcedureModel
     * @property procedureType
     * @type {string}
     */

  }, {
    key: "procedureType",
    get: function get() {
      return this._procedureType;
    }
    /**
     * Return value of `#_altitude`
     *
     * @for ProcedureModel
     * @property altitude
     * @type {number}
     */

  }, {
    key: "altitude",
    get: function get() {
      return this._altitude;
    }
  }]);

  return ProcedureModel;
}();

exports["default"] = ProcedureModel;

},{"../aircraft/FlightManagementSystem/WaypointModel":271,"../constants/routeConstants":314,"./HoldCollection":359,"lodash/forEach":199,"lodash/isArray":209,"lodash/isNil":219,"lodash/map":231,"lodash/random":237,"lodash/uniq":249}],363:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _aircraftCommandDefinitions = require("./aircraftCommandDefinitions");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * A definition of a specific command and it's arguments.
 *
 * Conatins a command name, which maps 1:1 with a name defined in `commandMap.js` and `commandDefinitions.js`.
 * Commands may have an alias or many, we care only about the root command. The command map will map any
 * alias to a root command and this `AircraftCommandModel` is only concerned about those root commands. It has
 * no way of knowing what the original alias was, if one was used.
 *
 * Each `AircraftCommandModel` will be expected to have, at a minimum, a `name` and a matching
 * `AIRCRAFT_COMMAND_DEFINITION`.
 *
 * @class AircraftCommandModel
 */
var AircraftCommandModel =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @for AircraftCommandModel
   */
  function AircraftCommandModel() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    _classCallCheck(this, AircraftCommandModel);

    /**
     * command name, should match a command in the COMMANDS constant
     *
     * @property name
     * @type {string}
     */
    this.name = name;
    /**
     * A reference to the AIRCRAFT_COMMAND_DEFINITION for this particular command.
     * this gives us access to both the `validate` and `parse` methods
     * that belong to this command.
     *
     * Storing this as an instance property allows us to do the lookup once
     * and then make it available to the rest of the class so it can
     * be referenced when needed.
     *
     * @property _commandDefinition
     * @type {object}
     * @private
     */

    this._commandDefinition = _aircraftCommandDefinitions.AIRCRAFT_COMMAND_DEFINITION[name];
    /**
     * list of command arguments
     *
     * - assumed to be the text command names
     * - may be empty, depending on the command
     * - should only ever be strings on initial set immediately after instantiation
     * - will later be parsed via the `_commandDefinition.parse()` method to the
     *   correct data types and shape
     *
     * @property args
     * @type {array}
     * @default []
     */

    this.args = []; // TODO: may need to throw here if `_commandDefinition` is undefined
  }
  /**
   * Return an array of [name, ...args]
   *
   * We use this shape solely to match the existing api.
   *
   * @property nameAndArgs
   * @return {array}
   */


  _createClass(AircraftCommandModel, [{
    key: "validateArgs",

    /**
     * Send the initial args off to the validator
     *
     * @for AircraftCommandModel
     * @method validateArgs
     * @return {string|undefined}
     */
    value: function validateArgs() {
      if (typeof this._commandDefinition === 'undefined') {
        return;
      }

      return this._commandDefinition.validate(this.args);
    }
    /**
     * Send the initial args, set from the `AircraftCommandParser` right after instantiation, off to
     * the parser for formatting.
     *
     * @for AircraftCommandModel
     * @method parseArgs
     */

  }, {
    key: "parseArgs",
    value: function parseArgs() {
      // this completely overwrites current args. this is intended because all args are received as
      // strings but consumed as strings, numbers or booleans. and when the args are initially set
      // they may not all be available yet
      this.args = this._commandDefinition.parse(this.args);
    }
  }, {
    key: "nameAndArgs",
    get: function get() {
      return [this.name].concat(_toConsumableArray(this.args));
    }
  }]);

  return AircraftCommandModel;
}();

exports["default"] = AircraftCommandModel;

},{"./aircraftCommandDefinitions":365}],364:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _compact2 = _interopRequireDefault(require("lodash/compact"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _tail2 = _interopRequireDefault(require("lodash/tail"));

var _AircraftCommandModel = _interopRequireDefault(require("./AircraftCommandModel"));

var _aircraftCommandMap = require("./aircraftCommandMap");

var _inputConstants = require("../../constants/inputConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Symbol used to split the command string as it enters the class.
 *
 * @property COMMAND_ARGS_SEPARATOR
 * @type {string}
 * @final
 */
var COMMAND_ARGS_SEPARATOR = ' ';
/**
 * This class is responsible for taking the content of the `$commandInput` and parsing it
 * out into commands and arguments.
 *
 * Everything this class needs comes in as a single string provided by `InputController.input_run()`.
 * ex:
 * - `timewarp 50`
 * - `AA777 fh 0270 d 050 sp 200`
 * - `AA777 hold dumba left 2min`
 *
 * **Differentiation of commands and arguments is determinied by splitting the string on an empty space. This
 * is very important, so legacy commands did not have spaces between the command and argument. With this
 * implementation _every_ command shall have a space between itself and it's arguments.**
 *
 * Commands are broken out into two categories: `System` and `Transmit`.
 * - System commands are zero or single argument commands that are used for interacting with the app
 *   itself. Things like `timewarp` or `tutorial` are examples of system commands.
 *
 * - Transmit commands are instructions meant for a specific aircraft within the controlled airspace.
 *   These commands can have zero to many arguments, depending on the command. Some examples of transmit
 *   commands are `to`, `taxi`, `hold`.
 *
 * Commands go through a lifecycle as they move from raw to parsed:
 * - user types command and presses enter
 * - command string is captured via input value, then passed as an argument to this class
 * - determine if command string is a `System Command` or `Transmit`
 * - creation of `AircraftCommandModel` objects for each command/argment group found
 * - validate command arguments (number of arguments and data type)
 * - parse command arguments
 *
 * All available commands are defined in the `commandMap`. Two terms of note are alias and root command.
 * We would call the `takeoff` command a root command and `to` and `cto` alises. The root command is the
 * one that shares the same key as the command definition which gives us the correct validator and parser.
 * The root command is also what the `AircraftModel` is expecting when it receives commands
 * from the `InputController`.
 *
 * @class AircraftCommandParser
 */

var AircraftCommandParser =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @for AircraftCommandParser
   * @param rawCommandWithArgs {string}  string present in the `$commandInput` when the user pressed `enter`
   */
  function AircraftCommandParser() {
    var rawCommandWithArgs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    _classCallCheck(this, AircraftCommandParser);

    if (!(0, _isString2["default"])(rawCommandWithArgs)) {
      // istanbul ignore next
      // eslint-disable-next-line max-len
      throw new TypeError("Invalid parameter. AircraftCommandParser expects a string but received ".concat(_typeof(rawCommandWithArgs)));
    }
    /**
     * Command name
     *
     * Could be either Transmit or a System command
     *
     * This is consumed by the `InputController` after parsing here and is used to
     * determine what to do with the parsed command(s)
     *
     * @type {string}
     * @default ''
     */


    this.command = '';
    /**
     * Aircraft callsign
     *
     * this is optional and not included with system commands
     *
     * @type {string}
     * @default ''
     */

    this.callsign = '';
    /**
     * List of `AircraftCommandModel` objects.
     *
     * Each command is contained within a `AircraftCommandModel`, even System commands. This provides
     * a consistent interface for obtaining commands and arguments (via getter) and also
     * aloows for easy implementation of the legacy API structure.
     *
     * @type {array<AircraftCommandModel>}
     */

    this.commandList = [];

    this._extractCommandsAndArgs(rawCommandWithArgs.toLowerCase());
  }
  /**
   * Return an array of [commandName, ...args]
   *
   * We use this shape solely to match the existing api.
   *
   * When command is a System command:
   * - commandList is assumed to have a length on 1
   * - commandList[0].args[0] is assumed to have a single string value
   *
   * @property args
   * @return {string|array<string>}
   */


  _createClass(AircraftCommandParser, [{
    key: "_extractCommandsAndArgs",

    /**
     * Accept the entire string provided to the constructor and attempt to break it up into:
     * - System command and its arguments
     * - Transmit commands and thier arguments
     *
     * @for AircraftCommandParser
     * @method _extractCommandsAndArgs
     * @param rawCommandWithArgs {string}
     * @private
     */
    value: function _extractCommandsAndArgs(rawCommandWithArgs) {
      var commandOrCallsignIndex = 0;
      var commandArgSegmentsWithCallsign = rawCommandWithArgs.split(COMMAND_ARGS_SEPARATOR);
      var callsignOrSystemCommandName = commandArgSegmentsWithCallsign[commandOrCallsignIndex]; // effectively a slice of the array that returns everything but the first item

      var commandArgSegments = (0, _tail2["default"])(commandArgSegmentsWithCallsign);

      if (this._isSystemCommand(callsignOrSystemCommandName)) {
        this._buildSystemCommandModel(commandArgSegmentsWithCallsign);

        return;
      }

      this._buildTransmitAircraftCommandModels(callsignOrSystemCommandName, commandArgSegments);
    }
    /**
     * Build a `AircraftCommandModel` for a System command then add that model to the `commandList`
     *
     * @for AircraftCommandParser
     * @method _buildSystemCommandModel
     * @private
     */

  }, {
    key: "_buildSystemCommandModel",
    value: function _buildSystemCommandModel(commandArgSegments) {
      var commandIndex = 0;
      var argIndex = 1;
      var commandName = commandArgSegments[commandIndex];
      var commandArgs = commandArgSegments[argIndex];
      var aircraftCommandModel = new _AircraftCommandModel["default"](commandName); // undefined will happen with zeroArgument system commands, so we check for that here
      // and add only when args are defined

      if (typeof commandArgs !== 'undefined') {
        aircraftCommandModel.args.push(commandArgs);
      }

      this.command = commandName;
      this.commandList.push(aircraftCommandModel);

      this._validateAndParseCommandArguments();
    }
    /**
     * Build `AircraftCommandModel` objects for each transmit commands then add them to the `commandList`
     *
     * @private
     */

  }, {
    key: "_buildTransmitAircraftCommandModels",
    value: function _buildTransmitAircraftCommandModels(callsignOrSystemCommandName, commandArgSegments) {
      this.command = _inputConstants.PARSED_COMMAND_NAME.TRANSMIT;
      this.callsign = callsignOrSystemCommandName;
      this.commandList = this._buildCommandList(commandArgSegments);

      this._validateAndParseCommandArguments();
    }
    /**
     * Loop through the commandArgSegments array and either create a new `AircraftCommandModel` or add
     * arguments to a `AircraftCommandModel`.
     *
     * commandArgSegments will contain both commands and arguments (very contrived example):
     * - `[cmd, arg, arg, cmd, cmd, arg, arg, arg]`
     *
     * this method is expecting that
     * the first item it receives, that is not a space, is a command. we then push each successive
     * array item to the args array until we find another command. then we repeat the process.
     *
     * this allows us to create several `AircraftCommandModel` with arguments and only loop over them once.
     *
     * @for AircraftCommandParser
     * @method _buildCommandList
     * @param commandArgSegments {array<string>}
     * @return {array<AircraftCommandModel>}
     * @private
     */

  }, {
    key: "_buildCommandList",
    value: function _buildCommandList(commandArgSegments) {
      var commandList = [];
      var aircraftCommandModel;

      for (var i = 0; i < commandArgSegments.length; i++) {
        var commandOrArg = commandArgSegments[i];

        if (commandOrArg === '') {
          continue;
        }

        var commandName = (0, _aircraftCommandMap.findCommandNameWithAlias)(commandOrArg);

        if (typeof aircraftCommandModel === 'undefined') {
          if (typeof commandName === 'undefined') {
            continue;
          }

          aircraftCommandModel = new _AircraftCommandModel["default"](commandName);
        } else {
          if (typeof commandName === 'undefined') {
            aircraftCommandModel.args.push(commandOrArg);
            continue;
          }

          commandList.push(aircraftCommandModel);
          aircraftCommandModel = new _AircraftCommandModel["default"](commandName);
        }
      } // add last command to array


      commandList.push(aircraftCommandModel);
      return (0, _compact2["default"])(commandList);
    }
    /**
     * Fire off the `_validateCommandArguments` method and throws any errors returned
     *
     * @for AircraftCommandParser
     * @method _validateAndParseCommandArguments
     * @private
     */

  }, {
    key: "_validateAndParseCommandArguments",
    value: function _validateAndParseCommandArguments() {
      var validationErrors = this._validateCommandArguments();

      if (validationErrors.length > 0) {
        (0, _forEach2["default"])(validationErrors, function (error) {
          throw error;
        });
      }
    }
    /**
     * For each `AircraftCommandModel` in the `commandList`, first validate it's arguments
     * then parse those arguments into a consumable array.
     *
     * @for AircraftCommandParser
     * @method _validateCommandArguments
     * @private
     */

  }, {
    key: "_validateCommandArguments",
    value: function _validateCommandArguments() {
      var validatedCommandList = (0, _map2["default"])(this.commandList, function (command) {
        if (typeof command === 'undefined') {
          return null;
        }

        var errorMessage = command.validateArgs();

        if (errorMessage) {
          // we only return here so all the errors can be thrown at once
          // from within the calling method
          return errorMessage;
        }

        command.parseArgs();
      });
      return (0, _compact2["default"])(validatedCommandList);
    }
    /**
     * Encapsulation of boolean logic used to determine if the `callsignOrSystemCommandName`
     * is in fact a system command.
     *
     *
     * @for AircraftCommandParser
     * @method _isSystemCommand
     * @param callsignOrSystemCommandName {string}
     * @return {boolean}
     */

  }, {
    key: "_isSystemCommand",
    value: function _isSystemCommand(callsignOrSystemCommandName) {
      var command = _aircraftCommandMap.AIRCRAFT_COMMAND_MAP[callsignOrSystemCommandName];

      if (typeof command === 'undefined') {
        return false;
      }

      return command.isSystemCommand && callsignOrSystemCommandName !== _inputConstants.PARSED_COMMAND_NAME.TRANSMIT;
    }
  }, {
    key: "args",
    get: function get() {
      if (this.command !== _inputConstants.PARSED_COMMAND_NAME.TRANSMIT) {
        return this.commandList[0].args;
      }

      return (0, _map2["default"])(this.commandList, function (command) {
        return command.nameAndArgs;
      });
    }
  }]);

  return AircraftCommandParser;
}();

exports["default"] = AircraftCommandParser;

},{"../../constants/inputConstants":311,"./AircraftCommandModel":363,"./aircraftCommandMap":366,"lodash/compact":184,"lodash/forEach":199,"lodash/isString":224,"lodash/map":231,"lodash/tail":243}],365:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AIRCRAFT_COMMAND_DEFINITION = void 0;

var _unitConverters = require("../../utilities/unitConverters");

var _argumentValidators = require("./argumentValidators");

var _argumentParsers = require("./argumentParsers");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * A no-op function used for command definitions that do not need a parser
 *
 * This function will immediately return any arguments passed to it and is
 * used in place of an actual parser. this way `command.parse` can still
 * be called even with commands that don't need to be parsed.
 *
 * @function noop
 * @param args {*}
 * @return {*}
 */
var noop = function noop(args) {
  return args;
};
/**
 * System and Aircraft command definitions that accept zero arguments
 *
 * @property ZERO_ARG_AIRCRAFT_COMMANDS
 * @type {Object}
 * @final
 */


var ZERO_ARG_AIRCRAFT_COMMANDS = {
  // system commands
  airac: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  auto: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  clear: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  pause: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  tutorial: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  // Aircraft commands
  abort: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  clearedAsFiled: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  debug: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  "delete": {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  flyPresentHeading: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  takeoff: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  sayAltitude: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  sayAssignedAltitude: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  sayHeading: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  sayAssignedHeading: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  sayIndicatedAirspeed: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  },
  sayAssignedSpeed: {
    validate: _argumentValidators.zeroArgumentsValidator,
    parse: noop
  }
};
/**
 * System and Aircraft commands that accept a single argument
 *
 * these commands accept a single argument and may require further parsing, eg: (string -> number)
 *
 * @property SINGLE_ARG_AIRCRAFT_COMMANDS
 * @type {Object}
 * @final
 */

var SINGLE_ARG_AIRCRAFT_COMMANDS = {
  '`': {
    validate: _argumentValidators.singleArgumentValidator,
    // calling method is expecting an array with values that will get spread later, thus we purposly
    // return an array here
    parse: function parse(args) {
      return [(0, _unitConverters.convertStringToNumber)(args)];
    }
  },
  airport: {
    validate: _argumentValidators.singleArgumentValidator,
    parse: noop
  },
  direct: {
    validate: _argumentValidators.singleArgumentValidator,
    parse: noop
  },
  expectArrivalRunway: {
    validate: _argumentValidators.singleArgumentValidator,
    parse: noop
  },
  ils: {
    validate: _argumentValidators.singleArgumentValidator,
    // TODO: split this out to custom parser once the null value is defined
    parse: function parse(args) {
      return [null, args[0]];
    }
  },
  land: {
    validate: _argumentValidators.zeroOrOneArgumentValidator,
    parse: noop
  },
  moveDataBlock: {
    validate: _argumentValidators.singleArgumentValidator,
    parse: noop
  },
  rate: {
    validate: _argumentValidators.singleArgumentValidator,
    // calling method is expecting an array with values that will get spread later, thus we purposly
    // return an array here
    parse: function parse(args) {
      return [(0, _unitConverters.convertStringToNumber)(args)];
    }
  },
  reroute: {
    validate: _argumentValidators.singleArgumentValidator,
    parse: noop
  },
  route: {
    validate: _argumentValidators.singleArgumentValidator,
    parse: noop
  },
  sid: {
    validate: _argumentValidators.singleArgumentValidator,
    parse: noop
  },
  speed: {
    validate: _argumentValidators.singleArgumentValidator,
    // calling method is expecting an array with values that will get spread later, thus we purposly
    // return an array here
    parse: function parse(arg) {
      return [(0, _unitConverters.convertStringToNumber)(arg)];
    }
  },
  star: {
    validate: _argumentValidators.singleArgumentValidator,
    parse: noop
  }
};
/**
 * System and Aircraft commands that accept arguments specific to the command
 *
 * These definitions will likely reference functions for validate and parse that are specific only
 * to one command
 *
 * @property CUSTOM_ARG_AIRCRAFT_COMMANDS
 * @type {Object}
 * @final
 */

var CUSTOM_ARG_AIRCRAFT_COMMANDS = {
  taxi: {
    validate: _argumentValidators.zeroOrOneArgumentValidator,
    parse: noop
  },
  cancelHold: {
    validate: _argumentValidators.zeroOrOneArgumentValidator,
    parse: noop
  },
  // these commands have specific argument requirements and may need to be parsed
  // into the correct type (sting -> number)
  altitude: {
    validate: _argumentValidators.altitudeValidator,
    parse: _argumentParsers.altitudeParser
  },
  cross: {
    validate: _argumentValidators.crossingValidator,
    parse: _argumentParsers.crossingParser
  },
  fix: {
    validate: _argumentValidators.fixValidator,
    parse: noop
  },
  heading: {
    validate: _argumentValidators.headingValidator,
    parse: _argumentParsers.headingParser
  },
  hold: {
    validate: _argumentValidators.holdValidator,
    parse: _argumentParsers.holdParser
  },
  squawk: {
    validate: _argumentValidators.squawkValidator,
    parse: noop
  },
  timewarp: {
    validate: _argumentValidators.zeroOrOneArgumentValidator,
    parse: _argumentParsers.timewarpParser
  },
  descendViaStar: {
    validate: _argumentValidators.optionalAltitudeValidator,
    parse: _argumentParsers.optionalAltitudeParser
  },
  climbViaSid: {
    validate: _argumentValidators.optionalAltitudeValidator,
    parse: _argumentParsers.optionalAltitudeParser
  }
}; // TODO: This entire thing ought to be absorbed into aircraftCommandMap, to keep
// all command definition information in a single place.

/**
 * Single exported constant that combines all the definitions above
 *
 * @property AIRCRAFT_COMMAND_DEFINITION
 * @type {Object}
 * @final
 */

var AIRCRAFT_COMMAND_DEFINITION = _objectSpread({}, ZERO_ARG_AIRCRAFT_COMMANDS, SINGLE_ARG_AIRCRAFT_COMMANDS, CUSTOM_ARG_AIRCRAFT_COMMANDS);

exports.AIRCRAFT_COMMAND_DEFINITION = AIRCRAFT_COMMAND_DEFINITION;

},{"../../utilities/unitConverters":391,"./argumentParsers":368,"./argumentValidators":369}],366:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findCommandNameWithAlias = findCommandNameWithAlias;
exports.EXPEDITE = exports.AIRCRAFT_COMMAND_MAP = void 0;

var _findKey2 = _interopRequireDefault(require("lodash/findKey"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Complete map of commands
 *
 * This list includes both System and Unicode commands, as well as all the various aircraft
 * commands.
 *
 * Aliased commands map to a single root command that is shared among all aliases. The values
 * here then map to a `AIRCRAFT_COMMAND_DEFINITION` which contains `validate` and `parse` functions for
 * each root command. Some commands have very unique demands for how arguments are formatted,
 * those functions let us do that on a case by case basis.
 *
 * Keys are lowercased here so they can be accessed programatically using input string segments
 * that are converted to lowercase for ease of comparison.
 *
 * @propery AIRCRAFT_COMMAND_MAP
 * @type {Object}
 * @final
 */
var AIRCRAFT_COMMAND_MAP = {
  abort: {
    aliases: ['abort'],
    functionName: 'runAbort',
    isSystemCommand: false
  },
  airac: {
    aliases: ['airac'],
    functionName: '',
    isSystemCommand: true
  },
  airport: {
    aliases: ['airport'],
    functionName: '',
    isSystemCommand: true
  },
  altitude: {
    aliases: ['a', 'altitude', 'c', 'climb', 'd', 'descend'],
    functionName: 'runAltitude',
    isSystemCommand: false
  },
  auto: {
    aliases: ['auto'],
    functionName: '',
    isSystemCommand: true
  },
  clear: {
    aliases: ['clear'],
    functionName: '',
    isSystemCommand: true
  },
  clearedAsFiled: {
    aliases: ['caf', 'clearedAsFiled'],
    functionName: 'runClearedAsFiled',
    isSystemCommand: false
  },
  climbViaSid: {
    aliases: ['climbViaSid', 'cvs'],
    functionName: 'runClimbViaSID',
    isSystemCommand: false
  },
  cross: {
    aliases: ['cross', 'cr', 'x'],
    functionName: 'runCross',
    isSystemCommand: false
  },
  "delete": {
    aliases: ['del', 'delete', 'kill'],
    functionName: 'runDelete',
    isSystemCommand: false
  },
  descendViaStar: {
    aliases: ['descendViaStar', 'dvs'],
    functionName: 'runDescendViaStar',
    isSystemCommand: false
  },
  direct: {
    aliases: ['dct', 'direct', 'pd'],
    functionName: 'runDirect',
    isSystemCommand: false
  },
  cancelHold: {
    aliases: ['exithold', 'cancelhold', 'continue', 'nohold', 'xh'],
    functionName: 'runCancelHoldingPattern',
    isSystemCommand: false
  },
  expectArrivalRunway: {
    aliases: ['e'],
    functionName: 'runExpectArrivalRunway',
    isSystemCommand: false
  },
  fix: {
    aliases: ['f', 'fix', 'track'],
    functionName: 'runFix',
    isSystemCommand: false
  },
  flyPresentHeading: {
    aliases: ['fph'],
    functionName: 'runFlyPresentHeading',
    isSystemCommand: false
  },
  heading: {
    aliases: ['fh', 'h', 'heading', 't', 'turn'],
    functionName: 'runHeading',
    isSystemCommand: false
  },
  hold: {
    aliases: ['hold'],
    functionName: 'runHold',
    isSystemCommand: false
  },
  ils: {
    aliases: ['*', 'i', 'ils'],
    functionName: 'runIls',
    isSystemCommand: false
  },
  land: {
    aliases: ['land'],
    functionName: 'runLand',
    isSystemCommand: false
  },
  moveDataBlock: {
    aliases: ['`'],
    functionName: 'runMoveDataBlock',
    isSystemCommand: false
  },
  pause: {
    aliases: ['pause'],
    functionName: '',
    isSystemCommand: true
  },
  rate: {
    aliases: ['rate'],
    functionName: '',
    isSystemCommand: true
  },
  reroute: {
    aliases: ['reroute', 'rr'],
    functionName: 'runReroute',
    isSystemCommand: false
  },
  route: {
    aliases: ['route'],
    functionName: 'runRoute',
    isSystemCommand: false
  },
  sayAltitude: {
    aliases: ['sa'],
    functionName: 'runSayAltitude',
    isSystemCommand: false
  },
  sayAssignedAltitude: {
    aliases: ['saa'],
    functionName: 'runSayAssignedAltitude',
    isSystemCommand: false
  },
  sayAssignedHeading: {
    aliases: ['sah'],
    functionName: 'runSayAssignedHeading',
    isSystemCommand: false
  },
  sayAssignedSpeed: {
    aliases: ['sas'],
    functionName: 'runSayAssignedSpeed',
    isSystemCommand: false
  },
  sayHeading: {
    aliases: ['sh'],
    functionName: 'runSayHeading',
    isSystemCommand: false
  },
  sayIndicatedAirspeed: {
    aliases: ['si'],
    functionName: 'runSayIndicatedAirspeed',
    isSystemCommand: false
  },
  sayRoute: {
    aliases: ['sr'],
    functionName: 'runSayRoute',
    isSystemCommand: false
  },
  sid: {
    aliases: ['sid'],
    functionName: 'runSID',
    isSystemCommand: false
  },
  speed: {
    aliases: ['-', '+', 'slow', 'sp', 'speed'],
    functionName: 'runSpeed',
    isSystemCommand: false
  },
  squawk: {
    aliases: ['sq', 'squawk'],
    functionName: 'runSquawk',
    isSystemCommand: false
  },
  star: {
    aliases: ['star'],
    functionName: 'runSTAR',
    isSystemCommand: false
  },
  takeoff: {
    aliases: ['cto', 'to', 'takeoff'],
    functionName: 'runTakeoff',
    isSystemCommand: false
  },
  taxi: {
    aliases: ['taxi', 'w', 'wait'],
    functionName: 'runTaxi',
    isSystemCommand: false
  },
  timewarp: {
    aliases: ['timewarp'],
    functionName: '',
    isSystemCommand: true
  },
  transmit: {
    aliases: ['transmit'],
    functionName: '',
    isSystemCommand: true
  },
  tutorial: {
    aliases: ['tutorial'],
    functionName: '',
    isSystemCommand: true
  }
};
/**
 * @property EXPEDITE
 * @type {array}
 * @final
 */

exports.AIRCRAFT_COMMAND_MAP = AIRCRAFT_COMMAND_MAP;
var EXPEDITE = ['expedite', 'ex'];
/**
 * Get the name of a command when given any of that command's aliases
 *
 * @function findCommandNameWithAlias
 * @param commandAlias {string}
 * @return {string}
 */

exports.EXPEDITE = EXPEDITE;

function findCommandNameWithAlias(commandAlias) {
  return (0, _findKey2["default"])(AIRCRAFT_COMMAND_MAP, function (command) {
    return command.aliases.indexOf(commandAlias) !== -1;
  });
}

},{"lodash/findKey":193}],367:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERROR_MESSAGE = void 0;

/* eslint-disable max-len */

/**
 * @property INVALID_ARG
 * @type {string}
 * @final
 */
var INVALID_ARG = 'Invalid argument';
/**
 * @property INVALID_ARG_LENGTH
 * @type {string}
 * @final
 */

var INVALID_ARG_LENGTH = "".concat(INVALID_ARG, " length");
/**
 * Encapsulation of error messaging used with `argumentValidators` functions
 *
 * @property ERROR_MESSAGE
 * @type {Object}
 * @final
 */

var ERROR_MESSAGE = {
  ZERO_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected exactly zero arguments"),
  SINGLE_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected exactly one argument"),
  TWO_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected exactly two arguments"),
  THREE_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected exactly three arguments"),
  ZERO_OR_ONE_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected zero or one argument"),
  ZERO_TO_THREE_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected zero to three arguments"),
  ZERO_TO_FOUR_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected zero to four arguments"),
  ONE_OR_MORE_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected one or more arguments"),
  ONE_OR_TWO_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected one or two arguments"),
  ONE_TO_THREE_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected one, two, or three arguments"),
  ONE_OR_THREE_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected one or three arguments"),
  TWO_OR_THREE_ARG_LENGTH: "".concat(INVALID_ARG_LENGTH, ". Expected two or three arguments"),
  ALTITUDE_EXPEDITE_ARG: "".concat(INVALID_ARG, ". Altitude accepts only \"expedite\" or \"ex\" as a second argument"),
  ALTITUDE_MUST_BE_NUMBER: "".concat(INVALID_ARG, ". Altitude must be a number"),
  SPEED_MUST_BE_NUMBER: "".concat(INVALID_ARG, ". Speed must be a number"),
  HEADING_MUST_BE_NUMBER: "".concat(INVALID_ARG, ". Heading must be a number"),
  HEADING_MUST_BE_VALID_COURSE: "".concat(INVALID_ARG, ". Heading must be between 001 and 360"),
  INCREMENTAL_HEADING_MUST_BE_POSITIVE: "".concat(INVALID_ARG, ". Incremental heading must be positive"),
  MUST_BE_STRING: "".concat(INVALID_ARG, ". Must be a string"),
  INVALID_DIRECTION_STRING: "".concat(INVALID_ARG, ". Expected one of 'left / l / right / r' as the first argument when passed three arguments"),
  HEADING_ACCEPTS_BOOLEAN_AS_THIRD_ARG: "".concat(INVALID_ARG, ". Heading accepts a boolean for the third argument when passed three arguments"),
  INVALID_SQUAWK: "".concat(INVALID_ARG, ". Expected '0000'-'7777' for the transponder code.")
};
exports.ERROR_MESSAGE = ERROR_MESSAGE;

},{}],368:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.crossingParser = exports.timewarpParser = exports.holdParser = exports.findHoldCommandByType = exports.isLegLengthArg = exports.headingParser = exports.directionNormalizer = exports.optionalAltitudeParser = exports.altitudeParser = void 0;

var _defaultTo2 = _interopRequireDefault(require("lodash/defaultTo"));

var _argumentValidators = require("./argumentValidators");

var _globalConstants = require("../../constants/globalConstants");

var _unitConverters = require("../../utilities/unitConverters");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Enumeration of possible the hold command argument names.
 *
 * Enumerated here base these nanes are shared accross several functions and this
 * provides a single source of truth.
 *
 * @property HOLD_COMMAND_ARG_NAMES
 * @type {Object}
 * @final
 */
var HOLD_COMMAND_ARG_NAMES = {
  TURN_DIRECTION: 'turnDirection',
  LEG_LENGTH: 'legLength',
  FIX_NAME: 'fixName',
  RADIAL: 'radial'
};
/**
 * Converts a flight level altitude to a number in thousands and converts second arg to a boolean
 *
 * @function altitudeParser
 * @param args {array}
 * @return {array<number, boolean>}
 */

var altitudeParser = function altitudeParser(args) {
  var altitude = (0, _unitConverters.convertToThousands)(args[0]); // the validator will have already caught an invalid value here. if one exists, it is assumed to be valid and
  // thus we return true. otherwise its false

  var shouldExpedite = typeof args[1] !== 'undefined';
  return [altitude, shouldExpedite];
};
/**
 * Converts a flight level altitude to a number in thousands if available
 *
 * @function optionalAltitudeParser
 * @param args {array}
 * @return {array<number>}
 */


exports.altitudeParser = altitudeParser;

var optionalAltitudeParser = function optionalAltitudeParser(args) {
  return args.length !== 0 ? [(0, _unitConverters.convertToThousands)(args[0])] : [];
};
/**
 * Accepts a direction string:
 * - `left / l / right / r`
 *
 * and returns `left / right`
 *
 * @function directionNormalizer
 * @param direction {string}
 * @return normalizedDirection {string}
 */


exports.optionalAltitudeParser = optionalAltitudeParser;

var directionNormalizer = function directionNormalizer(direction) {
  var normalizedDirection = direction;

  if (direction === 'l') {
    normalizedDirection = 'left';
  } else if (direction === 'r') {
    normalizedDirection = 'right';
  }

  return normalizedDirection;
};
/**
 * Returns a consistent array with the same shape no matter the number of arguments received
 *
 * Converts a flight level altitude to a number in thousands and converts second arg to a boolean
 *
 * @function headingParser
 * @param args {array}
 * @return {array<string, number, boolean>}
 */


exports.directionNormalizer = directionNormalizer;

var headingParser = function headingParser(args) {
  var direction;
  var heading;
  var isIncremental = false;

  switch (args.length) {
    case 1:
      // existing api is expeting undefined values to be exactly null
      direction = null;
      heading = (0, _unitConverters.convertStringToNumber)(args[0]);
      return [direction, heading, isIncremental];

    case 2:
      isIncremental = args[1].length === 2 || args[1].length === 1;
      direction = directionNormalizer(args[0]);
      heading = (0, _unitConverters.convertStringToNumber)(args[1]);
      return [direction, heading, isIncremental];

    default:
      throw new Error('An error ocurred parsing the Heading arguments');
  }
};
/**
 * Abstracted boolean logic used to detmine if a string contains `min` or `nm`.
 *
 * This is useful specifically with the `findHoldCommandByType`.
 *
 * @function isLegLengthArg
 * @param arg {string}
 * @return {boolean}
 */


exports.headingParser = headingParser;

var isLegLengthArg = function isLegLengthArg(arg) {
  return _globalConstants.REGEX.HOLD_DISTANCE.test(arg);
};
/**
 * Given a type and an argument list, find the first occurance of `type` from within the argument list.
 *
 * We are looking for one of three things here:
 * - `turnDirection` - a variation of left or right
 * - `legLength` - length of hold leg in either minutes (min) or nautical miles (nm)
 * - `fixName` - assumed to be a string that isn't a `turnDirection` or `legLength`. The parser has no way of
 *               knowing if a certain string is an actual `fixName`. We can only determine that it isn't a
 *               `turnDirection` or `legLength`. This will error from within the `runHold` method if the
 *               `fixName` is not valid.
 *
 * @function findHoldCommandByType
 * @param type {HOLD_COMMAND_ARG_NAMES}
 * @param args {array}
 * @return {string|null}
 */


exports.isLegLengthArg = isLegLengthArg;

var findHoldCommandByType = function findHoldCommandByType(type, args) {
  for (var i = 0; i < args.length; i++) {
    var arg = args[i];

    switch (type) {
      case HOLD_COMMAND_ARG_NAMES.TURN_DIRECTION:
        if (!(0, _argumentValidators.isValidDirectionString)(arg)) {
          continue;
        } // make sure we return only `left` or `right`


        return directionNormalizer(arg);

      case HOLD_COMMAND_ARG_NAMES.LEG_LENGTH:
        if (!isLegLengthArg(arg)) {
          continue;
        }

        return arg;

      case HOLD_COMMAND_ARG_NAMES.FIX_NAME:
        if ((0, _argumentValidators.isValidDirectionString)(arg) || isLegLengthArg(arg)) {
          continue;
        }

        return arg;

      case HOLD_COMMAND_ARG_NAMES.RADIAL:
        if (!(0, _argumentValidators.isValidCourseString)(arg)) {
          continue;
        }

        return (0, _unitConverters.convertStringToNumber)(arg);

      default:
        return null;
    }
  }

  return null;
}; // TODO: This duplicates work being done with initializing WaypointModel._holdParameters
//        We must determine how best to achieve this and remove the duplicated effort.

/**
 * The `hold` command accepts arguments in any order thus, we use the `findHoldCommandByType` helper
 * method to do that for us. This provides an easy way tp find the correct argument, no matter the order,
 * and consistently return an array of the same shape.
 *
 * @function holdParser
 * @param args {array}
 * @return {array<string>}
 */


exports.findHoldCommandByType = findHoldCommandByType;

var holdParser = function holdParser(args) {
  // existing api is expeting undefined values to be exactly null
  var fixName = findHoldCommandByType(HOLD_COMMAND_ARG_NAMES.FIX_NAME, args);
  var turnDirection = (0, _defaultTo2["default"])(findHoldCommandByType(HOLD_COMMAND_ARG_NAMES.TURN_DIRECTION, args), null);
  var legLength = (0, _defaultTo2["default"])(findHoldCommandByType(HOLD_COMMAND_ARG_NAMES.LEG_LENGTH, args), null);
  var radial = (0, _defaultTo2["default"])(findHoldCommandByType(HOLD_COMMAND_ARG_NAMES.RADIAL, args), null);
  return [turnDirection, legLength, fixName, radial];
};
/**
 * the `timewarp` command needs to be able to provide a default value,
 * this parser allows us to do that.
 *
 * @function timewarpParser
 * @param  {array|undefined} [args=[]]
 * @return {array<number>}
 */


exports.holdParser = holdParser;

var timewarpParser = function timewarpParser() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var defaultTimewarpValue = 1;

  if (args.length === 0) {
    return [defaultTimewarpValue];
  } // calling method is expecting an array with values that will get spread later, thus we purposly
  // return an array here


  return [(0, _unitConverters.convertStringToNumber)(args[0])];
};
/**
 * Convert the altitude argument from flight level number (i.e. 180) to feet in thousands (i.e. 18000).
 *
 * @function crossingParser
 * @param  args {array} [fix name, altitude]
 * @return {array<string, number>}
 */


exports.timewarpParser = timewarpParser;

var crossingParser = function crossingParser() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var fix = args[0];
  var altitude;
  var speed; // Set i to 1 to skip fixName

  for (var i = 1; i < args.length; i++) {
    if (args[i][0].toLowerCase() === 'a') {
      altitude = (0, _unitConverters.convertToThousands)(args[i].toString().substr(1));
    } else if (args[i][0].toLowerCase() === 's') {
      speed = (0, _unitConverters.convertStringToNumber)(args[i].toString().substr(1));
    }
  }

  return [fix, altitude, speed];
};

exports.crossingParser = crossingParser;

},{"../../constants/globalConstants":310,"../../utilities/unitConverters":391,"./argumentValidators":369,"lodash/defaultTo":187}],369:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.crossingValidator = exports.squawkValidator = exports.holdValidator = exports.headingValidator = exports.isValidDirectionString = exports.isValidCourseString = exports.fixValidator = exports.optionalAltitudeValidator = exports.altitudeValidator = exports.twoOrThreeArgumentsValidator = exports.oneOrThreeArgumentsValidator = exports.oneToThreeArgumentsValidator = exports.oneOrTwoArgumentValidator = exports.zeroOrOneArgumentValidator = exports.singleArgumentValidator = exports.zeroArgumentsValidator = void 0;

var _isNaN2 = _interopRequireDefault(require("lodash/isNaN"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _unitConverters = require("../../utilities/unitConverters");

var _aircraftCommandMap = require("./aircraftCommandMap");

var _aircraftCommandParserMessages = require("./aircraftCommandParserMessages");

var _globalConstants = require("../../constants/globalConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Check that `args` has exactly zero values
 *
 * @function zeroArgumentsValidator
 * @param args {array}
 * @return {string|undefined}
 */
var zeroArgumentsValidator = function zeroArgumentsValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (args.length !== 0) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.ZERO_ARG_LENGTH;
  }
};
/**
 * Checks that `args` has exactly one value
 *
 * @function singleArgumentValidator
 * @param args {array}
 * @return {string|undefined}
 */


exports.zeroArgumentsValidator = zeroArgumentsValidator;

var singleArgumentValidator = function singleArgumentValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (args.length !== 1) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.SINGLE_ARG_LENGTH;
  }
};
/**
 * Checks that `args` has exactly zero or one value
 *
 * @function zeroOrOneArgumentValidator
 * @param args {array}
 * @return {string|undefined}
 */


exports.singleArgumentValidator = singleArgumentValidator;

var zeroOrOneArgumentValidator = function zeroOrOneArgumentValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (args.length > 1) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.ZERO_OR_ONE_ARG_LENGTH;
  }
};
/**
 * Checks that `args` has exactly one or two values
 *
 * @function oneOrTwoArgumentValidator
 * @param args {array}
 * @return {string|undefined}
 */


exports.zeroOrOneArgumentValidator = zeroOrOneArgumentValidator;

var oneOrTwoArgumentValidator = function oneOrTwoArgumentValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (args.length < 1 || args.length > 2) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.ONE_OR_TWO_ARG_LENGTH;
  }
};
/**
 * Checks that `args` has exactly one, two or three values
 *
 * @function oneToThreeArgumentsValidator
 * @param args {array}
 * @return {string|undefined}
 */


exports.oneOrTwoArgumentValidator = oneOrTwoArgumentValidator;

var oneToThreeArgumentsValidator = function oneToThreeArgumentsValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (args.length === 0 || args.length > 3) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.ONE_TO_THREE_ARG_LENGTH;
  }
};
/**
 * Checks that `args` has exactly one or three values
 *
 * @function oneOrThreeArgumentsValidator
 * @param args {array}
 * @return {string|undefined}
 */


exports.oneToThreeArgumentsValidator = oneToThreeArgumentsValidator;

var oneOrThreeArgumentsValidator = function oneOrThreeArgumentsValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (args.length !== 1 && args.length !== 3) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.ONE_OR_THREE_ARG_LENGTH;
  }
};
/**
 * Checks that `args` has exactly two or three values
 *
 * @function twoOrThreeArgumentsValidator
 * @param args {array}
 * @return {string|undefined}
 */


exports.oneOrThreeArgumentsValidator = oneOrThreeArgumentsValidator;

var twoOrThreeArgumentsValidator = function twoOrThreeArgumentsValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (args.length !== 2 && args.length !== 3) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.TWO_OR_THREE_ARG_LENGTH;
  }
};
/**
 * Checks that args is the required length and the data is of the correct type
 *
 * ```
 * Allowed argument shapes:
 * - ['030']
 * - ['030', 'expedite']
 * - ['030', 'ex']
 * ```
 *
 * @function altitudeValidator
 * @param args {array}
 * @return {string|undefined}
 */


exports.twoOrThreeArgumentsValidator = twoOrThreeArgumentsValidator;

var altitudeValidator = function altitudeValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var hasLengthError = oneOrTwoArgumentValidator(args);

  if (hasLengthError) {
    return hasLengthError;
  }

  var numberFromString = (0, _unitConverters.convertStringToNumber)(args[0]);

  if ((0, _isNaN2["default"])(numberFromString)) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.ALTITUDE_MUST_BE_NUMBER;
  }

  if (args.length === 2 && _aircraftCommandMap.EXPEDITE.indexOf(args[1]) === _globalConstants.INVALID_INDEX) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.ALTITUDE_EXPEDITE_ARG;
  }
};
/**
 * Checks that there is exactly zero or one value and the data is of the correct type
 *
 * ```
 * Allowed argument shapes:
 * - ['030']
 * ```
 *
 * @function optionalAltitudeValidator
 * @param args {array}
 * @return {string|undefined}
 */


exports.altitudeValidator = altitudeValidator;

var optionalAltitudeValidator = function optionalAltitudeValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var hasLengthError = zeroOrOneArgumentValidator(args);

  if (hasLengthError) {
    return hasLengthError;
  }

  if (args.length !== 0) {
    return altitudeValidator(args);
  }
};
/**
 * Verifies a list of fix names are all strings and that there is at least one
 *
 * @function fixValidator
 * @param args {array}
 * @return {array<string>}
 */


exports.optionalAltitudeValidator = optionalAltitudeValidator;

var fixValidator = function fixValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var hasTypeError;

  if (args.length < 1) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.ONE_OR_MORE_ARG_LENGTH;
  }

  (0, _forEach2["default"])(args, function (arg) {
    if (!(0, _isString2["default"])(arg) && !hasTypeError) {
      hasTypeError = _aircraftCommandParserMessages.ERROR_MESSAGE.MUST_BE_STRING;
    }
  });

  if (hasTypeError) {
    return hasTypeError;
  }
};
/**
 * Tests if value is exactly a 3 digit decimal number
 * between 001 and 360
 *
 * @function isValidCourseString
 * @param value {string}
 * @returns {boolean}
 */


exports.fixValidator = fixValidator;

var isValidCourseString = function isValidCourseString(value) {
  // Can't rely on parseInt/convertStringToNumber as it'll parse 1min => 1
  if (!_globalConstants.REGEX.THREE_DIGIT_NUMBER.test(value)) {
    return false;
  }

  var course = (0, _unitConverters.convertStringToNumber)(value);
  return course >= 1 && course <= 360;
};
/**
 * Returns true if value is one of `left / l / right / r`
 *
 * @function isValidDirectionString
 * @param value {string}
 * @return {boolean}
 */


exports.isValidCourseString = isValidCourseString;

var isValidDirectionString = function isValidDirectionString(value) {
  return value === 'left' || value === 'l' || value === 'right' || value === 'r';
};
/**
 * Checks that args is the required length and the data is of the correct type for the number of arguments
 *
 * ```
 * Allowed arguments shapes:
 * - ['180']
 * - ['left', '180']
 * - ['l', '180']
 * - ['left', '80']
 * - ['l', '80']
 * ```
 *
 * @function headingValidator
 * @param args {array}
 * @return {string|undefined}
 */


exports.isValidDirectionString = isValidDirectionString;

var headingValidator = function headingValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var length = args.length;
  var hasLengthError = oneOrTwoArgumentValidator(args);
  var numberFromString;

  if (hasLengthError) {
    return hasLengthError;
  }

  switch (length) {
    case 1:
      if (!isValidCourseString(args[0])) {
        return _aircraftCommandParserMessages.ERROR_MESSAGE.HEADING_MUST_BE_VALID_COURSE;
      }

      break;

    case 2:
      numberFromString = (0, _unitConverters.convertStringToNumber)(args[1]);

      if (!isValidDirectionString(args[0])) {
        return _aircraftCommandParserMessages.ERROR_MESSAGE.INVALID_DIRECTION_STRING;
      }

      if (args[1].length === 3 && !isValidCourseString(args[1])) {
        return _aircraftCommandParserMessages.ERROR_MESSAGE.HEADING_MUST_BE_VALID_COURSE;
      }

      if ((0, _isNaN2["default"])(numberFromString)) {
        return _aircraftCommandParserMessages.ERROR_MESSAGE.HEADING_MUST_BE_NUMBER;
      }

      if (numberFromString < 1) {
        return _aircraftCommandParserMessages.ERROR_MESSAGE.INCREMENTAL_HEADING_MUST_BE_POSITIVE;
      }

      break;
    // default case is included only for semtantics, this should not ever be reachable
    // istanbul ignore next

    default:
      throw new Error('An error ocurred parsing the Heading arguments');
  }
};
/**
 * Checks that args is the required length and the data is of the correct type
 *
 * ```
 * Allowed argument shapes:
 * - ['dumba']
 * - ['dumba', 'left', '2min']
 * - ['dumba', 'left', '2nm']
 * - ['dumba', 'right', '2min']
 * - ['dumba', 'right', '2nm']
 * - ['dumba', 'right', '2nm', '265']
 * ```
 *
 * @function holdValidator
 * @param args {array}
 * @return {array<string>}
 */


exports.headingValidator = headingValidator;

var holdValidator = function holdValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (args.length > 4) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.ZERO_TO_FOUR_ARG_LENGTH;
  }

  for (var i = 0; i < args.length; i++) {
    if (!(0, _isString2["default"])(args[i])) {
      return _aircraftCommandParserMessages.ERROR_MESSAGE.MUST_BE_STRING;
    }
  }
};
/**
 * Checks that `args` has one value that corresponds to a valid squawk
 *
 * @function squawkValidator
 * @param args {array}
 * @return {string|undefined}
 */


exports.holdValidator = holdValidator;

var squawkValidator = function squawkValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (args.length !== 1) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.SINGLE_ARG_LENGTH;
  }

  if (!_globalConstants.REGEX.TRANSPONDER_CODE.test(args[0])) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.INVALID_SQUAWK;
  }
};
/**
 * Checks that args is the required length and the data is of the correct type
 *
 * ```
 * Allowed argument shapes:
 * - ['dumba', 'a120', 's210']
 * ```
 *
 * @function crossingValidator
 * @param args {array}
 * @return {array<string>}
 */


exports.squawkValidator = squawkValidator;

var crossingValidator = function crossingValidator() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (args.length !== 2 && args.length !== 3) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.TWO_OR_THREE_ARG_LENGTH;
  }

  var _args = _slicedToArray(args, 1),
      fixName = _args[0];

  var altitude;
  var speed; // Set i to 1 to skip fixName

  for (var i = 1; i < args.length; i++) {
    if (typeof args[i][0] === 'string') {
      if (args[i][0].toLowerCase() === 'a') {
        altitude = args[i].toString().substr(1);
      } else if (args[i][0].toLowerCase() === 's') {
        speed = args[i].toString().substr(1);
      }
    }
  }

  if (!(0, _isString2["default"])(fixName)) {
    return _aircraftCommandParserMessages.ERROR_MESSAGE.MUST_BE_STRING;
  }

  if (altitude) {
    altitude = (0, _unitConverters.convertStringToNumber)(altitude);

    if ((0, _isNaN2["default"])(altitude)) {
      return _aircraftCommandParserMessages.ERROR_MESSAGE.ALTITUDE_MUST_BE_NUMBER;
    }
  }

  if (speed) {
    speed = (0, _unitConverters.convertStringToNumber)(speed);

    if ((0, _isNaN2["default"])(speed)) {
      return _aircraftCommandParserMessages.ERROR_MESSAGE.SPEED_MUST_BE_NUMBER;
    }
  }

  if (args.length === 3) {
    if (altitude == null) {
      return _aircraftCommandParserMessages.ERROR_MESSAGE.ALTITUDE_MUST_BE_NUMBER;
    } else if (speed == null) {
      return _aircraftCommandParserMessages.ERROR_MESSAGE.SPEED_MUST_BE_NUMBER;
    }
  }
};

exports.crossingValidator = crossingValidator;

},{"../../constants/globalConstants":310,"../../utilities/unitConverters":391,"./aircraftCommandMap":366,"./aircraftCommandParserMessages":367,"lodash/forEach":199,"lodash/isNaN":218,"lodash/isString":224}],370:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _first2 = _interopRequireDefault(require("lodash/first"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _last2 = _interopRequireDefault(require("lodash/last"));

var _without2 = _interopRequireDefault(require("lodash/without"));

var _values2 = _interopRequireDefault(require("lodash/values"));

var _scopeCommandMap = require("./scopeCommandMap");

var _scopeConstants = require("../../constants/scopeConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// TODO: Replace dummy sector codes with a proper `SectorCollection`
var SECTOR_HANDOFF_CODES = ['18', '19', '10', '12'];
/**
 * A command to be interpreted by the scope itself
 * Used for manipulation of the display and other ATC tasks
 *
 * @class ScopeCommandModel
 */

var ScopeCommandModel =
/*#__PURE__*/
function () {
  /**
   * @for ScopeCommandModel
   * @constructor
   * @param command {string}
   */
  function ScopeCommandModel(command) {
    _classCallCheck(this, ScopeCommandModel);

    /**
     * Information usable to find the applicable aircraft
     * This could be the CID, assigned squawk code, or full callsign
     *
     * @for ScopeCommandModel
     * @property aircraftReference
     * @type {string}
     */
    this.aircraftReference = '';
    /**
     * Array of arguments to be passed to the specified command function
     *
     * @for ScopeCommandModel
     * @property commandArguments
     * @type {array<string>}
     */

    this.commandArguments = [];
    /**
     * Name of the `ScopeModel` method to call to execute this command
     *
     * @for ScopeCommandModel
     * @property commandFunction
     * @type {string}
     */

    this.commandFunction = '';

    this._init(command);
  }
  /**
   * Perform initialization tasks
   *
   * @for ScopeCommandModel
   * @method _init
   * @param command {string}
   */


  _createClass(ScopeCommandModel, [{
    key: "_init",
    value: function _init(command) {
      var pieces = (0, _without2["default"])(command.toUpperCase().split(' '), '');
      this.aircraftReference = (0, _last2["default"])(pieces);
      this.commandFunction = this._extractCommandFunction(pieces);
      this.commandArguments = this._extractCommandArguments(pieces);
    }
    /**
     * Accept the full command and return only the arguments
     *
     * @for ScopeCommandModel
     * @method _extractCommandArguments
     * @param command {string}
     * @return {string}
     */

  }, {
    key: "_extractCommandArguments",
    value: function _extractCommandArguments(command) {
      if ((0, _values2["default"])(_scopeCommandMap.IMPLIED_COMMANDS).indexOf(this.commandFunction) !== -1) {
        return (0, _without2["default"])(command, this.aircraftReference);
      }

      return command.splice(1, command.length - 2);
    }
    /**
     * Accept the full command and return only the function name
     *
     * @for ScopeCommandModel
     * @method _extractCommandFunction
     * @param command {string}
     * @return {string}
     */

  }, {
    key: "_extractCommandFunction",
    value: function _extractCommandFunction(command) {
      var firstElement = (0, _first2["default"])(command);

      if ((0, _has2["default"])(_scopeCommandMap.EXPLICIT_COMMANDS, firstElement)) {
        return _scopeCommandMap.EXPLICIT_COMMANDS[firstElement];
      }

      if (SECTOR_HANDOFF_CODES.indexOf(firstElement) !== -1) {
        return _scopeCommandMap.COMMAND_FUNCTIONS.INITIATE_HANDOFF;
      }

      if (firstElement === '.') {
        return _scopeCommandMap.COMMAND_FUNCTIONS.SCRATCHPAD;
      }

      if (firstElement.indexOf(_scopeConstants.DATA_BLOCK_DIRECTION_LENGTH_SEPARATOR) !== -1 || firstElement.length < 2) {
        return _scopeCommandMap.COMMAND_FUNCTIONS.MOVE_DATA_BLOCK;
      }

      if (command.length === 1) {
        return _scopeCommandMap.COMMAND_FUNCTIONS.ACCEPT_HANDOFF;
      }

      return _scopeCommandMap.COMMAND_FUNCTIONS.SCRATCHPAD;
    }
  }]);

  return ScopeCommandModel;
}();

exports["default"] = ScopeCommandModel;

},{"../../constants/scopeConstants":315,"./scopeCommandMap":371,"lodash/first":196,"lodash/has":201,"lodash/last":229,"lodash/values":251,"lodash/without":252}],371:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COMMAND_FUNCTIONS = exports.IMPLIED_COMMANDS = exports.EXPLICIT_COMMANDS = void 0;

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Scope commands whose first element is a reference to the function to execute
 *
 * @enum EXPLICIT_COMMANDS
 * @type {object}
 */
var EXPLICIT_COMMANDS = {
  QP: 'propogateDataBlock',
  QP_J: 'setHalo',
  QU: 'route',
  QZ: 'amendAltitude'
};
/**
 * Scope commands where the function to execute is not explicitly stated in
 * the command itself, but is "implied" based on the context of the entry
 *
 * @enum IMPLIED_COMMANDS
 * @type {object}
 */

exports.EXPLICIT_COMMANDS = EXPLICIT_COMMANDS;
var IMPLIED_COMMANDS = {
  ACCEPT_HANDOFF: 'acceptHandoff',
  INITIATE_HANDOFF: 'initiateHandoff',
  MOVE_DATA_BLOCK: 'moveDataBlock',
  SCRATCHPAD: 'setScratchpad'
};
/**
 * Array of all available scope commands that can be run
 * @enum COMMAND_FUNCTIONS
 * @type {object}
 */

exports.IMPLIED_COMMANDS = IMPLIED_COMMANDS;

var COMMAND_FUNCTIONS = _objectSpread({}, IMPLIED_COMMANDS, EXPLICIT_COMMANDS);

exports.COMMAND_FUNCTIONS = COMMAND_FUNCTIONS;

},{}],372:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _filter2 = _interopRequireDefault(require("lodash/filter"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _RadarTargetModel = _interopRequireDefault(require("./RadarTargetModel"));

var _BaseCollection2 = _interopRequireDefault(require("../base/BaseCollection"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _eventNames = require("../constants/eventNames");

var _themes = require("../constants/themes");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Collection of `RadarTargetModel`s
 *
 * @class RadarTargetCollection
 */
var RadarTargetCollection =
/*#__PURE__*/
function (_BaseCollection) {
  _inherits(RadarTargetCollection, _BaseCollection);

  /**
   * @for RadarTargetCollection
   * @constructor
   * @param theme {object}
   */
  function RadarTargetCollection(theme) {
    var _this;

    _classCallCheck(this, RadarTargetCollection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RadarTargetCollection).call(this));
    /**
     * Local reference to the event bus
     *
     * @for RadarTargetModel
     * @property _eventBus
     * @type {EventBus}
     */

    _defineProperty(_assertThisInitialized(_this), "addRadarTargetModelForAircraftModel", function (aircraftModel) {
      var radarTargetModel = new _RadarTargetModel["default"](_this._theme, aircraftModel);

      _this.addRadarTargetModel(radarTargetModel);
    });

    _defineProperty(_assertThisInitialized(_this), "removeRadarTargetModelForAircraftModel", function (aircraftModel) {
      var collectionWithAircraftRemoved = (0, _filter2["default"])(_this._items, function (radarTargetModel) {
        return radarTargetModel.aircraftModel.id !== aircraftModel.id;
      });
      _this._items = collectionWithAircraftRemoved;
    });

    _defineProperty(_assertThisInitialized(_this), "_setTheme", function (themeName) {
      if (!(0, _has2["default"])(_themes.THEME, themeName)) {
        console.error("Expected valid theme to change to, but received '".concat(themeName, "'"));
        return;
      }

      _this._theme = _themes.THEME[themeName];
    });

    _this._eventBus = _EventBus["default"];
    /**
     * Current theme, updated via event bus events
     *
     * @for RadarTargetCollection
     * @property _theme
     * @type {object}
     */

    _this._theme = theme;

    _this._init().enable();

    return _this;
  }
  /**
   * Return a read-only reference to the collection array
   *
   * @for RadarTargetCollection
   * @property items
   * @type {array}
   */


  _createClass(RadarTargetCollection, [{
    key: "_init",

    /**
     * Complete initialization tasks
     *
     * @for RadarTargetCollection
     * @method _init
     * @private
     * @chainable
     */
    value: function _init() {
      return this;
    }
    /**
    * Activate event handlers
    *
    * @for RadarTargetModel
    * @method enable
    */

  }, {
    key: "enable",
    value: function enable() {
      this._eventBus.on(_eventNames.EVENT.ADD_AIRCRAFT, this.addRadarTargetModelForAircraftModel);

      this._eventBus.on(_eventNames.EVENT.SET_THEME, this._setTheme);
    }
    /**
    * Deactivate event handlers
    *
    * @for RadarTargetModel
    * @method disable
    */

  }, {
    key: "disable",
    value: function disable() {
      this._eventBus.off(_eventNames.EVENT.ADD_AIRCRAFT, this.addRadarTargetModelForAircraftModel);

      this._eventBus.off(_eventNames.EVENT.SET_THEME, this._setTheme);
    }
    /**
     * Add the provided `RadarTargetModel` instance to the collection
     *
     * @for RadarTargetCollection
     * @method addRadarTargetModel
     * @param radarTargetModel {RadarTargetModel}
     */

  }, {
    key: "addRadarTargetModel",
    value: function addRadarTargetModel(radarTargetModel) {
      if (!(radarTargetModel instanceof _RadarTargetModel["default"])) {
        throw new TypeError("Expected instance of RadarTargetModel but received '".concat(radarTargetModel, "'"));
      }

      this._items.push(radarTargetModel);
    }
    /**
     * Create `RadarTargetModel`s for the given `AircraftModel`
     *
     * @for RadarTargetCollection
     * @method addRadarTargetModelForAircraftModel
     * @param aircraftModel {AircraftModel}
     */

  }, {
    key: "findRadarTargetModelForAircraftModel",

    /**
     * Get the radar target model object for the specified aircraft
     *
     * @for RadarTargetCollection
     * @method findRadarTargetModelForAircraftModel
     * @param aircraftModel {AircraftModel}
     * @return radarTargetModel {RadarTargetModel}
     */
    value: function findRadarTargetModelForAircraftModel(aircraftModel) {
      // Store variable because `this` within lodash `_filter` has different scope
      var radarTargetModels = this._items;
      var results = (0, _filter2["default"])(radarTargetModels, function (radarTargetModel) {
        return radarTargetModel.aircraftModel.id === aircraftModel.id;
      });

      if (results.length > 1) {
        throw new Error("Unable to get radar target because ".concat(results.length, " matching aircraft were found"));
      }

      var radarTargetModel = results[0];
      return radarTargetModel;
    } // TODO: Allow us to choose an aircraft by its CID

    /**
     * Get the radar target model object for the specified aircraft
     *
     * @for RadarTargetCollection
     * @method findRadarTargetModelForAircraftReference
     * @param aircraftReference {string} the CID, squawk code, or callsign assigned to an aircraft
     * @return radarTargetModel {RadarTargetModel}
     */

  }, {
    key: "findRadarTargetModelForAircraftReference",
    value: function findRadarTargetModelForAircraftReference(aircraftReference) {
      // Store variable because `this` within lodash `_filter` has different scope
      var radarTargetModels = this._items;
      var results = (0, _filter2["default"])(radarTargetModels, function (_ref) {
        var aircraftModel = _ref.aircraftModel;
        return aircraftModel.transponderCode === aircraftReference || aircraftModel.callsign === aircraftReference;
      });

      if (results.length > 1) {
        return;
      }

      var radarTargetModel = results[0];
      return radarTargetModel;
    }
    /**
     * Remove from the collection the radar target model associated with the specified aircraft model
     *
     * @for RadarTargetCollection
     * @method removeRadarTargetModelForAircraftModel
     * @param aircraftModel {AircraftModel}
     */

  }, {
    key: "reset",

    /**
    * Reset all properties to their default values
    *
    * @for RadarTargetCollection
    * @method reset
    */
    value: function reset() {
      this._items = [];
    }
    /**
     * Reset all radar target models to default state
     *
     * @for RadarTargetCollection
     * @method resetAllRadarTargets
     */

  }, {
    key: "resetAllRadarTargets",
    value: function resetAllRadarTargets() {
      var radarTargetModels = this._items;

      for (var i = 0; i < radarTargetModels.length; i++) {
        radarTargetModels[i].reset();
      }
    }
    /**
     * Change theme to the specified name
     *
     * This should ONLY be called through the EventBus during a `SET_THEME` event,
     * thus ensuring that the same theme is always in use by all app components.
     *
     * This method must remain an arrow function in order to preserve the scope
     * of `this`, since it is being invoked by an EventBus callback.
     *
     * @for RadarTargetCollection
     * @method _setTheme
     * @param themeName {string}
     * @private
     */

  }, {
    key: "items",
    get: function get() {
      return this._items;
    }
  }]);

  return RadarTargetCollection;
}(_BaseCollection2["default"]);

exports["default"] = RadarTargetCollection;

},{"../base/BaseCollection":294,"../constants/eventNames":308,"../constants/themes":319,"../lib/EventBus":346,"./RadarTargetModel":373,"lodash/filter":190,"lodash/has":201}],373:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _has2 = _interopRequireDefault(require("lodash/has"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isNaN2 = _interopRequireDefault(require("lodash/isNaN"));

var _padEnd2 = _interopRequireDefault(require("lodash/padEnd"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _core = require("../math/core");

var _vector = require("../math/vector");

var _generalUtilities = require("../utilities/generalUtilities");

var _eventNames = require("../constants/eventNames");

var _globalConstants = require("../constants/globalConstants");

var _unitConverters = require("../utilities/unitConverters");

var _scopeConstants = require("../constants/scopeConstants");

var _themes = require("../constants/themes");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// TODO: abstract these to an appropriate constants file
var HEAVY_LETTER = 'H';
var SUPER_LETTER = 'J';
/**
 * A single radar target observed by the radar system and shown on the scope
 * Contains references to the full aircraft model, though only some of that
 * information will be made available to the controller through the scope.
 *
 * @class RadarTargetModel
 */

var RadarTargetModel =
/*#__PURE__*/
function () {
  /**
   * @for RadarTargetModel
   * @constructor
   * @param theme {object}
   * @param aircraftModel {AircraftModel}
   */
  function RadarTargetModel(theme, aircraftModel) {
    var _this = this;

    _classCallCheck(this, RadarTargetModel);

    _defineProperty(this, "_setTheme", function (themeName) {
      if (!(0, _has2["default"])(_themes.THEME, themeName)) {
        console.error("Expected valid theme to change to, but received '".concat(themeName, "'"));
        return;
      }

      _this._theme = _themes.THEME[themeName];
    });

    /**
     * The full aircraft model object that this radar target corresponds to
     *
     * @for RadarTargetModel
     * @property aircraftModel
     * @type {AircraftModel}
     */
    this.aircraftModel = null;
    /**
     * The cruise altitude (hard) assigned in the data block
     *
     * @for RadarTargetModel
     * @property _cruiseAltitude
     * @type {number}
     */

    this._cruiseAltitude = _globalConstants.INVALID_NUMBER;
    /**
     * Direction the data block is extended away from the radar target.
     * A value of -1 means to leave at default position.
     *
     * @for RadarTargetModel
     * @property _dataBlockLeaderDirection
     * @type {number}
     */

    this._dataBlockLeaderDirection = _globalConstants.INVALID_NUMBER;
    /**
     * Length of the leader line extending away from the radar target and
     * connecting to the data block.
     *
     * @for RadarTargetModel
     * @property _dataBlockLeaderLength
     * @type {number}
     */

    this._dataBlockLeaderLength = theme.DATA_BLOCK.LEADER_LENGTH;
    /**
     * Event Bus reference
     *
     * @for RadarTargetModel
     * @property _eventBus
     * @type {EventBus}
     */

    this._eventBus = _EventBus["default"]; // TODO: This will later be expanded upon such that aircraft may exist in
    // the simulation without necessarily having full data blocks. An example
    // of this would be VFR traffic with a partial or altitude-only data block.
    // For now, assuming all aircraft in existence have an editable data block.

    /**
     * Boolean value representing whether the aircraft has a full data block.
     * This is opposed to a partial (PDB), limited (LDB), or other non-full state.
     *
     * @for RadarTargetModel
     * @property _hasFullDataBlock
     * @type {boolean}
     */

    this._hasFullDataBlock = true;
    /**
     * Radius of the halo to be drawn around the radar taget
     *
     * If no halo is to be drawn, the value will be INVALID_NUMBER
     *
     * @for RadarTargetModel
     * @property _haloRadius
     * @type {number}
     * @default INVALID_NUMBER
     */

    this._haloRadius = _globalConstants.INVALID_NUMBER;
    /**
     * Boolean value representing whether the full data block is being suppressed
     * on this particular scope.
     *
     * @for RadarTargetModel
     * @property _hasSuppressedDataBlock
     * @type {boolean}
     */

    this._hasSuppressedDataBlock = false;
    /**
     * The altitude (soft) assigned in the data block
     *
     * @for RadarTargetModel
     * @property _interimAltitude
     * @type {number}
     */

    this._interimAltitude = _globalConstants.INVALID_NUMBER; // TODO: This will be replaced with `this._sectorInControl` or something
    // when handoffs become possible. For now, just marking whether or not "we"
    // are the sector with control of the track.

    /**
     * Boolean value representing whether the track of this target is under
     * control of this particular scope.
     *
     * @for RadarTargetModel
     * @property _isUnderOurControl
     * @type {boolean}
     */

    this._isUnderOurControl = true; // TODO: Store the aircraft's initial route here. Yes, we want to intentionally
    // make a copy of the route and store it here, not point to the aircraft's route.
    // When the aircraft is told to fly a new route, this property should still show
    // the old route, until the controller updates it in the scope.

    /**
     * The flight plan route for the aircraft associated with this radar target
     *
     * @for RadarTargetModel
     * @property _routeString
     * @type {string}
     */

    this._routeString = '';
    /**
     * A 3 character (or less) alphanumeric string that is shown in the data block
     * The scratchpad is used for controller shorthand notes and other purposes
     *
     * @for RadarTargetModel
     * @property _scratchPadText
     * @type {string}
     */

    this._scratchPadText = '';
    /**
     * Active theme
     *
     * @for RadarTargetModel
     * @property _theme
     * @type {object}
     */

    this._theme = theme;

    this._init(aircraftModel).enable();
  }
  /**
   * Angle away from the radar target to draw the leader line and data block
   *
   * @for RadarTargetModel
   * @property dataBlockLeaderDirection
   * @type {number}
   */


  _createClass(RadarTargetModel, [{
    key: "_init",

    /**
     * Complete initialization tasks
     *
     * @for RadarTargetModel
     * @method _init
     * @param theme {object}
     * @param aircraftModel {AircraftModel}
     * @private
     * @chainable
     */
    value: function _init(aircraftModel) {
      this.aircraftModel = aircraftModel;
      this._cruiseAltitude = aircraftModel.fms.flightPlanAltitude;
      this._dataBlockLeaderDirection = this._theme.DATA_BLOCK.LEADER_DIRECTION;
      this._dataBlockLeaderLength = this._theme.DATA_BLOCK.LEADER_LENGTH;
      this._routeString = aircraftModel.fms.getRouteString();
      this.setDefaultScratchpad();
      return this;
    }
    /**
    * Disable handlers
    *
    * @for RadarTargetModel
    * @method enable
    * @chainable
    */

  }, {
    key: "enable",
    value: function enable() {
      this._eventBus.on(_eventNames.EVENT.SET_THEME, this._setTheme);

      return this;
    }
    /**
    * Enable handlers
    *
    * @for RadarTargetModel
    * @method disable
    * @chainable
    */

  }, {
    key: "disable",
    value: function disable() {
      this._eventBus.off(_eventNames.EVENT.SET_THEME, this._setTheme);

      return this;
    }
    /**
    * Reset all properties to their default state
    *
    * @for RadarTargetModel
    * @method reset
    * @chainable
    */

  }, {
    key: "reset",
    value: function reset() {
      this.aircraftModel = null;
      this._cruiseAltitude = _globalConstants.INVALID_NUMBER;
      this._dataBlockLeaderDirection = _globalConstants.INVALID_NUMBER;
      this._dataBlockLeaderLength = this._theme.DATA_BLOCK.LEADER_LENGTH;
      this._hasFullDataBlock = true;
      this._haloRadius = _globalConstants.INVALID_NUMBER;
      this._hasSuppressedDataBlock = false;
      this._interimAltitude = _globalConstants.INVALID_NUMBER;
      this._isUnderOurControl = true;
      this._routeString = '';
      return this;
    }
    /**
     * Assign a new "hard" altitude
     *
     * @for RadarTargetModel
     * @param altitude {number}
     * @return {array} [success of operation, system's response]
     */

  }, {
    key: "amendAltitude",
    value: function amendAltitude(altitude) {
      this._cruiseAltitude = altitude;
      return [true, 'AMEND ALTITUDE'];
    }
    /**
     * Generate a string to be used for the first row of a datablock
     *
     * @for RadarTargetModel
     * @method buildDataBlockRowOne
     * @returns {string}
     */

  }, {
    key: "buildDataBlockRowOne",
    value: function buildDataBlockRowOne() {
      var dataBlockRowOne = this.aircraftModel.callsign; // NOTE: using empty space before the letter on purpose so this gets rendered
      // appropriately within a canvas

      switch (this.aircraftModel.model.weightClass) {
        case SUPER_LETTER:
          dataBlockRowOne += " ".concat(SUPER_LETTER);
          break;

        case HEAVY_LETTER:
          dataBlockRowOne += " ".concat(HEAVY_LETTER);
          break;

        default:
          break;
      }

      return dataBlockRowOne;
    }
    /**
     * Generate a string to be used for the second row of a datablock
     *
     * @for RadarTargetModel
     * @method buildDataBlockRowTwoPrimaryInfo
     * @returns {string}
     */

  }, {
    key: "buildDataBlockRowTwoPrimaryInfo",
    value: function buildDataBlockRowTwoPrimaryInfo() {
      var aircraftAltitude = (0, _core.round)(this.aircraftModel.altitude / 100);
      var aircraftSpeed = (0, _core.round)(this.aircraftModel.groundSpeed / 10);
      return "".concat((0, _generalUtilities.leftPad)(aircraftAltitude, 3), " ").concat((0, _generalUtilities.leftPad)(aircraftSpeed, 2));
    }
    /**
     * Generate a string to be used for the second row of a datablock
     * when the timeshare section is active
     *
     * @for RadarTargetModel
     * @method buildDataBlockRowTwoSecondaryInfo
     * @returns {string}
     */

  }, {
    key: "buildDataBlockRowTwoSecondaryInfo",
    value: function buildDataBlockRowTwoSecondaryInfo() {
      var paddedScratchPadText = (0, _padEnd2["default"])(this.scratchPadText, this._theme.DATA_BLOCK.SCRATCHPAD_CHARACTER_LIMIT, ' ');
      var paddedAircraftModelIcao = (0, _padEnd2["default"])(this.aircraftModel.model.icao.toUpperCase(), this._theme.DATA_BLOCK.AIRCRAFT_MODEL_ICAO_CHARACTER_LIMIT, ' ');
      var scratchPadText = paddedScratchPadText.slice(0, this._theme.DATA_BLOCK.SCRATCHPAD_CHARACTER_LIMIT);
      var aircraftModelIcao = paddedAircraftModelIcao.slice(0, this._theme.DATA_BLOCK.AIRCRAFT_MODEL_ICAO_CHARACTER_LIMIT);
      return "".concat(scratchPadText, " ").concat(aircraftModelIcao);
    }
    /**
     * Abstracts the math from the `CanvasController` used to determine
     * where the center of a datablock should be located
     *
     * @param {number} leaderIntersectionWithBlock
     */

  }, {
    key: "calculateDataBlockCenter",
    value: function calculateDataBlockCenter(leaderIntersectionWithBlock) {
      var blockCenterOffset = {
        ctr: [0, 0],
        360: [0, -this._theme.DATA_BLOCK.HALF_HEIGHT],
        45: [this._theme.DATA_BLOCK.HALF_WIDTH, -this._theme.DATA_BLOCK.HALF_HEIGHT],
        90: [this._theme.DATA_BLOCK.HALF_WIDTH, 0],
        135: [this._theme.DATA_BLOCK.HALF_WIDTH, this._theme.DATA_BLOCK.HALF_HEIGHT],
        180: [0, this._theme.DATA_BLOCK.HALF_HEIGHT],
        225: [-this._theme.DATA_BLOCK.HALF_WIDTH, this._theme.DATA_BLOCK.HALF_HEIGHT],
        270: [-this._theme.DATA_BLOCK.HALF_WIDTH, 0],
        315: [-this._theme.DATA_BLOCK.HALF_WIDTH, -this._theme.DATA_BLOCK.HALF_HEIGHT]
      };
      var leaderEndToBlockCenter = blockCenterOffset[this.dataBlockLeaderDirection];
      return (0, _vector.vadd)(leaderIntersectionWithBlock, leaderEndToBlockCenter);
    }
    /**
    * Mark this radar target as NOT being controlled by "our" ScopeModel
    * Note that this will eventually be reworked so we can specify which
    * scope has control, not just whether or not "we" do.
    *
    * @for RadarTargetModel
    * @method markAsNotOurControl
    */

  }, {
    key: "markAsNotOurControl",
    value: function markAsNotOurControl() {
      this._isUnderOurControl = false;
    }
    /**
     * Mark this radar target as being controlled by "our" ScopeModel
     * Note that this will eventually be reworked so we can specify which
     * scope has control, not just whether or not "we" do.
     *
     * @for RadarTargetModel
     * @method markAsOurControl
     */

  }, {
    key: "markAsOurControl",
    value: function markAsOurControl() {
      this._isUnderOurControl = true;
    }
    /**
     * Change the direction and/or length of the data block leader line
     *
     * @for RadarTargetModel
     * @method moveDataBlock
     * @param commandArguments {string}
     * @return {array} [success of operation, system's response]
     */

  }, {
    key: "moveDataBlock",
    value: function moveDataBlock(commandArguments) {
      if ((0, _isEmpty2["default"])(commandArguments)) {
        return [false, 'ERR: BAD SYNTAX'];
      }

      var desiredDirection = commandArguments;
      var desiredLength = '';

      if (commandArguments.indexOf(_scopeConstants.DATA_BLOCK_DIRECTION_LENGTH_SEPARATOR) !== _globalConstants.INVALID_NUMBER) {
        var argumentPieces = commandArguments.split(_scopeConstants.DATA_BLOCK_DIRECTION_LENGTH_SEPARATOR);
        desiredDirection = parseInt(argumentPieces[0], _unitConverters.DECIMAL_RADIX);
        desiredLength = parseInt(argumentPieces[1], _unitConverters.DECIMAL_RADIX);

        if ((0, _isEmpty2["default"])(argumentPieces[0])) {
          desiredDirection = '';
        }
      }

      if (desiredLength > 6 || desiredLength < 0) {
        return [false, 'ERR: LEADER LENGTH 0-6 ONLY'];
      }

      if (desiredDirection !== '' && !(0, _isNaN2["default"])(desiredDirection)) {
        if (!(0, _has2["default"])(_scopeConstants.DATA_BLOCK_POSITION_MAP, desiredDirection)) {
          return [false, 'ERR: BAD SYNTAX'];
        }

        this._dataBlockLeaderDirection = _scopeConstants.DATA_BLOCK_POSITION_MAP[desiredDirection];
      }

      if (desiredLength !== '' && !(0, _isNaN2["default"])(desiredLength)) {
        this._dataBlockLeaderLength = desiredLength;
      }

      return [true, 'ADJUST DATA BLOCK'];
    }
    /**
     * Clear any existing halo
     *
     * @for RadarTargetModel
     * @method removeHalo
     * @return {array} [success of operation, system's response]
     */

  }, {
    key: "removeHalo",
    value: function removeHalo() {
      if (!this.hasHalo) {
        return;
      }

      this._haloRadius = _globalConstants.INVALID_NUMBER;
      return [true, 'TOGGLE HALO'];
    }
    /**
     * Set the radius of the halo
     *
     * @for RadarTargetModel
     * @method setHalo
     * @param radius {number}
     * @return {array} [success of operation, system's response]
     */

  }, {
    key: "setHalo",
    value: function setHalo(radius) {
      if (!this.hasHalo) {
        this._haloRadius = radius;
        return [true, 'TOGGLE HALO'];
      }

      if (radius === this._haloRadius) {
        return this.removeHalo();
      }

      this._haloRadius = radius;
      return [true, 'ADJUST HALO'];
    }
    /**
     * Set default value of the scratchpad
     *
     * @for RadarTargetModel
     * @method setDefaultScratchpad
     * @return {array} [success of operation, system's response]
     */

  }, {
    key: "setDefaultScratchpad",
    value: function setDefaultScratchpad() {
      if (this.aircraftModel.isDeparture()) {
        this.scratchPadText = this.aircraftModel.fms.getFlightPlanEntry();
        return [true, 'RESET SCRATCHPAD'];
      }

      this.scratchPadText = this.aircraftModel.destination.substr(1, 3);
      return [true, 'RESET SCRATCHPAD'];
    }
    /**
     * Set the value of the scratchpad
     *
     * @for RadarTargetModel
     * @method setScratchpad
     * @param scratchPadText {string}
     * @return {array} [success of operation, system's response]
     */

  }, {
    key: "setScratchpad",
    value: function setScratchpad(scratchPadText) {
      this.scratchPadText = scratchPadText;
      return [true, 'SET SCRATCHPAD'];
    }
    /**
     * Change theme to the specified name
     *
     * This should ONLY be called through the EventBus during a `SET_THEME` event,
     * thus ensuring that the same theme is always in use by all app components.
     *
     * This method must remain an arrow function in order to preserve the scope
     * of `this`, since it is being invoked by an EventBus callback.
     *
     * @for RadarTargetModel
     * @method _setTheme
     * @param themeName {string}
     */

  }, {
    key: "dataBlockLeaderDirection",
    get: function get() {
      return this._dataBlockLeaderDirection;
    }
    /**
     * Length of leader line connecting radar target and data block
     *
     * @for RadarTargetModel
     * @property dataBlockLeaderLength
     * @type {number}
     */

  }, {
    key: "dataBlockLeaderLength",
    get: function get() {
      return this._dataBlockLeaderLength;
    }
    /**
     * Get the `PositionModel` for the aircraft associated with the radar target
     *
     * @for RadarTargetModel
     * @property positionModel
     * @type {PositionModel}
     */

  }, {
    key: "positionModel",
    get: function get() {
      return this.aircraftModel.positionModel;
    }
    /**
     * Get the latest known altitude for the aircraft associated with the radar target
     *
     * @for RadarTargetModel
     * @property positionModel
     * @type {PositionModel}
     */

  }, {
    key: "indicatedAltitude",
    get: function get() {
      return this.aircraftModel.altitude;
    }
    /**
     * @for RadarTargetModel
     * @property scratchPadText
     * @type {string}
     */

  }, {
    key: "scratchPadText",
    get: function get() {
      return this._scratchPadText;
    },
    set: function set(text) {
      this._scratchPadText = text.slice(0, 3).toUpperCase();
    }
    /**
     * @for RadarTargetModel
     * @property haloRadius
     * @type {number}
     */

  }, {
    key: "haloRadius",
    get: function get() {
      return this._haloRadius;
    }
    /**
     * @for RadarTargetModel
     * @property hasHalo
     * @type {boolean}
     */

  }, {
    key: "hasHalo",
    get: function get() {
      return this._haloRadius > 0;
    }
  }]);

  return RadarTargetModel;
}();

exports["default"] = RadarTargetModel;

},{"../constants/eventNames":308,"../constants/globalConstants":310,"../constants/scopeConstants":315,"../constants/themes":319,"../lib/EventBus":346,"../math/core":349,"../math/vector":352,"../utilities/generalUtilities":387,"../utilities/unitConverters":391,"lodash/has":201,"lodash/isEmpty":213,"lodash/isNaN":218,"lodash/padEnd":235}],374:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _has2 = _interopRequireDefault(require("lodash/has"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _GameController = _interopRequireDefault(require("../game/GameController"));

var _RadarTargetCollection = _interopRequireDefault(require("./RadarTargetCollection"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _eventNames = require("../constants/eventNames");

var _gameOptionConstants = require("../constants/gameOptionConstants");

var _themes = require("../constants/themes");

var _unitConverters = require("../utilities/unitConverters");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Scope belonging to a Player
 *
 * NOTE: Many methods are just placeholders for future use, hence why their params are commented out
 *
 * @class ScopeModel
 */
var ScopeModel =
/*#__PURE__*/
function () {
  /**
   * @for ScopeModel
   * @constructor
   */
  function ScopeModel() {
    var _this = this;

    _classCallCheck(this, ScopeModel);

    _defineProperty(this, "_setTheme", function (themeName) {
      if (!(0, _has2["default"])(_themes.THEME, themeName)) {
        console.error("Expected valid theme to change to, but received '".concat(themeName, "'"));
        return;
      }

      _this._theme = _themes.THEME[themeName];
    });

    /**
     * Local reference to the event bus
     *
     * @for ScopeModel
     * @property _eventBus
     * @type {EventBus}
     * @private
     */
    this._eventBus = _EventBus["default"];
    /**
     * Length of PTL lines (aka "vector lines") for all aircraft
     *
     * @for ScopeModel
     * @property _ptlLength
     * @type {number} length in minutes
     * @default 0
     * @private
     */

    this._ptlLength = 0; // TODO: Use this!

    /**
     * Collection of all sectors being controlled by this scope
     *
     * Currently set to null and not used. Is a placeholder for the
     * forthcoming class `SectorCollection`.
     *
     * @for ScopeModel
     * @property _sectorCollection
     * @type {null}
     * @private
     */

    this._sectorCollection = null;
    /**
     * Current theme
     *
     * @for ScopeModel
     * @property _theme
     * @type {object}
     * @private
     */

    this._theme = _themes.THEME.DEFAULT;
    /**
     * Collection of all radar targets observed by this scope
     *
     * @for ScopeModel
     * @property radarTargetCollection
     * @type {RadarTargetCollection}
     */

    this.radarTargetCollection = new _RadarTargetCollection["default"](this._theme);
    this.init().enable();
  }

  _createClass(ScopeModel, [{
    key: "init",
    // ------------------------------ LIFECYCLE ------------------------------

    /**
     * Complete initialization tasks
     *
     * @for ScopeModel
     * @method init
     * @chainable
     */
    value: function init() {
      return this;
    }
    /**
    * Enable handlers
    *
    * @for ScopeModel
    * @method enable
    */

  }, {
    key: "enable",
    value: function enable() {
      this._eventBus.on(_eventNames.EVENT.SET_THEME, this._setTheme);
    }
    /**
    * Disable handlers
    *
    * @for ScopeModel
    * @method disable
    */

  }, {
    key: "disable",
    value: function disable() {
      this._eventBus.off(_eventNames.EVENT.SET_THEME, this._setTheme);
    } // ------------------------------ PUBLIC ------------------------------

    /**
     * Accept a pending handoff from another sector
     *
     * NOTE: This is just a placeholder for future use, hence why the params are commented out
     *
     * @for ScopeModel
     * @method acceptHandoff
     * @param radarTargetModel {RadarTargetModel}
     * @return result {array} [success of operation, system's response]
     */

  }, {
    key: "acceptHandoff",
    value: function acceptHandoff()
    /* radarTargetModel */
    {
      return [false, 'acceptHandoff command not yet available'];
    }
    /**
     * Amend the cruise altitude OR interim altitude for a given `RadarTargetModel`
     *
     * @for ScopeModel
     * @method amendAltitude
     * @param radarTargetModel {RadarTargetModel}
     * @param altitude {string}
     * @return result {array} [success of operation, system's response]
     */

  }, {
    key: "amendAltitude",
    value: function amendAltitude(radarTargetModel, altitude) {
      altitude = parseInt(altitude, _unitConverters.DECIMAL_RADIX);
      return radarTargetModel.amendAltitude(altitude);
    }
    /**
     * Increase or decrease the PTL length by one step
     *
     * @for ScopeModel
     * @method changePtlLength
     * @param {number} direction - either -1 or 1 to indicate increment direction
     */

  }, {
    key: "changePtlLength",
    value: function changePtlLength(direction) {
      var validValues = _GameController["default"].getGameOption(_gameOptionConstants.GAME_OPTION_NAMES.PROJECTED_TRACK_LINE_LENGTHS).split('-').map(function (val) {
        return parseFloat(val);
      });

      var currentIndex = validValues.indexOf(this._ptlLength);
      var nextIndex = currentIndex + Math.sign(direction);

      if (nextIndex >= validValues.length) {
        return;
      }

      if (nextIndex < 0) {
        this._ptlLength = 0;

        this._eventBus.trigger(_eventNames.EVENT.MARK_SHALLOW_RENDER);

        return;
      }

      this._ptlLength = validValues[nextIndex];

      this._eventBus.trigger(_eventNames.EVENT.MARK_SHALLOW_RENDER);
    }
    /**
     * Decrease the length of the PTL lines for all aircraft
     *
     * @for ScopeModel
     * @method decreasePtlLength
     */

  }, {
    key: "decreasePtlLength",
    value: function decreasePtlLength() {
      var direction = -1;
      this.changePtlLength(direction);
    }
    /**
     * Increase the length of the PTL lines for all aircraft
     *
     * @for ScopeModel
     * @method increasePtlLength
     */

  }, {
    key: "increasePtlLength",
    value: function increasePtlLength() {
      var direction = 1;
      this.changePtlLength(direction);
    }
    /**
     * Initiate a handoff to another sector
     *
     * NOTE: This is just a placeholder for future use, hence why the params are commented out
     *
     * @for ScopeModel
     * @method initiateHandoff
     * @param radarTargetModel {RadarTargetModel}
     * @param sectorCode {string} the handoff code for the receiving sector
     * @return result {array} [success of operation, system's response]
     */

  }, {
    key: "initiateHandoff",
    value: function initiateHandoff()
    /* radarTargetModel, sectorCode */
    {
      return [false, 'initiateHandoff command not yet available'];
    }
    /**
     * Change direction and/or length of data block leader line
     *
     * @for ScopeModel
     * @method moveDataBlock
     * @param radarTargetModel {RadarTargetModel}
     * @param commandArguments {string}
     * @return result {array} [success of operation, system's response]
     */

  }, {
    key: "moveDataBlock",
    value: function moveDataBlock(radarTargetModel, commandArguments) {
      return radarTargetModel.moveDataBlock(commandArguments);
    }
    /**
     * Toggle visibility of the data block of a given `RadarTargetModel`, on this
     * sector's scope, or the scope of another sector
     *
     * NOTE: This is just a placeholder for future use, hence why the params are commented out
     *
     * @for ScopeModel
     * @method propogateDataBlock
     * @param radarTargetModel {RadarTargetModel}
     * @param sectorCode {string} handoff code for the receiving sector
     * @return result {array} [success of operation, system's response]
     */

  }, {
    key: "propogateDataBlock",
    value: function propogateDataBlock()
    /* radarTargetModel, sectorCode */
    {
      return [false, 'propogateDataBlock command not yet available'];
    }
    /**
     * Amend the route stored in the scope for a given `RadarTargetModel`
     *
     * NOTE: This is just a placeholder for future use, hence why the params are commented out
     *
     * @for ScopeModel
     * @method route
     * @param radarTargetModel {RadarTargetModel}
     * @param routeString {string}
     * @return result {array} [success of operation, system's response]
     */

  }, {
    key: "route",
    value: function route()
    /* radarTargetModel, routeString */
    {
      return [false, 'route command not yet available'];
    }
    /**
     * Execute a scope command from a `ScopeCommandModel`
     * @method runScopeCommand
     * @param scopeCommandModel {ScopeCommandModel}
     * @return result {array} [success of operation, system's response]
     */

  }, {
    key: "runScopeCommand",
    value: function runScopeCommand(scopeCommandModel) {
      var functionName = scopeCommandModel.commandFunction;
      var functionArguments = scopeCommandModel.commandArguments;
      var radarTargetModel = this.radarTargetCollection.findRadarTargetModelForAircraftReference(scopeCommandModel.aircraftReference);

      if (!(functionName in this)) {
        return [false, 'ERR: BAD SYNTAX'];
      }

      if ((0, _isNil2["default"])(radarTargetModel)) {
        return [false, 'ERR: UNKNOWN AIRCRAFT'];
      } // call the appropriate function, and explode the array of arguments
      // this allows any number of arguments to be accepted by the receiving method


      return this[functionName].apply(this, [radarTargetModel].concat(_toConsumableArray(functionArguments)));
    }
    /**
     * Amend the scratchpad for a given `RadarTargetModel`
     *
     * @for ScopeModel
     * @method setScratchpad
     * @param radarTargetModel {RadarTargetModel}
     * @param scratchPadText {string}
     * @return result {array} [success of operation, system's response]
     */

  }, {
    key: "setScratchpad",
    value: function setScratchpad(radarTargetModel, scratchPadText) {
      if (scratchPadText.length > 3) {
        return [false, 'ERR: SCRATCHPAD MAX 3 CHAR'];
      }

      if (scratchPadText === '.') {
        return radarTargetModel.setDefaultScratchpad();
      }

      return radarTargetModel.setScratchpad(scratchPadText.toUpperCase());
    }
    /**
     * Toggle halo for a given `RadarTargetModel`
     *
     * @for ScopeModel
     * @method setHalo
     * @param radarTargetModel {RadarTargetModel}
     * @return result {array} [success of operation, system's response]
     */

  }, {
    key: "setHalo",
    value: function setHalo(radarTargetModel, radius) {
      var haloDefaultRadius = this._theme.SCOPE.HALO_DEFAULT_RADIUS_NM;
      var haloMaxRadius = this._theme.SCOPE.HALO_MAX_RADIUS_NM;

      if (radius <= 0) {
        return [false, 'ERR: HALO SIZE INVALID'];
      }

      if (radius > haloMaxRadius) {
        return [false, "ERR: HALO MAX ".concat(haloMaxRadius, " NM")];
      }

      if (!radius) {
        radius = haloDefaultRadius;
      }

      return radarTargetModel.setHalo(radius);
    } // ------------------------------ PRIVATE ------------------------------

    /**
     * Change theme to the specified name
     *
     * This should ONLY be called through the EventBus during a `SET_THEME` event,
     * thus ensuring that the same theme is always in use by all app components.
     *
     * This method must remain an arrow function in order to preserve the scope
     * of `this`, since it is being invoked by an EventBus callback.
     *
     * @for ScopeModel
     * @method _setTheme
     * @param themeName {string}
     */

  }, {
    key: "ptlLength",
    get: function get() {
      return this._ptlLength;
    }
  }]);

  return ScopeModel;
}();

exports["default"] = ScopeModel;

},{"../constants/eventNames":308,"../constants/gameOptionConstants":309,"../constants/themes":319,"../game/GameController":339,"../lib/EventBus":346,"../utilities/unitConverters":391,"./RadarTargetCollection":372,"lodash/has":201,"lodash/isNil":219}],375:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.speech_toggle = exports.speech_say = exports.randomizePilotVoice = exports.speech_init = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _EventTracker = _interopRequireDefault(require("./EventTracker"));

var _radioUtilities = require("./utilities/radioUtilities");

var _storageKeys = require("./constants/storageKeys");

var _selectors = require("./constants/selectors");

var _speechConstants = require("./constants/speechConstants");

var _trackableEvents = require("./constants/trackableEvents");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/* eslint-disable no-underscore-dangle, no-unused-vars, no-undef, global-require */

/**
 *
 * @function speech_init
 */
var speech_init = function speech_init() {
  prop.speech = {};
  prop.speech.synthesis = window.speechSynthesis;
  prop.speech.enabled = false;

  if ((0, _get2["default"])(localStorage, _storageKeys.STORAGE_KEY.ATC_SPEECH_ENABLED, false) === true) {
    prop.speech.enabled = true;
    (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_SPEECH).addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
  }
};
/**
 *
 * @function randomizePilotVoice
 */


exports.speech_init = speech_init;

var randomizePilotVoice = function randomizePilotVoice() {
  var voice = _speechConstants.VOICES[Math.floor(Math.random() * _speechConstants.VOICES.length)];

  var pitch = (Math.random() * (_speechConstants.LOWER_PITCH - _speechConstants.HIGHER_PITCH) + _speechConstants.HIGHER_PITCH).toFixed(1);

  var rate = (Math.random() * (_speechConstants.NORMAL_SPEED - _speechConstants.FASTER_SPEED) + _speechConstants.FASTER_SPEED).toFixed(3);

  return {
    voice: voice,
    pitch: pitch,
    rate: rate
  };
};
/**
 *
 * @function speech_say
 * @param sentence
 */


exports.randomizePilotVoice = randomizePilotVoice;

var speech_say = function speech_say(sentence, pilotVoice) {
  if (prop.speech.synthesis != null && prop.speech.enabled) {
    var textToSay = '';

    for (var i = 0; i < sentence.length; i++) {
      var singleSentence = sentence[i];

      switch (singleSentence.type) {
        case 'callsign':
          textToSay += " ".concat(singleSentence.content.getRadioCallsign(), " ");
          break;

        case 'altitude':
          textToSay += " ".concat((0, _radioUtilities.radio_altitude)(singleSentence.content), " ");
          break;

        case 'speed':
        case 'heading':
          textToSay += " ".concat((0, _radioUtilities.radio_heading)(singleSentence.content), " ");
          break;

        case 'text':
          textToSay += " ".concat(singleSentence.content, " ");
          break;

        default:
          break;
      }
    }

    var utterance = new SpeechSynthesisUtterance(textToSay); // make the object

    utterance.lang = 'en-US'; // set the language

    utterance.voice = prop.speech.synthesis.getVoices().filter(function (voice) {
      // set the voice
      return voice.name === pilotVoice.voice;
    })[0];
    utterance.rate = pilotVoice.rate;
    utterance.pitch = pilotVoice.pitch; // say the words

    prop.speech.synthesis.speak(utterance);
  }
};
/**
 *
 * @function speech_toggle
 */


exports.speech_say = speech_say;

var speech_toggle = function speech_toggle() {
  var $speechToggleElement = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_SPEECH);
  prop.speech.enabled = !prop.speech.enabled;

  if (!prop.speech.enabled) {
    prop.speech.synthesis.cancel();
  }

  $speechToggleElement.toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
  localStorage[_storageKeys.STORAGE_KEY.ATC_SPEECH_ENABLED] = prop.speech.enabled;
  var hasClass = $speechToggleElement.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

  _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'speech', "".concat(hasClass));
};

exports.speech_toggle = speech_toggle;

},{"./EventTracker":259,"./constants/selectors":316,"./constants/speechConstants":317,"./constants/storageKeys":318,"./constants/trackableEvents":334,"./utilities/radioUtilities":389,"jquery":1,"lodash/get":200,"lodash/has":201}],376:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _filter2 = _interopRequireDefault(require("lodash/filter"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _reduce2 = _interopRequireDefault(require("lodash/reduce"));

var _random2 = _interopRequireDefault(require("lodash/random"));

var _BaseCollection2 = _interopRequireDefault(require("../base/BaseCollection"));

var _SpawnPatternModel = _interopRequireDefault(require("./SpawnPatternModel"));

var _aircraftConstants = require("../constants/aircraftConstants");

var _globalConstants = require("../constants/globalConstants");

var _validatorUtilities = require("../utilities/validatorUtilities");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * A collection of `SpawnPatternModel` objects
 *
 * @class SpawnPatternCollection
 * @extends BaseCollection
 */
var SpawnPatternCollection =
/*#__PURE__*/
function (_BaseCollection) {
  _inherits(SpawnPatternCollection, _BaseCollection);

  function SpawnPatternCollection() {
    _classCallCheck(this, SpawnPatternCollection);

    return _possibleConstructorReturn(this, _getPrototypeOf(SpawnPatternCollection).apply(this, arguments));
  }

  _createClass(SpawnPatternCollection, [{
    key: "init",

    /**
     * Lifecycle method. Should be run only once on instantiation.
     *
     * Set up the instance properties
     *
     * @for SpawnPatternCollection
     * @method init
     * @param airportJson {object}
     */
    value: function init(airportJson) {
      if (typeof airportJson === 'undefined' || (0, _validatorUtilities.isEmptyObject)(airportJson)) {
        throw new TypeError('Invalid airportJson passed to SpawnPatternCollection');
      }

      this._buildSpawnPatternModels(airportJson.spawnPatterns);
    }
    /**
     * Loop through each item in the collection andd call `.destroy()` on that model.
     *
     * Used when resetting the collection, like onAirportChange.
     *
     * @for SpawnPatternCollection
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      (0, _forEach2["default"])(this._items, function (spawnPatternModel) {
        spawnPatternModel.reset(); // ModelSourceFactory.returnModelToPool(spawnPatternModel);
      });
      this._items = [];
    }
    /**
     * @for SpawnPatternCollection
     * @method addItems
     * @param items {array}
     */

  }, {
    key: "addItems",
    value: function addItems() {
      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (items.length === 0) {
        return;
      }

      for (var i = 0; i < items.length; i++) {
        var itemToAdd = items[i];
        this.addItem(itemToAdd);
      }
    }
    /**
     * @for SpawnPatternCollection
     * @method addItem
     * @param item {SpawnPatternModel}
     */

  }, {
    key: "addItem",
    value: function addItem(item) {
      if (!(item instanceof _SpawnPatternModel["default"])) {
        throw new TypeError('Only SpawnPatternModel objects can be added to the SpawnPatternCollection.');
      }

      this._items.push(item);
    }
    /**
     * Gather a randomized list of departure `SpawnPatternModel` objects
     * that will be created during the preSpawn.
     *
     * Clamps max at 5 patterns.
     * Randomly selects departure patterns from a filtered list containing only departure patterns.
     *
     * This method should be called by the `SpawnScheduler` when preSpawning new
     * aircraft on session start.
     *
     * @for SpawnPatternCollection
     * @method getDepartureModelsForPreSpawn
     * @return departureModelsForPreSpawn {array<SpawnPatternModel>}
     */

  }, {
    key: "getDepartureModelsForPreSpawn",
    value: function getDepartureModelsForPreSpawn() {
      var departureModelsForPreSpawn = [];
      var departureModelsLength = this.departureModels.length;
      var minutesOfDeparturesToPreSpawn = 10;
      var hoursOfDeparturesToPreSpawn = minutesOfDeparturesToPreSpawn * _globalConstants.TIME.ONE_MINUTE_IN_HOURS;
      var departuresPerHour = (0, _reduce2["default"])(this.departureModels, function (sum, spawnPattern) {
        return sum + spawnPattern.rate;
      }, 0);
      var departuresToPreSpawn = departuresPerHour * hoursOfDeparturesToPreSpawn;

      for (var i = 0; i < departuresToPreSpawn; i++) {
        var index = (0, _random2["default"])(0, departureModelsLength - 1);
        var spawnPatternModel = this.departureModels[index];
        departureModelsForPreSpawn.push(spawnPatternModel);
      }

      return departureModelsForPreSpawn;
    }
    /**
     * Gather a list of `SpawnPatternModel` objects by their flight category.
     *
     * @for SpawnPatternCollection
     * @method findSpawnPatternsByCategory
     * @param flightCategory {FLIGHT_CATEGORY}
     * @return {array<SpawnPatternModel>}
     */

  }, {
    key: "findSpawnPatternsByCategory",
    value: function findSpawnPatternsByCategory(flightCategory) {
      return (0, _filter2["default"])(this._items, {
        category: flightCategory
      });
    }
    /**
     * Loop through spawnPatterns, as defined in airport json, and create
     * a `SpawnPatternModel` for each. Then add it to the collection.
     *
     * @for SpawnPatternCollection
     * @method _buildSpawnPatternModels
     * @param spawnPatterns {array<object>}
     * @private
     */

  }, {
    key: "_buildSpawnPatternModels",
    value: function _buildSpawnPatternModels(spawnPatterns) {
      var _this = this;

      (0, _forEach2["default"])(spawnPatterns, function (spawnPattern) {
        var spawnPatternModel = new _SpawnPatternModel["default"](spawnPattern); // const spawnPatternModel = ModelSourceFactory.getModelSourceForType(
        //     'SpawnPatternModel',
        //     spawnPattern
        // );

        _this.addItem(spawnPatternModel);
      });
    }
  }, {
    key: "spawnPatternModels",

    /**
     * Public property that gives access to the current value of `_items`
     *
     * @property spawnPatternModels
     * @type {array<SpawnPatternModel>}
     */
    get: function get() {
      return this._items;
    }
    /**
     * All `SpawnPatternModel` objects categorized as `departure`
     *
     * Used for assembling preSpawn departures
     *
     * @property departureModels
     * @return {array<SpawnPatternModel>}
     */

  }, {
    key: "departureModels",
    get: function get() {
      return (0, _filter2["default"])(this._items, {
        category: _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE
      });
    }
  }]);

  return SpawnPatternCollection;
}(_BaseCollection2["default"]);

var _default = new SpawnPatternCollection();

exports["default"] = _default;

},{"../base/BaseCollection":294,"../constants/aircraftConstants":303,"../constants/globalConstants":310,"../utilities/validatorUtilities":392,"./SpawnPatternModel":377,"lodash/filter":190,"lodash/forEach":199,"lodash/random":237,"lodash/reduce":238}],377:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _random2 = _interopRequireDefault(require("lodash/random"));

var _round2 = _interopRequireDefault(require("lodash/round"));

var _RouteModel = _interopRequireDefault(require("../aircraft/FlightManagementSystem/RouteModel"));

var _AirportController = _interopRequireDefault(require("../airport/AirportController"));

var _BaseModel2 = _interopRequireDefault(require("../base/BaseModel"));

var _StaticPositionModel = _interopRequireDefault(require("../base/StaticPositionModel"));

var _buildPreSpawnAircraft2 = require("./buildPreSpawnAircraft");

var _spawnPatternModelJsonValidator = require("./spawnPatternModelJsonValidator");

var _circle = require("../math/circle");

var _aircraftConstants = require("../constants/aircraftConstants");

var _airportConstants = require("../constants/airportConstants");

var _globalConstants = require("../constants/globalConstants");

var _unitConverters = require("../utilities/unitConverters");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// TODO: this may need to live somewhere else

/**
 * @property SPAWN_METHOD
 * @type {Object}
 * @final
 */
var SPAWN_METHOD = {
  RANDOM: 'random',
  CYCLIC: 'cyclic',
  SURGE: 'surge',
  WAVE: 'wave'
};
/**
 * Defines a spawn pattern for a specific route within the area
 *
 * This same structure is used to define departures and arrivals
 * and is used by the `SpawnScheduler` to instantiate new `AircraftModel`
 * objects.
 *
 * This class will expect data in the following shape:
 * ```javascript
 * // Departures
 * {
 *    "origin": "KLAS",
 *    "destination": "",
 *    "category": "departure",
 *    "route": "KLAS.BOACH6.HEC",
 *    "altitude": "",
 *    "speed": "",
 *    "method": "random",
 *    "rate": 5,
 *    "airlines": [
 *        ["aal", 10],
 *        ["ual", 10],
 *        ["ual/long", 3]
 *    ]
 * }
 *
 * // Arrivals
 * {
 *   "origin": "",
 *   "destination": "KLAS",
 *   "category": "arrival",
 *   "route": "BETHL.GRNPA1.KLAS",
 *   "altitude": [30000, 40000],
 *   "speed": 320,
 *   "method": "cyclic",
 *   "rate": 17.5,
 *   "period": 75,
 *   "offset": 25,
 *   "airlines": [
 *       ["aal", 10],
 *       ["ual", 10],
 *       ["ual/long", 3]
 *   ]
 * }
 * ```
 * additional information on `spawnPatterns` can be found in the
 * [spawnPatternReadme](https://github.com/openscope/openscope/tree/develop/documentation/spawnPatternReadme.md)
 *
 * @class SpawnPatternModel
 * @extends BaseModel
 */

var SpawnPatternModel =
/*#__PURE__*/
function (_BaseModel) {
  _inherits(SpawnPatternModel, _BaseModel);

  /**
   * @constructor
   * @for SpawnPatternModel
   * @param spawnPatternJson {object}
   */
  // istanbul ignore next
  function SpawnPatternModel(spawnPatternJson) {
    var _this;

    _classCallCheck(this, SpawnPatternModel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SpawnPatternModel).call(this, 'spawnPatternModel'));
    /**
     * Schedule reference id
     *
     * Stored here so a specific interval can be associated with a
     * specfic `SpawnPatternModel` instance. An Interval may be reset
     * or changed during the life of the app.
     *
     * Provides easy access to a specific scheduleId
     *
     * @property scheduleId
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    _this.scheduleId = _globalConstants.INVALID_NUMBER;
    /**
     * One of `FLIGHT_CATEGORY`
     *
     * @property category
     * @type {string}
     * @default ''
     */

    _this.category = '';
    /**
     * Type of arrival or departure pattern
     *
     * Could be `random`, `cyclic`, `surge` or `wave`
     *
     * @property type
     * @type {string}
     * @default ''
     */

    _this.method = '';
    /**
     * List of possible airlines a spawning aircraft can belong to.
     *
     * @property airlines
     * @type {array<string>}
     * @default []
     */

    _this.airlines = [];
    /**
     * List of airlines enumerated by weight
     *
     * In english, if the value of `this.airlines` was:
     * ```
     * [
     *     ['aal', 5],
     *     ['ual', 2]
     * ]
     * ```
     * This property would have a length of 7, with 5 entires of `aal` and two entries of `ual`.
     * The reason for this is to provide an easy way to find a weighted value. Now all we need is
     * a random index and the value located at that index.
     *
     * @property _weightedAirlineList
     * @type {array}
     * @default []
     */

    _this._weightedAirlineList = [];
    /**
     * Aircraft to spawn on airport load
     *
     * This list is evaluated by the `SpawnScheduler` when setting up
     * schedules for each `SpawnPatternModel`.
     *
     * @property preSpawnAircraftList
     * @type {array<object>}
     * @default []
     */

    _this.preSpawnAircraftList = [];
    /**
     * A local copy of the `RouteModel` that will exist in all aircraft spawned
     * from this spawn pattern. Note that this property IS NOT transferred or
     * copied or anything like that during aircraft spawn, but rather is included
     * here so we can ask questions about the route related to HOW we spawn traffic.
     *
     * @for SpawnPatternModel
     * @property _routeModel
     * @type {RouteModel}
     */

    _this._routeModel = null; // SPAWNING AIRCRAFT PROPERTIES

    /**
     * The airport this pattern begins at
     *
     * @property origin
     * @type {string}
     * @default ''
     */

    _this.origin = '';
    /**
     * The airport icao id this pattern's aircraft will land at
     * or the procedure name the aircraft is departing with
     *
     * @property destination
     * @type {string}
     * @default ''
     */

    _this.destination = '';
    /**
     * String representation of a `StandardRoute` or a list of fixes
     *
     * @property routeString
     * @type {string}
     * @default
     */

    _this.routeString = '';
    /**
     * List of fixes to follow on spawn.
     *
     * This property will be set to an array of strings representing
     * fixnames. this is only used when a DirectRouteString has been
     * passed for the route parameter.
     *
     * @property waypoints
     * @type {array<string>}
     * @default []
     */

    _this.waypoints = [];
    /**
     * Lowest altitude an aircraft can spawn at
     *
     * @property _minimumAltitude
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    _this._minimumAltitude = _globalConstants.INVALID_NUMBER;
    /**
     * Highest altitude an aircraft can spawn at
     *
     * @property _maximumAltitude
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    _this._maximumAltitude = _globalConstants.INVALID_NUMBER;
    /**
     * Speed of spawning aircraft
     *
     * @property speed
     * @type {number}
     * @default 0
     */

    _this.speed = 0;
    /**
     * Heading of a spawning aircraft
     *
     * @property heading
     * @type {number}
     * @default -999
     */

    _this.heading = -999;
    /**
     * Initial position of a spawning aircraft
     *
     * @property _positionModel
     * @type {StaticPositionModel}
     * @default null
     */

    _this._positionModel = null; // SPAWN PATTERN PROPERTIES

    /**
     * Rate at which aircaft spawn, express in aircraft per hour
     *
     * @property rate
     * @type {number}
     * @default INVALID_NUMBER
     */

    _this.rate = _globalConstants.INVALID_NUMBER;
    /**
     * GameTime when a specific spawn pattern started
     *
     * Used only for cycle, surge and wave patterns
     *
     * @property cycleStartTime
     * @type {number}
     * @default INVALID_NUMBER
     */

    _this.cycleStartTime = _globalConstants.INVALID_NUMBER;
    /**
     * Used only with cycle, surge or wave spawnPatters
     *
     * Shifts the pattern to a different part of the cycle
     *
     * @property offset
     * @type {number}
     * @default INVALID_NUMBER
     */

    _this.offset = _globalConstants.INVALID_NUMBER;
    /**
     * Used only with cycle, surge or wave spawnPatters
     *
     * Length of a pattern cycle
     *
     * @property period
     * @type {number}
     * @default INVALID_NUMBER
     */

    _this.period = _globalConstants.INVALID_NUMBER;
    /**
     * Used only with cycle, surge or wave spawnPatters
     *
     * @property variation
     * @type {number}
     * @default INVALID_NUMBER
     */

    _this.variation = _globalConstants.INVALID_NUMBER;
    /**
     * Miles entrail during the surge [fast, slow]
     *
     * Used only for `surge` spawn patterns. set as a class
     * property to allow maintainence of state between spawns
     *
     * @property entrail
     * @type {number}
     * @default
     */

    _this.entrail = [5.5, 10];
    /**
     * calculated arrival rate when "in the surge"
     *
     * Used only for `surge` spawn patterns. set as a class
     * property to allow maintainence of state between spawns
     *
     * @property _aircraftPerHourUp
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    _this._aircraftPerHourUp = _globalConstants.INVALID_NUMBER;
    /**
     * calculated arrival rate when not "in the surge"
     *
     * Used only for `surge` spawn patterns. set as a class
     * property to allow maintainence of state between spawns
     *
     * @property _aircraftPerHourDown
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    _this._aircraftPerHourDown = _globalConstants.INVALID_NUMBER;
    /**
     * Calculated time length of surge, in minutes
     *
     * Used only for `surge` spawn patterns. set as a class
     * property to allow maintainence of state between spawns
     *
     * @property _uptime
     * @type {number}
     * @default INVALID_NUMBER
     * @private
     */

    _this._uptime = _globalConstants.INVALID_NUMBER;

    _this.init(spawnPatternJson);

    return _this;
  }
  /**
   * The spawn pattern's id
   *
   * @property id
   * @return {string}
   */


  _createClass(SpawnPatternModel, [{
    key: "init",

    /**
     * Lifecycle method. Should be run only once on instantiation.
     *
     * Set up the instance properties
     *
     * This is a pooled object so we verify essential parameters
     * here instead of the constructor
     *
     * @for SpawnPatternModel
     * @method init
     * @param spawnPatternJson {object}
     */
    value: function init(spawnPatternJson) {
      // We return early here if the object is empty because we pre-hydrate objects in the `ModelSourcePool`
      if ((0, _isEmpty2["default"])(spawnPatternJson)) {
        return;
      }

      if (!(0, _spawnPatternModelJsonValidator.spawnPatternModelJsonValidator)(spawnPatternJson)) {
        console.error('### Invalid spawnPatternJson received', spawnPatternJson);
      }

      this.origin = spawnPatternJson.origin;
      this.destination = spawnPatternJson.destination;
      this.category = spawnPatternJson.category;
      this.routeString = spawnPatternJson.route;
      this.speed = this._extractSpeedFromJson(spawnPatternJson);
      this.method = spawnPatternJson.method;
      this.rate = parseFloat(spawnPatternJson.rate);
      this.entrail = (0, _get2["default"])(spawnPatternJson, 'entrail', this.entrail);
      this._routeModel = new _RouteModel["default"](spawnPatternJson.route);
      this.cycleStartTime = 0;
      this.period = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / 2;
      this._positionModel = this._generateSelfReferencedAirportPositionModel();
      this.airlines = this._assembleAirlineNamesAndFrequencyForSpawn(spawnPatternJson.airlines);
      this._weightedAirlineList = this._buildWeightedAirlineList();
      this.preSpawnAircraftList = this._buildPreSpawnAircraft(spawnPatternJson);

      this._calculateSurgePatternInitialDelayValues(spawnPatternJson);

      this._setCyclePeriodAndOffset(spawnPatternJson);

      this._initializePositionAndHeadingForAirborneAircraft(spawnPatternJson);

      this._setMinMaxAltitude(spawnPatternJson.altitude);
    }
    /**
     * Destroy the current instance properties
     *
     * Useful when changing airports
     *
     * @for SpawnPatternModel
     * @method reset
     */

  }, {
    key: "reset",
    value: function reset() {
      this.scheduleId = _globalConstants.INVALID_NUMBER;
      this.category = '';
      this.method = '';
      this.origin = '';
      this.destination = '';
      this.routeString = '';
      this._minimumAltitude = _globalConstants.INVALID_NUMBER;
      this._maximumAltitude = _globalConstants.INVALID_NUMBER;
      this.speed = 0;
      this.heading = _globalConstants.INVALID_NUMBER;
      this._positionModel = null;
      this.cycleStartTime = _globalConstants.INVALID_NUMBER;
      this.rate = _globalConstants.INVALID_NUMBER;
      this.offset = _globalConstants.INVALID_NUMBER;
      this.period = _globalConstants.INVALID_NUMBER;
      this.variation = _globalConstants.INVALID_NUMBER;
      this.airlines = [];
      this._weightedAirlineList = [];
      this.preSpawnAircraftList = [];
    }
    /**
     * Sets the `cycleStart` property with the value of the gameClock when the first
     * timer for this pattern is run by the `SpawnScheduler`
     *
     * Used to calculate cycle, wave and surge spawn patterns
     *
     * @for SpawnPatternModel
     * @method cycleStart
     * @param startTime {number}
     */

  }, {
    key: "cycleStart",
    value: function cycleStart(startTime) {
      if (this.cycleStartTime !== _globalConstants.INVALID_NUMBER) {
        return;
      }

      this.cycleStartTime = startTime - this.offset;
    }
    /**
     * Return a random value from `_weightedAirlineList`
     *
     * Used for spawning arrival aircraft that do not yet have an assigned airline
     *
     * @for SpawnPatternModel
     * @method getRandomAirlineForSpawn
     * @return {string}
     */

  }, {
    key: "getRandomAirlineForSpawn",
    value: function getRandomAirlineForSpawn() {
      var index = this._findRandomIndexForList(this._weightedAirlineList);

      var airlineId = this._weightedAirlineList[index];
      return airlineId;
    }
    /**
     * Return a number to use for the next delay period calculated based
     * on spawning method.
     *
     * This is the value that will be used by the `SpawnScheduler` when
     * when creating a new spawn interval.
     *
     * @for SpawnPatternModel
     * @method getNextDelayValue
     * @param gameTime {number}
     * @return {number}  Next delay period based on spawn method in seconds
     */

  }, {
    key: "getNextDelayValue",
    value: function getNextDelayValue() {
      var gameTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      switch (this.method) {
        case SPAWN_METHOD.RANDOM:
          return this._calculateRandomDelayPeriod();

        case SPAWN_METHOD.CYCLIC:
          return this._calculateNextCyclicDelayPeriod(gameTime);

        case SPAWN_METHOD.SURGE:
          return this._calculateNextSurgeDelayPeriod(gameTime);

        case SPAWN_METHOD.WAVE:
          return this._calculateNextWaveDelayPeriod(gameTime);

        default:
          break;
      }
    }
    /**
     * Used to determine if this spawn pattern will spawn aircraft in the air instead of on the ground
     *
     * @for SpawnPatternModel
     * @method isAirborneAtSpawn
     * @return {boolean}
     */

  }, {
    key: "isAirborneAtSpawn",
    value: function isAirborneAtSpawn() {
      return this.isArrival() || this.isOverflight();
    }
    /**
     * Used to determine if this spawn pattern is for an arrival
     *
     * @for SpawnPatternModel
     * @method isArrival
     * @return {boolean}
     */

  }, {
    key: "isArrival",
    value: function isArrival() {
      return this.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL;
    }
    /**
     * Used to determine if this spawn pattern is for an departing aircraft
     *
     * @for SpawnPatternModel
     * @method isDeparture
     * @return {boolean}
     */

  }, {
    key: "isDeparture",
    value: function isDeparture() {
      return this.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE;
    }
    /**
     * Used to determine if this spawn pattern is for an overflight
     *
     * @for SpawnPatternModel
     * @method isOverflight
     * @return {boolean}
     */

  }, {
    key: "isOverflight",
    value: function isOverflight() {
      return this.category === _aircraftConstants.FLIGHT_CATEGORY.OVERFLIGHT;
    }
    /**
     *
     *
     * @for SpawnPatternModel
     * @method _calculateSurgePatternInitialDelayValues
     * @param spawnPatternJson {object}
     * @private
     */

  }, {
    key: "_calculateSurgePatternInitialDelayValues",
    value: function _calculateSurgePatternInitialDelayValues(spawnPatternJson) {
      if (spawnPatternJson.method !== SPAWN_METHOD.SURGE) {
        return;
      }

      this._aircraftPerHourUp = this.speed / this.entrail[0];
      this._aircraftPerHourDown = this.speed / this.entrail[1]; // to help the uptime calculation
      // TODO: move this calculation out to a helper function or class method

      this.uptime = (this.period * this.rate - this.period * this._aircraftPerHourDown) / (this._aircraftPerHourUp - this._aircraftPerHourDown);
      this.uptime -= this.uptime % (_globalConstants.TIME.ONE_HOUR_IN_SECONDS / this._aircraftPerHourUp); // TODO: abstract to helper
      // adjust to maintain correct acph rate

      var averageSpawnRate = this.rate * this.period * _globalConstants.TIME.ONE_SECOND_IN_HOURS;
      var elevatedSpawnRate = this._aircraftPerHourUp * this.uptime * _globalConstants.TIME.ONE_SECOND_IN_HOURS;
      var downTime = this.period - this.uptime;
      var hoursSpentAtReducedSpawnRate = downTime * _globalConstants.TIME.ONE_SECOND_IN_HOURS;
      var reducedSpawnRate = (averageSpawnRate - elevatedSpawnRate) * hoursSpentAtReducedSpawnRate;
      this._aircraftPerHourDown = reducedSpawnRate; // TODO: abstract this if/else block to helper method
      // Verify we can comply with the requested arrival rate based on entrail spacing

      if (this.rate > this._aircraftPerHourUp) {
        console.warn('TOO MANY ARRIVALS IN SURGE! Requested: ' + "".concat(this.rate, " acph | Acceptable Range for requested entrail distance: ") + "".concat(Math.ceil(this._aircraftPerHourDown), " acph - ").concat(Math.floor(this._aircraftPerHourUp), " acph"));
        this.rate = this._aircraftPerHourUp;
        this._aircraftPerHourDown = this._aircraftPerHourUp;
      } else if (this.rate < this._aircraftPerHourDown) {
        console.warn('TOO FEW ARRIVALS IN SURGE! Requested: ' + "".concat(this.rate, " acph | Acceptable Range for requested entrail distance: ") + "".concat(Math.ceil(this._aircraftPerHourDown), " acph - ").concat(Math.floor(this._aircraftPerHourUp), " acph"));
        this.rate = this._aircraftPerHourDown;
        this._aircraftPerHourUp = this._aircraftPerHourDown;
      }
    }
    /**
     *
     *
     * @for SpawnPatternModel
     * @method _setCyclePeriodAndOffset
     * @param spawnPatternJson {object}
     * @private
     */

  }, {
    key: "_setCyclePeriodAndOffset",
    value: function _setCyclePeriodAndOffset(spawnPatternJson) {
      var offset = (0, _get2["default"])(spawnPatternJson, 'offset', 0);
      var period = (0, _get2["default"])(spawnPatternJson, 'period', null);
      this.offset = (0, _unitConverters.convertMinutesToSeconds)(offset);
      this.period = period ? (0, _unitConverters.convertMinutesToSeconds)(period) : this.period;
      this.variation = (0, _get2["default"])(spawnPatternJson, 'variation', 0);
    }
    /**
     * Sets `_minimumAltitude` and `_maximumAltitude` from a provided altitude.
     *
     * Altitude may be a single number or a range, expressed as: `[min, max]`.
     * This method handles that variation and sets the instance properties with
     * the correct values.
     *
     * @for SpawnPatternModel
     * @method _setMinMaxAltitude
     * @param altitude {array|number}
     * @private
     */

  }, {
    key: "_setMinMaxAltitude",
    value: function _setMinMaxAltitude(altitude) {
      if ((0, _isArray2["default"])(altitude)) {
        var _altitude = _slicedToArray(altitude, 2),
            min = _altitude[0],
            max = _altitude[1];

        this._minimumAltitude = parseInt(min, _unitConverters.DECIMAL_RADIX);
        this._maximumAltitude = parseInt(max, _unitConverters.DECIMAL_RADIX);
        return;
      }

      this._minimumAltitude = parseInt(altitude, _unitConverters.DECIMAL_RADIX);
      this._maximumAltitude = parseInt(altitude, _unitConverters.DECIMAL_RADIX);
    }
    /**
     *
     *
     * @for SpawnPatternModel
     * @method _calculateRandomDelayPeriod
     * @return {number}
     * @private
     */

  }, {
    key: "_calculateRandomDelayPeriod",
    value: function _calculateRandomDelayPeriod() {
      var minimumDelay = this._calculateMinimumDelayFromSpeed();

      var averageDelay = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.rate;

      if (averageDelay < minimumDelay) {
        console.error("Too many aircraft requested on spawn pattern \"".concat(this.routeString, "\""));
        return minimumDelay;
      }

      var delayVariation = averageDelay - minimumDelay;
      var maximumDelay = averageDelay + delayVariation;
      return (0, _random2["default"])(minimumDelay, maximumDelay);
    }
    /**
     * @for SpawnPatternModel
     * @method _calculateMinimumDelayFromSpeed
     * @return {number}  number to use as a delay period for the next delay
     * @private
     */

  }, {
    key: "_calculateMinimumDelayFromSpeed",
    value: function _calculateMinimumDelayFromSpeed() {
      if (this.speed === 0) {
        return 0;
      }

      return Math.floor(_airportConstants.AIRPORT_CONSTANTS.MIN_ENTRAIL_DISTANCE_NM * (_globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.speed));
    }
    /**
     * Calculates the correct delay period to create arrivals in a cyclic pattern.
     *
     * Rate at which the arrival rate increases or decreases remains constant throughout the cycle.
     *
     * |---o---------------o---------------o---------------o-----------| < - - - - - - max arrival rate
     * | o   o           o   o           o   o           o   o         |   +variation
     * o-------o-------o-------o-------o-------o-------o-------o-------o < - - - - - - avg arrival rate
     * |         o   o |         o   o           o   o           o   o |   -variation
     * |-----------o---|-----------o---------------o---------------o---| < - - - - - - min arrival rate
     * |<---period---->|           |<---period---->|
     *
     *
     * @for SpawnPatternModel
     * @method _calculateNextCyclicDelayPeriod
     * @param gameTime {number} current gameTime
     * @return {number}         number to use as a delay period for the next delay
     * @private
     */

  }, {
    key: "_calculateNextCyclicDelayPeriod",
    value: function _calculateNextCyclicDelayPeriod(gameTime) {
      var totalTime = gameTime - this.cycleStartTime;
      var progressInPeriod = totalTime / (this.period / 4);

      if (progressInPeriod >= 4) {
        this.cycleStartTime += this.period;
        return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.rate + (progressInPeriod - 4) * this.variation);
      }

      if (progressInPeriod <= 1) {
        return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.rate + progressInPeriod * this.variation);
      }

      if (progressInPeriod <= 2) {
        return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.rate + 2 * (this.period - 2 * totalTime) / this.period * this.variation);
      }

      if (progressInPeriod <= 3) {
        return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.rate - (progressInPeriod - 2) * this.variation);
      }

      if (progressInPeriod < 4) {
        return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.rate - 4 * (this.period - totalTime) / this.period * this.variation);
      }
    }
    /**
     * Calculate a delay period that goes from very low and steeply increases to a
     * sustained arrival surge of densely packed aircraft.
     *
     * Example airport: `EDDT - Berlin Tegel Airport`
     *
     * o o o o o o o o o o - - - - - - - - - - - o o o o o o o o o o-----+ < - - - max arrival rate ( *this.factor)
     * o                 o                       o                 o     |
     * o                 o                       o                 o     |   x(this.factor)
     * o                 o                       o                 o     |
     * o - - - - - - - - o o o o o o o o o o o o o - - - - - - - - o o o-+ < - - - min arrival rate (n)
     * |<--- up time --->|<----- down time ----->|<--- up time --->|
     *
     * @for SpawnPatternModel
     * @method _calculateNextSurgeDelayPeriod
     * @param gameTime {number} current gameTime
     * @return {number}         number to use as a delay period for the next delay
     * @private
     */

  }, {
    key: "_calculateNextSurgeDelayPeriod",
    value: function _calculateNextSurgeDelayPeriod(gameTime) {
      var totalTime = gameTime - this.cycleStartTime;
      var progressInPeriod = totalTime / this.period; // progress in period

      var intervalUp = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / this._aircraftPerHourUp;
      var intervalDown = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / this._aircraftPerHourDown; // reduced spawn rate

      var timeRemaining = this.period - totalTime;

      if (progressInPeriod >= 1) {
        this.cycleStartTime += this.period;
        return intervalUp;
      } // elevated spawn rate


      if (totalTime <= this.uptime) {
        return intervalUp;
      }

      if (timeRemaining > intervalDown + intervalUp) {
        // plenty of time until new period
        return intervalDown;
      }

      if (timeRemaining > intervalDown) {
        // next plane will delay the first arrival of the next period
        return intervalDown - (totalTime + intervalDown + intervalUp - this.period);
      } // next plane is first of elevated spawn rate


      this.cycleStartTime += this.period;
      return intervalUp;
    }
    /**
     * Calculate a delay period that will increase and decrease faster when changing between the lower/higher rates.
     *
     * ------------o-o-o---------------------------------------+-----------o-o < - - - - - max arrival rate
     *        o             o                                  |      o      |       ^
     *    o                     o                              |  o          |  +variation
     *  o                         o                            |o            |       v
     * o-------------------------- o---------------------------o-------------+ < - - - - - avg arrival rate
     * |                            o                         o|             |       ^
     * |                              o                     o  |             |  -variation
     * |                                  o             o      |             |       v
     * +---------------------------------------o-o-o-----------+-------------+ < - - - - - min arrival rate
     * |                                                       |
     * |<  -  -  -  -  -  -  -  - period -  -  -  -  -  -  -  >|
     *
     *
     * @for SpawnPatternModel
     * @method _calculateNextWaveDelayPeriod
     * @param gameTime {number} current gameTime
     * @return {number}         number to use as a delay period for the next delay
     * @private
     */

  }, {
    key: "_calculateNextWaveDelayPeriod",
    value: function _calculateNextWaveDelayPeriod(gameTime) {
      var t = gameTime - this.cycleStartTime;
      var progressInPeriod = t / this.period;

      if (progressInPeriod >= 1) {
        this.cycleStartTime += this.period;
      }

      var rate = this.rate + this.variation * Math.sin(progressInPeriod * (0, _circle.tau)());
      return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / rate;
    }
    /**
     * Abstracted boolean logic used to determine if a category is valid.
     *
     * @for SpawnPatternModel
     * @method _isValidCategory
     * @param _isValidCategory {string}
     * @return {boolean}
     * @private
     */

  }, {
    key: "_isValidCategory",
    value: function _isValidCategory(category) {
      return category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL || category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE || category === _aircraftConstants.FLIGHT_CATEGORY.OVERFLIGHT;
    }
    /**
     * Returns a random index number for an array
     *
     * @for SpawnPatternModel
     * @method _findRandomIndexForList
     * @param list {array}
     * @return {number}
     * @private
     */

  }, {
    key: "_findRandomIndexForList",
    value: function _findRandomIndexForList(list) {
      return (0, _random2["default"])(0, list.length - 1);
    }
    /**
     * When `speed` is null, return 0 otherwise the specified speed value
     *
     * @for SpawnPatternModel
     * @method _extractSpeedFromJson
     * @param spawnPatternJson {object}
     * @return {number}
     */

  }, {
    key: "_extractSpeedFromJson",
    value: function _extractSpeedFromJson(spawnPatternJson) {
      if (!spawnPatternJson.speed) {
        return 0;
      }

      return parseInt(spawnPatternJson.speed, _unitConverters.DECIMAL_RADIX);
    }
    /**
     * Loops through defined airlines for the spawn pattern and transforms them from array values
     * to an object with meaningful keys.
     *
     * The result is used internally to build the `weightedAirlineList`.
     *
     * In the future the assembled object could, itself, be a defined model object
     *
     * @for SpawnPatternModel
     * @method _assembleAirlineNamesAndFrequencyForSpawn
     * @param spawnPatternAirlines {array<array>}
     * @return {array<object>}
     * @private
     */

  }, {
    key: "_assembleAirlineNamesAndFrequencyForSpawn",
    value: function _assembleAirlineNamesAndFrequencyForSpawn(spawnPatternAirlines) {
      var spawnPatternAirlineModels = (0, _map2["default"])(spawnPatternAirlines, function (spawnPatternAirline) {
        return {
          name: spawnPatternAirline[0],
          rate: spawnPatternAirline[1]
        };
      });
      return spawnPatternAirlineModels;
    }
    /**
     * Build the values for `_weightedAirlineList`
     *
     * see doc block for `_weightedAirlineList` property for more information
     * about what this method produces and why
     *
     * @for SpawnPatternModel
     * @method _buildWeightedAirlineList
     * @return {array<string>}
     * @private
     */

  }, {
    key: "_buildWeightedAirlineList",
    value: function _buildWeightedAirlineList() {
      var weightedAirlineList = [];
      (0, _forEach2["default"])(this.airlines, function (airline) {
        for (var i = 0; i < airline.rate; i++) {
          weightedAirlineList.push(airline.name);
        }
      });
      return weightedAirlineList;
    }
    /**
     * Builds a list of objects used to create the initial aircraft
     * that exist within the app onLoad or onAirportChange.
     *
     * @for SpawnPatternModel
     * @method _buildPreSpawnAircraft
     * @param spawnPatternJson {object}
     */

  }, {
    key: "_buildPreSpawnAircraft",
    value: function _buildPreSpawnAircraft(spawnPatternJson) {
      if (this.isDeparture()) {
        // TODO: this may be dead, please remove if it is
        var preSpawnDepartureAircraft = [{
          type: 'departure'
        }];
        return preSpawnDepartureAircraft;
      }

      var preSpawnArrivalAircraftList = (0, _buildPreSpawnAircraft2.buildPreSpawnAircraft)(spawnPatternJson, _AirportController["default"].current);
      return preSpawnArrivalAircraftList;
    }
    /**
     * Calculate the initial heading and position for a spawning arrival.
     *
     * Sets `position` and `heading` properties.
     *
     * @for SpawnPatternModel
     * @method _initializePositionAndHeadingForAirborneAircraft
     * @param spawnPatternJson {object}
     * @private
     */

  }, {
    key: "_initializePositionAndHeadingForAirborneAircraft",
    value: function _initializePositionAndHeadingForAirborneAircraft(spawnPatternJson) {
      if (spawnPatternJson.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
        return;
      }

      this._positionModel = this._routeModel.waypoints[0].positionModel;
      this.heading = this._calculateSpawnHeading();
    }
    /**
     * Calculate the heading from the first waypoint to the second waypoint
     *
     * This is used to determine the heading of newly spawned aircraft
     *
     * @for SpawnPatternModel
     * @method calculateSpawnHeading
     * @return {number} heading, in radians
     */

  }, {
    key: "_calculateSpawnHeading",
    value: function _calculateSpawnHeading() {
      var firstWaypointPositionModel = this._routeModel.waypoints[0].positionModel;
      var secondWaypointPositionModel = this._routeModel.waypoints[1].positionModel;
      var heading = firstWaypointPositionModel.bearingToPosition(secondWaypointPositionModel);
      return heading;
    }
    /**
     *
     * @for SpawnPatternModel
     * @method _generateSelfReferencedAirportPositionModel
     * @return {StaticPositionModel}
     */

  }, {
    key: "_generateSelfReferencedAirportPositionModel",
    value: function _generateSelfReferencedAirportPositionModel() {
      var airportPosition = _AirportController["default"].airport_get().positionModel;

      var selfReferencingPosition = new _StaticPositionModel["default"](airportPosition.gps, airportPosition, airportPosition.magneticNorth);
      return selfReferencingPosition;
    }
  }, {
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * List of airline icaos for this spawnPattern
     *
     * @property airlineList
     * @return {array<string>}
     */

  }, {
    key: "airlineList",
    get: function get() {
      return (0, _map2["default"])(this.airlines, function (airline) {
        return airline.name;
      });
    }
    /**
     * Convenience getter used for `EventTracker`
     *
     * This getter *should not* be used in code for
     * anything other than event tracking
     *
     * @property airportIcao
     * @return string
     */

  }, {
    key: "airportIcao",
    get: function get() {
      if (this.isOverflight()) {
        return 'overflight';
      }

      return this.isArrival() ? this.destination : this.origin;
    }
    /**
     * Initial altitude of a spawning aircraft
     *
     * value rounded to the nearest thousandth foot
     *
     * @property altitude
     * @return {number}
     */

  }, {
    key: "altitude",
    get: function get() {
      var altitude = (0, _random2["default"])(this._minimumAltitude, this._maximumAltitude);
      return (0, _round2["default"])(altitude, -3);
    }
    /**
     * Provide read-only public access to this._positionModel
     *
     * @for SpawnPatternModel
     * @property positionModel
     * @type {StaticPositionModel}
     */

  }, {
    key: "positionModel",
    get: function get() {
      return this._positionModel;
    }
    /**
     * Facade to access relative position
     *
     * @for SpawnPatternModel
     * @property relativePosition
     * @type {array<number>} [kilometersNorth, kilometersEast]
     */

  }, {
    key: "relativePosition",
    get: function get() {
      return this._positionModel.relativePosition;
    }
  }]);

  return SpawnPatternModel;
}(_BaseModel2["default"]);

exports["default"] = SpawnPatternModel;

},{"../aircraft/FlightManagementSystem/RouteModel":270,"../airport/AirportController":284,"../base/BaseModel":295,"../base/StaticPositionModel":297,"../constants/aircraftConstants":303,"../constants/airportConstants":305,"../constants/globalConstants":310,"../math/circle":348,"../utilities/unitConverters":391,"./buildPreSpawnAircraft":379,"./spawnPatternModelJsonValidator":380,"lodash/forEach":199,"lodash/get":200,"lodash/isArray":209,"lodash/isEmpty":213,"lodash/map":231,"lodash/random":237,"lodash/round":239}],378:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _SpawnPatternCollection = _interopRequireDefault(require("./SpawnPatternCollection"));

var _TimeKeeper = _interopRequireDefault(require("../engine/TimeKeeper"));

var _GameController = _interopRequireDefault(require("../game/GameController"));

var _globalConstants = require("../constants/globalConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Used to create a game_timer for a `SpawnPatternModel` and provide
 * methods for re-creating a new timer on timer expiration.
 *
 * This is designed to be a stateless class.
 *
 * @class SpawnScheduler
 */
var SpawnScheduler =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @for SpawnScheduler
   * @param aircraftController {AircraftController}
   */
  function SpawnScheduler() {
    var _this = this;

    _classCallCheck(this, SpawnScheduler);

    _defineProperty(this, "createAircraftAndRegisterNextTimeout", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var spawnPatternModel = args[0][0];
      var aircraftController = args[0][1];
      aircraftController.createAircraftWithSpawnPatternModel(spawnPatternModel);
      spawnPatternModel.scheduleId = _this.createNextSchedule(spawnPatternModel);
    });

    /**
     * @property _aircraftController
     * @type {AircraftController}
     * @default null
     * @private
     */
    this._aircraftController = null;
  }
  /**
   * @for SpawnScheduler
   * @method init
   * @param aircraftController {AircraftController}
   * @chainable
   */


  _createClass(SpawnScheduler, [{
    key: "init",
    value: function init(aircraftController) {
      if (typeof aircraftController === 'undefined') {
        throw new TypeError('Invalid parameter. SpawnScheduler requires aircraftController to be defined.');
      }

      this.aircraftController = aircraftController;
      this.startScheduler();
      return this;
    }
    /**
     * Starts the scheduler and prespawns departures
     *
     * @for SpawnScheduler
     * @method startScheduler
     */

  }, {
    key: "startScheduler",
    value: function startScheduler() {
      // TODO: rename to createSchedulesWithTimer
      this.createSchedulesFromList(); // TODO: create getter on collection to get all preSpawn including departures
      // TODO: create method `createPreSpawnDeparturesAndArrivals`

      this.createPreSpawnDepartures();
    }
    /**
     * Loop through each `SpawnPatternModel` and create a `game_timeout` for each
     *
     * @for SpawnScheduler
     * @method createSchedulesFromList
     */

  }, {
    key: "createSchedulesFromList",
    value: function createSchedulesFromList() {
      var _this2 = this;

      (0, _forEach2["default"])(_SpawnPatternCollection["default"].spawnPatternModels, function (spawnPatternModel) {
        // set the #cycleStartTime for this `spawnPatternModel` with current game time
        spawnPatternModel.cycleStart(_TimeKeeper["default"].accumulatedDeltaTime);
        spawnPatternModel.scheduleId = _this2.createNextSchedule(spawnPatternModel); // TODO: abstract this to a class method on the `SpawnPatternModel`

        if (spawnPatternModel.isAirborneAtSpawn() && spawnPatternModel.preSpawnAircraftList.length > 0) {
          _this2.aircraftController.createPreSpawnAircraftWithSpawnPatternModel(spawnPatternModel);
        }
      });
    }
    /**
     * Send `SpawnPatternModel` objects off the the `AircraftController` to create
     * new aircraft onLoad or onAirportChange.
     *
     * When starting a session there should always be at least one departure waiting
     * to taxi. The logic for determining _which_ patterns to use, and how many,
     * is handled within the `SpawnPatternCollection`. Here we simply get the
     * result and loop through each `SpawnPatternModel`.
     *
     * @for SpawnScheduler
     * @method createPreSpawnDepartures
     */

  }, {
    key: "createPreSpawnDepartures",
    value: function createPreSpawnDepartures() {
      var departureModelsToPreSpawn = _SpawnPatternCollection["default"].getDepartureModelsForPreSpawn();

      for (var i = 0; i < departureModelsToPreSpawn.length; i++) {
        var spawnPatternModel = departureModelsToPreSpawn[i];
        this.aircraftController.createAircraftWithSpawnPatternModel(spawnPatternModel);
      }
    }
    /**
     * Registers a new timeout, its callback and callback arguments with the `GameController`
     *
     * @for SpawnScheduler
     * @method createNextSchedule
     * @param spawnPatternModel {SpawnPatternModel}
     * @return {array}
     */

  }, {
    key: "createNextSchedule",
    value: function createNextSchedule(spawnPatternModel) {
      var delay = spawnPatternModel.getNextDelayValue(_TimeKeeper["default"].accumulatedDeltaTime);
      return this._createTimeout(spawnPatternModel, delay);
    }
    /**
     * Resets the timer for a specific spawn pattern
     *
     * @for SpawnScheduler
     * @method resetTimer
     * @param spawnPatternModel {SpawnPatternModel}
     */

  }, {
    key: "resetTimer",
    value: function resetTimer(spawnPatternModel) {
      var timePassed = 0;
      var scheduleId = spawnPatternModel.scheduleId;

      if (scheduleId && scheduleId !== _globalConstants.INVALID_NUMBER) {
        _GameController["default"].destroyTimer(spawnPatternModel.scheduleId);

        var timerStart = spawnPatternModel.scheduleId[1] - spawnPatternModel.scheduleId[3];
        timePassed = _TimeKeeper["default"].accumulatedDeltaTime - timerStart;
        spawnPatternModel.scheduleId = null;
      }

      if (spawnPatternModel.rate <= 0) {
        return;
      }

      var nextDelay = spawnPatternModel.getNextDelayValue(_TimeKeeper["default"].accumulatedDeltaTime);

      if (timePassed < nextDelay) {
        nextDelay -= timePassed;
      } else {
        this.aircraftController.createAircraftWithSpawnPatternModel(spawnPatternModel);
      }

      spawnPatternModel.scheduleId = this._createTimeout(spawnPatternModel, nextDelay);
    }
    /**
     * Registers a new timeout, its callback and callback arguments with the `GameController`
     *
     * @for SpawnScheduler
     * @method _createTimeout
     * @param spawnPatternModel {SpawnPatternModel}
     * @param delay {number} time in seconds
     * @return {array}
     */

  }, {
    key: "_createTimeout",
    value: function _createTimeout(spawnPatternModel, delay) {
      return _GameController["default"].game_timeout(this.createAircraftAndRegisterNextTimeout, // lifespan of timeout
      delay, // passing null only to match existing api
      null, // arguments sent to callback as it's first parameter. using array so multiple arg can be sent
      [spawnPatternModel, this.aircraftController]);
    }
    /**
     * Method sent to `game_timeout` as the callback
     *
     * When fired, this method will call `createAircraftWithSpawnPatternModel` and then
     * create a new time by calling `createNextSchedule`. Doing so will also result
     * in calculating a new delay period.
     *
     * Accepts two arguments; `spawnPattern` and `aircraftController`.
     *
     * @for SpawnScheduler
     * @method createAircraftAndRegisterNextTimeout
     * @param args {*[]}
     */

  }]);

  return SpawnScheduler;
}();

var _default = new SpawnScheduler();

exports["default"] = _default;

},{"../constants/globalConstants":310,"../engine/TimeKeeper":338,"../game/GameController":339,"./SpawnPatternCollection":376,"lodash/forEach":199}],379:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._calculateOffsetsToEachWaypointInRoute = _calculateOffsetsToEachWaypointInRoute;
exports._calculateAltitudeOffsets = _calculateAltitudeOffsets;
exports._calculateAltitudeAtOffset = _calculateAltitudeAtOffset;
exports._calculateIdealSpawnAltitudeAtOffset = _calculateIdealSpawnAltitudeAtOffset;
exports.buildPreSpawnAircraft = void 0;

var _findIndex2 = _interopRequireDefault(require("lodash/findIndex"));

var _floor2 = _interopRequireDefault(require("lodash/floor"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _random2 = _interopRequireDefault(require("lodash/random"));

var _without2 = _interopRequireDefault(require("lodash/without"));

var _RouteModel = _interopRequireDefault(require("../aircraft/FlightManagementSystem/RouteModel"));

var _globalConstants = require("../constants/globalConstants");

var _unitConverters = require("../utilities/unitConverters");

var _validatorUtilities = require("../utilities/validatorUtilities");

var _distance = require("../math/distance");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/**
 * Return an array whose indices directly mirror those of `waypointModelList`, except it
 * contains the distances along the route at which each waypoint lies from the spawn point
 *
 * @function _calculateOffsetsToEachWaypointInRoute
 * @param waypointModelList {array<WaypointModel>} array of all waypoints along the route
 * @return {array<number>} offset distance from spawn point to each waypoint
 */
function _calculateOffsetsToEachWaypointInRoute(waypointModelList) {
  // begin by storing the first fix's offset: a distance of 0 from the spawn point
  var waypointOffsetMap = [0];
  var totalDistanceTraveled = 0; // continue with second waypoint, because first is already stored

  for (var i = 1; i < waypointModelList.length; i++) {
    if (waypointModelList[i].isVectorWaypoint || waypointModelList[i - 1].isVectorWaypoint) {
      continue;
    }

    var previousWaypointModel = waypointModelList[i - 1];
    var nextWaypointModel = waypointModelList[i];
    var distanceToNextWaypoint = previousWaypointModel.calculateDistanceToWaypoint(nextWaypointModel);
    totalDistanceTraveled += distanceToNextWaypoint;
    waypointOffsetMap.push(totalDistanceTraveled);
  }

  return waypointOffsetMap;
}
/**
 * Create an array of the various altitude restrictions along the route, and the offset distances at which they exist
 *
 * Note that unlike the `waypointOffsetMap`, the altitude offset array DOES NOT mirror the indices
 * of the `waypointModelList`. Only offsets and altitudes of altitude-restricted waypoints are included.
 *
 * Also note that this is designed to retrieve bottom altitudes used in descent. It could probably
 * be reused for departures, just by doing a Math.max() instead of Math.min() below
 *
 * @function _calculateAltitudeOffsets
 * @param waypointModelList {array<WaypointModel>} array of all waypoints along the route
 * @param waypointOffsetMap {array<number>} offset distance from spawn point to each waypoint
 * @return {array<array<number>>} [[offsetDistance, altitude], [offsetDistance, altitude], ...]
 */


function _calculateAltitudeOffsets(waypointModelList, waypointOffsetMap) {
  var altitudeOffsets = [];

  for (var i = 0; i < waypointModelList.length; i++) {
    var waypointModel = waypointModelList[i];

    if (!waypointModel.hasAltitudeRestriction) {
      continue;
    }

    var altitudes = (0, _without2["default"])([waypointModel.altitudeMaximum, waypointModel.altitudeMinimum], -1);
    altitudeOffsets.push([waypointOffsetMap[i], Math.min.apply(Math, _toConsumableArray(altitudes))]);
  }

  return altitudeOffsets;
}
/**
 * Calculate the interpolated altitude along the glidepath at the given distance along the route from the spawn point
 *
 * @function _calculateAltitudeAtOffset
 * @param altitudeOffsets {array<array<number>>} information about location of altitude restrictions
 * @param offsetDistance {number} distance along route at which we want to know the ideal spawn altitude
 * @return {number} ideal spawn altitude, in feet (rounded up to nearest thousand)
 */


function _calculateAltitudeAtOffset(altitudeOffsets, offsetDistance) {
  var indexOfDistance = 0;
  var indexOfAltitude = 1;
  var indexOfNextAltitudeRestriction = (0, _findIndex2["default"])(altitudeOffsets, function (altitudeOffset) {
    return altitudeOffset[indexOfDistance] >= offsetDistance;
  });
  var indexOfPreviousAltitudeRestriction = indexOfNextAltitudeRestriction - 1;

  if (indexOfPreviousAltitudeRestriction < -1) {
    indexOfPreviousAltitudeRestriction = altitudeOffsets.length - 1;
  }

  if (indexOfNextAltitudeRestriction < 0) {
    // no restrictions ahead
    if (indexOfPreviousAltitudeRestriction < 0) {
      // no restrictions ahead or behind
      throw new TypeError('Expected altitude restrictions to calculate appropriate spawn altiude, but none were received.');
    }

    return altitudeOffsets[indexOfPreviousAltitudeRestriction][indexOfAltitude];
  }

  if (indexOfPreviousAltitudeRestriction < 0) {
    // have restrictions ahead, but none behind
    return (0, _floor2["default"])(altitudeOffsets[indexOfNextAltitudeRestriction][indexOfAltitude], -3);
  }

  var previousAltitudeRestriction = altitudeOffsets[indexOfPreviousAltitudeRestriction];
  var nextAltitudeRestriction = altitudeOffsets[indexOfNextAltitudeRestriction];
  var distanceBetweenRestrictions = nextAltitudeRestriction[indexOfDistance] - previousAltitudeRestriction[indexOfDistance];
  var altitudeBetweenRestrictions = nextAltitudeRestriction[indexOfAltitude] - previousAltitudeRestriction[indexOfAltitude];
  var distanceFromPreviousRestrictionToOffsetDistance = offsetDistance - previousAltitudeRestriction[indexOfDistance];
  var progressBetweenRestrictions = distanceFromPreviousRestrictionToOffsetDistance / distanceBetweenRestrictions;
  var altitudeChangeFromPreviousRestriction = altitudeBetweenRestrictions * progressBetweenRestrictions;
  return (0, _floor2["default"])(previousAltitudeRestriction[indexOfAltitude] + altitudeChangeFromPreviousRestriction, -3);
}
/**
 * Calculate the ideal spawn altitude at the given distance along the route from the spawn point
 *
 * @function _calculateIdealSpawnAltitudeAtOffset
 * @param altitudeOffsets {array<array<number>>} information about location of altitude restrictions
 * @param offsetDistance {number} distance along route at which we want to know the ideal spawn altitude
 * @param spawnSpeed {number} airspeed at which to spawn the aircraft
 * @param spawnAltitude {number|array<number>} altitude specified in the spawn pattern json
 * @param totalDistance {number} distance along route from spawn point to airspace boundary
 * @param airspaceCeiling {number} altitude of the top of our airspace
 * @return {number} ideal spawn altitude, in feet (rounded up to nearest thousand)
 */


function _calculateIdealSpawnAltitudeAtOffset(altitudeOffsets, offsetDistance, spawnSpeed, spawnAltitude, totalDistance, airspaceCeiling) {
  var indexOfDistance = 0;
  var indexOfAltitude = 1;
  var firstAltitudeRestriction = altitudeOffsets[0];

  if (!firstAltitudeRestriction) {
    // no altitude restrictions at all
    firstAltitudeRestriction = [totalDistance, airspaceCeiling];
  }

  if (offsetDistance >= firstAltitudeRestriction[indexOfDistance]) {
    return _calculateAltitudeAtOffset(altitudeOffsets, offsetDistance);
  }

  var distanceToFirstAltitudeRestriction = firstAltitudeRestriction[indexOfDistance] - offsetDistance;
  var minutesToFirstAltitudeRestriction = distanceToFirstAltitudeRestriction / spawnSpeed * _globalConstants.TIME.ONE_HOUR_IN_MINUTES;
  var assumedDescentRate = 1000;
  var highestAcceptableAltitude = firstAltitudeRestriction[indexOfAltitude] + assumedDescentRate * minutesToFirstAltitudeRestriction;

  if ((0, _isArray2["default"])(spawnAltitude)) {
    spawnAltitude = (0, _random2["default"])(spawnAltitude[0] / 1000, spawnAltitude[1] / 1000) * 1000;
  }

  return Math.min((0, _floor2["default"])(highestAcceptableAltitude, -3), spawnAltitude);
}
/**
 * Loop through `waypointModelList` and determine where along the route an
 * aircraft should spawn
 *
 * @function _calculateSpawnPositionsAndAltitudes
 * @param waypointModelList {array<WaypointModel>}
 * @param spawnOffsets {array}
 * @param spawnSpeed {number}
 * @param spawnAltitude {number}
 * @param totalDistance {number} distance along route from spawn point to airspace boundary
 * @return spawnPositions {array<number>} distances along route, in nm
 */


function _calculateSpawnPositionsAndAltitudes(waypointModelList, spawnOffsets, spawnSpeed, spawnAltitude, totalDistance, airspaceCeiling) {
  var spawnPositionsAndAltitudes = [];

  var waypointOffsetMap = _calculateOffsetsToEachWaypointInRoute(waypointModelList);

  var altitudeOffsets = _calculateAltitudeOffsets(waypointModelList, waypointOffsetMap); // for each new aircraft


  var _loop = function _loop(i) {
    var spawnOffset = spawnOffsets[i];
    var nextWaypointIndex = (0, _findIndex2["default"])(waypointOffsetMap, function (distanceToWaypoint) {
      // Purposefully using strict comparison:
      // If we return true here when distanceToWaypoint is equal to spawnOffset,
      // the previousWaypointModel and the nextWaypointModel will be the same for
      // the last item (the spawn point) resulting in the incapacity to compute a
      // heading.
      return distanceToWaypoint > spawnOffset;
    });
    var nextWaypointModel = waypointModelList[nextWaypointIndex];
    var previousWaypointIndex = Math.max(0, nextWaypointIndex - 1);
    var previousWaypointModel = waypointModelList[previousWaypointIndex];
    var distanceFromPreviousWaypointToSpawnPoint = spawnOffset - waypointOffsetMap[previousWaypointIndex];
    var heading = previousWaypointModel.calculateBearingToWaypoint(nextWaypointModel);
    var spawnPositionModel = previousWaypointModel.positionModel.generateDynamicPositionFromBearingAndDistance(heading, distanceFromPreviousWaypointToSpawnPoint);

    var altitude = _calculateIdealSpawnAltitudeAtOffset(altitudeOffsets, spawnOffset, spawnSpeed, spawnAltitude, totalDistance, airspaceCeiling);

    spawnPositionsAndAltitudes.push({
      altitude: altitude,
      heading: heading,
      nextFix: nextWaypointModel.name,
      positionModel: spawnPositionModel
    });
  };

  for (var i = 0; i < spawnOffsets.length; i++) {
    _loop(i);
  }

  return spawnPositionsAndAltitudes;
}
/**
 * Calculate distances along spawn pattern route at which to prespawn aircraft
 *
 * To randomize the spawn locations, the interval between aircraft will vary, but should
 * average out to exactly the `entrailDistance`. The exception is if the `entrailDistance`
 * is less than the `smallestIntervalNm` defined below. In that case, aircraft will be
 * spawned at exactly the `entrailDistance` with no variation due to their proximity.
 *
 * NOTE: Provided there is at least `smallestIntervalNm` distance between them, an aircraft
 * will always be spawned right along the airspace boundary, and another at the first fix.
 *
 * For example, with `smallestIntervalNm = 15`:
 *   - If requesting 8MIT, will spawn exactly 8MIT
 *   - If requesting 30MIT, will spawn each a/c 15MIT-45MIT of the previous arrival
 *
 * @function _assembleSpawnOffsets
 * @param entrailDistance {number}
 * @param totalDistance {number}
 * @return spawnOffsets {array<number>} distances along route, in nm
 */


var _assembleSpawnOffsets = function _assembleSpawnOffsets(entrailDistance) {
  var totalDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var offsetClosestToAirspace = totalDistance - 3;
  var smallestIntervalNm = 15;
  var largestIntervalNm = entrailDistance + (entrailDistance - smallestIntervalNm); // if requesting less than `smallestIntervalNm`, spawn all AT `entrailDistance`

  if (smallestIntervalNm > largestIntervalNm) {
    smallestIntervalNm = largestIntervalNm;
  }

  var spawnOffsets = [offsetClosestToAirspace];
  var distanceAlongRoute = offsetClosestToAirspace; // distance between successive arrivals in nm

  while (distanceAlongRoute > smallestIntervalNm) {
    var interval = (0, _random2["default"])(smallestIntervalNm, largestIntervalNm, true);
    distanceAlongRoute -= interval;

    if (distanceAlongRoute < smallestIntervalNm) {
      break;
    }

    spawnOffsets.push(distanceAlongRoute);
  } // spawn an aircraft at the first fix of the route


  spawnOffsets.push(0);
  return spawnOffsets;
};
/**
 * Returns the total distance from beginning to end of the provided route, along the route's course
 *
 * @function _calculateTotalDistanceAlongRoute
 * @param waypointModelList {array<WaypointModel>}
 * @param airport {AirportModel}
 * @return {number}
 */


var _calculateTotalDistanceAlongRoute = function _calculateTotalDistanceAlongRoute(waypointModelList, airport) {
  // find last fix along STAR that is outside of airspace, ie: next fix is within airspace
  // distance between closest fix outside airspace and airspace border in nm
  var totalDistance = 0; // Iteration started at index 1 to ensure two elements are available. It is
  // already an expectation that aircraft must have two waypoints, so this
  // should not be a problem here.

  for (var i = 1; i < waypointModelList.length; i++) {
    var waypointModel = waypointModelList[i];
    var previousWaypoint = waypointModelList[i - 1];

    if (waypointModel.isVectorWaypoint || previousWaypoint.isVectorWaypoint) {
      continue;
    }

    var distanceBetweenWaypoints = (0, _unitConverters.nm)((0, _distance.distance2d)(previousWaypoint.relativePosition, waypointModel.relativePosition));
    var distanceToBoundary = Infinity;

    for (var j = 0; j < airport.airspace.length; j++) {
      var airspace = airport.airspace[j];

      if (airspace.isPointInside2D(waypointModel.relativePosition)) {
        var distanceToAirspace = airspace.distanceToBoundary(previousWaypoint.relativePosition); // find shortest distance, since the waypoint might be inside multiple airspace polygons

        distanceToBoundary = Math.min(distanceToBoundary, distanceToAirspace);
      }
    } // if waypointModel is within any of our airspace


    if (distanceToBoundary !== Infinity) {
      totalDistance += distanceToBoundary;
      break;
    }

    totalDistance += distanceBetweenWaypoints;
  }

  return totalDistance;
};
/**
 * Calculate heading, nextFix and position data to be used when creating an
 * `AircraftModel` along a route.
 *
 * @function _preSpawn
 * @param spawnPatternJson
 * @param airport
 * @return {array<object>}
 */


var _preSpawn = function _preSpawn(spawnPatternJson, airport) {
  // distance between each arriving aircraft, in nm
  var airspaceCeiling = airport.maxAssignableAltitude;
  var spawnSpeed = spawnPatternJson.speed;
  var spawnAltitude = spawnPatternJson.altitude;
  var entrailDistance = spawnSpeed / spawnPatternJson.rate;
  var routeModel = new _RouteModel["default"](spawnPatternJson.route);
  var waypointModelList = routeModel.waypoints;

  var totalDistance = _calculateTotalDistanceAlongRoute(waypointModelList, airport); // calculate number of offsets


  var spawnOffsets = _assembleSpawnOffsets(entrailDistance, totalDistance); // calculate heading, nextFix and position data to be used when creating an `AircraftModel` along a route


  var spawnPositions = _calculateSpawnPositionsAndAltitudes(waypointModelList, spawnOffsets, spawnSpeed, spawnAltitude, totalDistance, airspaceCeiling);

  return spawnPositions;
};
/**
 * Backfill STAR routes with arrivals closer than the spawn point.
 *
 * Should be run only once on airport load.
 *
 * Aircraft spawn at the first point defined in the `arrivals` entry of the airport json file.
 * When that spawn point is very far from the airspace boundary, it obviously takes quite a
 * while for them to reach the airspace. This function spawns arrivals along the route, between
 * the spawn point and the airspace boundary, in order to ensure the player is not kept waiting
 * for their first arrival aircraft.
 *
 * @function buildPreSpawnAircraft
 * @param spawnPatternJson {object}
 * @param currentAirport {AirportModel}
 * @return {array<object>}
 */


var buildPreSpawnAircraft = function buildPreSpawnAircraft(spawnPatternJson, currentAirport) {
  if ((0, _validatorUtilities.isEmptyObject)(spawnPatternJson)) {
    throw new TypeError('Invalid parameter passed to buildPreSpawnAircraft. Expected spawnPatternJson to be an object');
  }

  if ((0, _isNil2["default"])(currentAirport)) {
    throw new TypeError('Invalid parameter passed to buildPreSpawnAircraft. Expected currentAirport to be defined');
  }

  return _preSpawn(spawnPatternJson, currentAirport);
};

exports.buildPreSpawnAircraft = buildPreSpawnAircraft;

},{"../aircraft/FlightManagementSystem/RouteModel":270,"../constants/globalConstants":310,"../math/distance":350,"../utilities/unitConverters":391,"../utilities/validatorUtilities":392,"lodash/findIndex":192,"lodash/floor":198,"lodash/isArray":209,"lodash/isNil":219,"lodash/random":237,"lodash/without":252}],380:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spawnPatternModelJsonValidator = void 0;

var _difference2 = _interopRequireDefault(require("lodash/difference"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _keys2 = _interopRequireDefault(require("lodash/keys"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// istanbul ignore
var ACCEPTED_KEYS = ['destination', 'origin', 'category', 'route', 'altitude', 'method', 'rate', 'speed', 'airlines'];
var ACCEPTED_OPTIONAL_KEYS = ['offset', 'period', 'variation'];
var ALL_KEYS = [].concat(ACCEPTED_KEYS, ACCEPTED_OPTIONAL_KEYS);
/**
 * Validates the presence of correct `SpawnPatternModel` keys.
 *
 * Expects a shape of one the following:
 *
 * ```javascript
 * // Departures
 * {
 *      "origin": "KLAS",
 *      "destination": "",
 *      "category": "departure",
 *      "route": "KLAS.BOACH6.HEC",
 *      "altitude": "",
 *      "speed": ""
 *      "method": "random",
 *      "rate": 5,
 *      "airlines": [
 *          ["aal", 10],
 *          ["ual", 10],
 *          ["ual/long", 3]
 *      ]
 *  }
 *
 *  // Arrivals
 *  {
 *      "origin": "",
 *      "destination": "KLAS",
 *      "category": "arrival",
 *      "route": "BETHL.GRNPA1.KLAS",
 *      "altitude": [30000, 40000],
 *      "speed": 320,
 *      "method": "cyclic",
 *      "rate": 17.5,
 *      "period": 75,
 *      "offset": 25,
 *      "airlines": [
 *          ["aal", 10],
 *          ["ual", 10],
 *          ["ual/long", 3]
 *      ]
 *  }
 *  ```
 *
 * @function spawnPatternModelJsonValidator
 * @param json {object}
 * @return isValid {boolean}
 */
// istanbul ignore next

var spawnPatternModelJsonValidator = function spawnPatternModelJsonValidator(json) {
  var isValid = true;

  for (var i = 0; i < ACCEPTED_KEYS.length; i++) {
    var key = ACCEPTED_KEYS[i];

    if ((key === 'altitude' || key === 'speed') && json.category === 'departure') {
      continue;
    }

    if (key === 'origin' && json.category === 'arrival') {
      continue;
    }

    if (!(0, _has2["default"])(json, key) && !(0, _has2["default"])(ACCEPTED_OPTIONAL_KEYS, key)) {
      console.warn("spawnPattern is missing a required key: ".concat(key));
      isValid = false;
    }
  }

  var jsonKeys = (0, _keys2["default"])(json);
  var unsupportedKeys = (0, _difference2["default"])(jsonKeys, ALL_KEYS);

  if (unsupportedKeys.length > 0) {
    console.warn("Unsupported key(s) found in spawnPattern: ".concat(unsupportedKeys.join(', ')));
  }

  return isValid;
};

exports.spawnPatternModelJsonValidator = spawnPatternModelJsonValidator;

},{"lodash/difference":188,"lodash/has":201,"lodash/keys":227}],381:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _isNaN2 = _interopRequireDefault(require("lodash/isNaN"));

var _GameController = _interopRequireDefault(require("../game/GameController"));

var _selectors = require("../constants/selectors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @property UI_SETTINGS_MODAL_TEMPLATE
 * @type {string}
 * @final
 */
var UI_SETTINGS_MODAL_TEMPLATE = "\n    <div class=\"option-dialog dialog\">\n        <p class=\"dialog-title\">Settings</p>\n        <div class=\"dialog-body nice-scrollbar\"></div>\n    </div>";
/**
 * @property UI_DIALOG_FOOTER_TEMPLATE
 * @type {string}
 * @final
 */

var UI_DIALOG_FOOTER_TEMPLATE = '<div class="dialog-footer"></div>';
/**
 * @property UI_OPTION_CONTAINER_TEMPLATE
 * @type {string}
 * @final
 */

var UI_OPTION_CONTAINER_TEMPLATE = '<div class="form-element"></div>';
/**
 * @property UI_OPTION_LABEL_TEMPLATE
 * @type {string}
 * @final
 */

var UI_OPTION_LABEL_TEMPLATE = '<span class="form-label"></span>';
/**
 * @property UI_OPTION_SELECTOR_TEMPLATE
 * @type {string}
 * @final
 */

var UI_OPTION_SELECTOR_TEMPLATE = '<span class="form-type-select"></span>'; // TODO: This class has no corresponding styles

/**
 * @property UI_STATIC_TEXT_TEMPLATE
 * @type {string}
 * @final
 */

var UI_STATIC_TEXT_TEMPLATE = '<span class="option-static-text"></span>';
/**
 * @class SettingsController
 */

var SettingsController =
/*#__PURE__*/
function () {
  function SettingsController($element) {
    _classCallCheck(this, SettingsController);

    /**
     * Root DOM element
     *
     * @property $element
     * @type {jquery|HTML Element}
     * @default $element
     */
    this.$element = $element;
    /**
     * Dialog DOM element
     *
     * @property $dialog
     * @type {jquery|HTML Element}
     * @default null
     */

    this.$dialog = null;
    /**
     * Dialog's body DOM element
     *
     * @property $dialogBody
     * @type {jquery|HTML Element}
     * @default null
     */

    this.$dialogBody = null;
    this.init();
  }
  /**
   *
   * @for SettingsController
   * @method init
   * @chainable
   */


  _createClass(SettingsController, [{
    key: "init",
    value: function init() {
      var _this = this;

      this.$dialog = (0, _jquery["default"])(UI_SETTINGS_MODAL_TEMPLATE);
      this.$dialogBody = this.$dialog.find(_selectors.SELECTORS.DOM_SELECTORS.DIALOG_BODY);

      var descriptions = _GameController["default"].game.option.getDescriptions();

      (0, _forEach2["default"])(descriptions, function (opt) {
        if (opt.type !== 'select') {
          return;
        }

        var $container = _this._buildOptionTemplate(opt);

        _this.$dialogBody.append($container);
      });

      var $version = this._buildVersionTemplate();

      this.$dialog.append($version);
      this.$element.append(this.$dialog);
      return this;
    }
    /**
     * Returns whether the airport selection dialog is open
     *
     * @for SettingsController
     * @method isDialogOpen
     * @return {boolean}
     */

  }, {
    key: "isDialogOpen",
    value: function isDialogOpen() {
      return this.$dialog.hasClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
    }
    /**
    * @for SettingsController
    * @method toggleDialog
    */

  }, {
    key: "toggleDialog",
    value: function toggleDialog() {
      this.$dialog.toggleClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
    }
    /**
     * Build the html for a game option and its corresponding value elements.
     *
     * @for SettingsController
     * @method _buildOptionTemplate
     * @param option {object}
     * @return $container {jquery Element}
     * @private
     */

  }, {
    key: "_buildOptionTemplate",
    value: function _buildOptionTemplate(option) {
      var $container = (0, _jquery["default"])(UI_OPTION_CONTAINER_TEMPLATE);
      var $label = (0, _jquery["default"])(UI_OPTION_LABEL_TEMPLATE);
      var $optionSelector = (0, _jquery["default"])(UI_OPTION_SELECTOR_TEMPLATE);
      var $selector = (0, _jquery["default"])("<select name=\"".concat(option.name, "\"></select>"));

      var selectedOption = _GameController["default"].game.option.getOptionByName(option.name);

      $container.append($label);
      $label.text(option.description); // this could me done with a _map(), but verbosity here makes the code easier to read

      for (var i = 0; i < option.optionList.length; i++) {
        var $optionSelectTempalate = this._buildOptionSelectTemplate(option.optionList[i], selectedOption);

        $selector.append($optionSelectTempalate);
      } // TODO: this should be moved to proper event handler method and only assigned here.


      $selector.change(function (event) {
        var $currentTarget = (0, _jquery["default"])(event.currentTarget);

        _GameController["default"].game.option.setOptionByName($currentTarget.attr('name'), $currentTarget.val());
      });
      $optionSelector.append($selector);
      $container.append($optionSelector);
      return $container;
    }
    /**
     * Build the html for a select option.
     *
     * @for SettingsController
     * @method _buildOptionTemplate
     * @param optionData {array<string>}
     * @param selectedOption {string}
     * @return optionSelectTempalate {HTML Element}
     * @private
     */

  }, {
    key: "_buildOptionSelectTemplate",
    value: function _buildOptionSelectTemplate(optionData, selectedOption) {
      // the `selectedOption` coming in to this method will always be a string (due to existing api) but
      // could contain valid numbers. here we test for valid number and build `parsedSelectedOption` accordingly.
      var parsedSelectedOption = !(0, _isNaN2["default"])(parseFloat(selectedOption)) ? parseFloat(selectedOption) : selectedOption;

      if (optionData.value === parsedSelectedOption) {
        return "<option value=\"".concat(optionData.value, "\" selected>").concat(optionData.displayLabel, "</option>");
      }

      return "<option value=\"".concat(optionData.value, "\">").concat(optionData.displayLabel, "</option>");
    }
    /**
     * Builds a static text information psuedo-option.
     * Will display as such:
     *
     * `(settings menu)`
     *
     * `Text text text         Value value value`
     *
     * @for SettingsController
     * @method _buildStaticTemplate
     * @param {string} label
     * @param {string} value (optional)
     * @return {JQuery|HTML element}
     */

  }, {
    key: "_buildStaticTemplate",
    value: function _buildStaticTemplate(label) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var $container = (0, _jquery["default"])(UI_OPTION_CONTAINER_TEMPLATE);
      var $label = (0, _jquery["default"])(UI_OPTION_LABEL_TEMPLATE);
      var $value = (0, _jquery["default"])(UI_STATIC_TEXT_TEMPLATE);
      $container.append($label);
      $container.append($value);
      $label.text(label);
      $value.text(value);
      return $container;
    }
    /**
     * Build the html for the simulator version psuedo-option.
     *
     * @for SettingsController
     * @method _buildVersionTemplate
     * @return {JQuery|HTML element}
     */

  }, {
    key: "_buildVersionTemplate",
    value: function _buildVersionTemplate() {
      var simulatorVersion = window.GLOBAL.VERSION;
      var $container = (0, _jquery["default"])(UI_DIALOG_FOOTER_TEMPLATE);
      $container.text("openScope ATC Simulator v".concat(simulatorVersion));
      return $container;
    }
  }]);

  return SettingsController;
}();

exports["default"] = SettingsController;

},{"../constants/selectors":316,"../game/GameController":339,"jquery":1,"lodash/forEach":199,"lodash/isNaN":218}],382:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _EventTracker = _interopRequireDefault(require("../EventTracker"));

var _SpawnPatternCollection = _interopRequireDefault(require("../trafficGenerator/SpawnPatternCollection"));

var _SpawnScheduler = _interopRequireDefault(require("../trafficGenerator/SpawnScheduler"));

var _selectors = require("../constants/selectors");

var _aircraftConstants = require("../constants/aircraftConstants");

var _eventNames = require("../constants/eventNames");

var _globalConstants = require("../constants/globalConstants");

var _trackableEvents = require("../constants/trackableEvents");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @property UI_SETTINGS_MODAL_TEMPLATE
 * @type {string}
 * @final
 */
var UI_TRAFFIC_MODAL_TEMPLATE = "\n    <div class=\"traffic-dialog dialog\">\n        <p class=\"dialog-title\">Traffic rate</p>\n        <div class=\"dialog-body nice-scrollbar\"></div>\n    </div>";
/**
 * @class TrafficRateController
 */

var TrafficRateController =
/*#__PURE__*/
function () {
  function TrafficRateController($element) {
    _classCallCheck(this, TrafficRateController);

    /**
     * @property EventBus
     * @type {EventBus}
     * @default EventBus
     * @private
     */
    this._eventBus = _EventBus["default"];
    /**
     * Root DOM element
     *
     * @property $element
     * @type {jquery|HTML Element}
     * @default $element
     */

    this.$element = $element;
    /**
     * Dialog DOM element
     *
     * @property $dialog
     * @type {jquery|HTML Element}
     * @default null
     */

    this.$dialog = null;
    /**
     * Spawn rates by category or route
     *
     * @property _rates
     * @type {object}
     * @default null
     */

    this._rates = null;
    /**
     * Form elements by category
     *
     * @property _elements
     * @type {array}
     * @default null
     */

    this._elements = null;

    this.init()._setupHandlers().enable();
  }
  /**
   *
   * @for TrafficRateController
   * @method init
   * @chainable
   */


  _createClass(TrafficRateController, [{
    key: "init",
    value: function init() {
      this.$dialog = (0, _jquery["default"])(UI_TRAFFIC_MODAL_TEMPLATE);
      this.$dialogBody = this.$dialog.find(".".concat(_selectors.CLASSNAMES.DIALOG_BODY));

      this._buildDialogBody();

      this.$element.append(this.$dialog);
      return this;
    }
    /**
     * Create event handlers
     *
     * Should be run once only on instantiation
     *
     * @for TrafficRateController
     * @method _setupHandlers
     * @chainable
     */

  }, {
    key: "_setupHandlers",
    value: function _setupHandlers() {
      this._onAirportChangeHandler = this.onAirportChange.bind(this);
      return this;
    }
    /**
     * Enable event handlers
     *
     * should be run only once on instantiation
     *
     * @for TrafficRateController
     * @method enable
     * @chainable
     */

  }, {
    key: "enable",
    value: function enable() {
      this._eventBus.on(_eventNames.EVENT.AIRPORT_CHANGE, this._onAirportChangeHandler);

      return this;
    }
    /**
     * Disable event handlers
     *
     * @for TrafficRateController
     * @method disable
     * @chainable
     */

  }, {
    key: "disable",
    value: function disable() {
      this._eventBus.off(_eventNames.EVENT.AIRPORT_CHANGE, this._onAirportChangeHandler);

      return this;
    }
    /**
     * Returns whether the airport selection dialog is open
     *
     * @for TrafficRateController
     * @method isDialogOpen
     * @return {boolean}
     */

  }, {
    key: "isDialogOpen",
    value: function isDialogOpen() {
      return this.$dialog.hasClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
    }
    /**
    * @for TrafficRateController
    * @method toggleDialog
    */

  }, {
    key: "toggleDialog",
    value: function toggleDialog() {
      this.$dialog.toggleClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
    }
    /**
     * Rebuilds the dialog body when the airport is changed.
     *
     * @for TrafficRateController
     * @method onAirportChange
     */

  }, {
    key: "onAirportChange",
    value: function onAirportChange() {
      this._buildDialogBody();
    }
    /**
     * Builds the dialog body
     *
     * @for TrafficRateController
     * @method _buildDialogBody
     */

  }, {
    key: "_buildDialogBody",
    value: function _buildDialogBody() {
      var _this = this;

      this.$dialogBody.empty();
      this._rates = {};
      this._elements = {};

      for (var _i = 0, _Object$values = Object.values(_aircraftConstants.FLIGHT_CATEGORY); _i < _Object$values.length; _i++) {
        var category = _Object$values[_i];
        this._rates[category] = 1;
        this._elements[category] = [];

        var $formElement = this._buildSlider(category, category, category, this._onChangeFlightCategoryRate);

        this.$dialogBody.append($formElement);
      }

      var _loop = function _loop() {
        var category = _Object$values2[_i2];

        var spawnPatterns = _SpawnPatternCollection["default"].findSpawnPatternsByCategory(category);

        if (spawnPatterns.length > 0) {
          _this.$dialogBody.append('<hr />');
        }

        (0, _forEach2["default"])(spawnPatterns, function (spawnPattern) {
          var label = spawnPattern.routeString.replace(_globalConstants.REGEX.SINGLE_DOT, ' ');
          _this._rates[spawnPattern.id] = spawnPattern.rate;

          var $formElement = _this._buildInputField(spawnPattern.id, label, spawnPattern, _this._onChangeSpawnPatternRate);

          _this.$dialogBody.append($formElement);

          _this._elements[category].push({
            spawnPattern: spawnPattern,
            $formElement: $formElement
          });
        });
      };

      for (var _i2 = 0, _Object$values2 = Object.values(_aircraftConstants.FLIGHT_CATEGORY); _i2 < _Object$values2.length; _i2++) {
        _loop();
      }
    }
    /**
     * Build form element
     *
     * @for TrafficRateController
     * @method _buildFormElement
     * @param key {string}
     * @param data {string|object} passed to the change handler
     * @param onChangeMethod {function}
     * @return {jquery|HTML Element}
     */

  }, {
    key: "_buildSlider",
    value: function _buildSlider(key, label, data, onChangeMethod) {
      var rate = this._rates[key];
      var template = "\n            <div class=\"form-element\">\n                <div class=\"form-label\">".concat(label, "</div>\n                <input class=\"form-slider\" type=\"range\" name=\"").concat(key, "\" value=\"").concat(rate, "\" min=\"0\" max=\"10\" step=\"0.5\" />\n                <span class=\"form-value\">").concat(rate, "</span>\n            </div>");
      var $element = (0, _jquery["default"])(template);
      var onChangeHandler = onChangeMethod.bind(this);
      $element.on('change', {
        rateKey: data
      }, onChangeHandler);
      return $element;
    }
    /**
     * Build form element
     *
     * @for TrafficRateController
     * @method _buildInputField
     * @param key {string}
     * @param data {string|object} passed to the change handler
     * @param onChangeMethod {function}
     * @return {jquery|HTML Element}
     */

  }, {
    key: "_buildInputField",
    value: function _buildInputField(key, label, data, onChangeMethod) {
      var rate = this._rates[key];
      var template = "\n            <div class=\"form-element\">\n                <div class=\"form-label\">".concat(label, "</div>\n                <input class=\"form-input\" type=\"number\" name=\"").concat(key, "\" value=\"").concat(rate, "\" min=\"0\" max=\"60\">\n                <span class=\"form-value\">").concat(rate, "</span>\n            </div>");
      var $element = (0, _jquery["default"])(template);
      var onChangeHandler = onChangeMethod.bind(this);
      $element.on('change', {
        rateKey: data
      }, onChangeHandler);
      return $element;
    }
    /**
     * Called when the rate for a flight category was changed
     *
     * @for TrafficRateController
     * @method _onChangeFlightCategoryRate
     * @param event
     */

  }, {
    key: "_onChangeFlightCategoryRate",
    value: function _onChangeFlightCategoryRate(event) {
      var $target = (0, _jquery["default"])(event.target);
      var $output = $target.next(".".concat(_selectors.CLASSNAMES.FORM_VALUE));
      var value = $target.val();
      var category = event.data.rateKey;
      var elements = this._elements[category];
      var airportIcao = elements[0].spawnPattern.airportIcao;
      this._rates[category] = parseFloat(value);
      $output.text(value);

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.CHANGE_SPAWN_PATTERN, 'flight-category', "".concat(airportIcao, ":").concat(category, ":").concat(value));

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref2 = _step.value;
          var spawnPattern = _ref2.spawnPattern,
              $formElement = _ref2.$formElement;
          var $childOutput = $formElement.children(".".concat(_selectors.CLASSNAMES.FORM_VALUE));

          this._updateRate(spawnPattern, $childOutput);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * Called when the rate for a route was changed
     *
     * @for TrafficRateController
     * @method _onChangeSpawnPatternRate
     * @param event
     */

  }, {
    key: "_onChangeSpawnPatternRate",
    value: function _onChangeSpawnPatternRate(event) {
      var $target = (0, _jquery["default"])(event.target);
      var $output = $target.next(".".concat(_selectors.CLASSNAMES.FORM_VALUE));
      var value = $target.val();
      var spawnPattern = event.data.rateKey;
      var nextRate = parseFloat(value);
      this._rates[spawnPattern.id] = nextRate;

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.CHANGE_SPAWN_PATTERN, 'spawn-pattern', "".concat(spawnPattern.airportIcao, ":").concat(spawnPattern.routeString, ":").concat(spawnPattern.rate, ":").concat(nextRate));

      this._updateRate(spawnPattern, $output);
    }
    /**
     * Recalculate the rate for a spawn pattern
     *
     * @for TrafficRateController
     * @method _updateRate
     * @param spawnPattern {SpawnPatternModel}
     * @param $output {jQuery element} text element to output the actual rate
     */

  }, {
    key: "_updateRate",
    value: function _updateRate(spawnPattern, $output) {
      var category = spawnPattern.category;
      spawnPattern.rate = this._rates[category] * this._rates[spawnPattern.id];
      $output.text(spawnPattern.rate);

      _SpawnScheduler["default"].resetTimer(spawnPattern);
    }
  }]);

  return TrafficRateController;
}();

exports["default"] = TrafficRateController;

},{"../EventTracker":259,"../constants/aircraftConstants":303,"../constants/eventNames":308,"../constants/globalConstants":310,"../constants/selectors":316,"../constants/trackableEvents":334,"../lib/EventBus":346,"../trafficGenerator/SpawnPatternCollection":376,"../trafficGenerator/SpawnScheduler":378,"jquery":1,"lodash/forEach":199}],383:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _get2 = _interopRequireDefault(require("lodash/get"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var INIT_POSITION_PADDING = [0, 0];
/**
 * Model representing a single tutorial step.
 *
 * Consumed by tutorial.js
 *
 * @class TutorialStep
 */

var TutorialStep =
/*#__PURE__*/
function () {
  /**
   * @for TutorialStep
   * @constructor
   */
  function TutorialStep() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TutorialStep);

    this.title = (0, _get2["default"])(options, 'title', '?');
    this.text = (0, _get2["default"])(options, 'text', '?');
    this.parse = (0, _get2["default"])(options, 'parse', null);
    this.side = (0, _get2["default"])(options, 'side', 'none'); // TODO: Is this an actual `relativePosition`, or something else?

    this.position = (0, _get2["default"])(options, 'position', INIT_POSITION_PADDING);
    this.padding = (0, _get2["default"])(options, 'padding', INIT_POSITION_PADDING);
  }
  /**
   * Replace tokens with values from current sim state
   * or return simple text.
   *
   * @for TutorialStep
   * @method getText
   * @return {string}
   */


  _createClass(TutorialStep, [{
    key: "getText",
    value: function getText() {
      if (this.parse) {
        return this.parse(this.text);
      }

      return this.text;
    }
  }]);

  return TutorialStep;
}();

exports["default"] = TutorialStep;

},{"lodash/get":200}],384:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _AirportController = _interopRequireDefault(require("../airport/AirportController"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _EventTracker = _interopRequireDefault(require("../EventTracker"));

var _TimeKeeper = _interopRequireDefault(require("../engine/TimeKeeper"));

var _TutorialStep = _interopRequireDefault(require("./TutorialStep"));

var _core = require("../math/core");

var _eventNames = require("../constants/eventNames");

var _storageKeys = require("../constants/storageKeys");

var _selectors = require("../constants/selectors");

var _trackableEvents = require("../constants/trackableEvents");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var tutorial = {};
var TUTORIAL_TEMPLATE = '' + '<div id="tutorial">' + '   <h1></h1>' + '   <main></main>' + '   <div class="prev"><img src="assets/images/prev.png" title="Previous step" /></div>' + '   <div class="next"><img src="assets/images/next.png" title="Next step" /></div>' + '</div>';
/**
 * @class TutorialView
 */

var TutorialView =
/*#__PURE__*/
function () {
  /**
   * @constructor
   */
  function TutorialView() {
    var $element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, TutorialView);

    /**
     * @property EventBus
     * @type {EventBus}
     * @default EventBus
     * @private
     */
    this._eventBus = _EventBus["default"];
    /**
     * @property tutorial
     * @type {}
     * @private
     */

    this.tutorial = null;
    /**
     * Root DOM element
     *
     * @property $element
     * @type {jquery|HTML Element}
     * @default $element
     */

    this.$element = $element;
    /**
     * Root tutorial DOM element
     *
     * @property $tutorialView
     * @type {jquery|HTML Element}
     * @default `#tutorial`
     */

    this.$tutorialView = null;
    /**
     * Previous tutorial step button
     *
     * @property $tutorialPrevious
     * @type {jquery|HTML Element}
     * @default `.prev`
     */

    this.$tutorialPrevious = null;
    /**
     * Next tutorial step button
     *
     * @property $tutorialNext
     * @type {jquery|HTML Element}
     * @default `.next`
     */

    this.$tutorialNext = null;
    /**
     * Command bar button to toggle the tutorial on/off
     *
     * @for TutorialView
     * @property $toggleTutorial
     * @type {jquery|HTML Element}
     */

    this.$toggleTutorial = null;

    this._init()._setupHandlers().layout().enable();
  }
  /**
   * Lifecycle method should be run once on application init.
   *
   * Caches selectors in variabls so they only need to be looked up one time.
   *
   * @for TutorialView
   * @method _init
   * @chainable
   */


  _createClass(TutorialView, [{
    key: "_init",
    value: function _init() {
      this.$tutorialView = (0, _jquery["default"])(TUTORIAL_TEMPLATE);
      this.$tutorialPrevious = this.$tutorialView.find(_selectors.SELECTORS.DOM_SELECTORS.PREV);
      this.$tutorialNext = this.$tutorialView.find(_selectors.SELECTORS.DOM_SELECTORS.NEXT);
      this.$toggleTutorial = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_TUTORIAL);
      this.tutorial = tutorial;
      this.tutorial.steps = [];
      this.tutorial.step = 0;
      this.tutorial.open = false;
      return this;
    }
    /**
     * Create event handlers
     *
     * Should be run once only on instantiation
     *
     * @for TutorialView
     * @method _setupHandlers
     * @chainable
     */

  }, {
    key: "_setupHandlers",
    value: function _setupHandlers() {
      this._onAirportChangeHandler = this.onAirportChange.bind(this);
      this._onTutorialToggleHandler = this.tutorial_toggle.bind(this);
      return this;
    }
    /**
     * Lifecycle method should be run once on application init.
     *
     * Adds the TUTORIAL_TEMPLATE to the view
     *
     * @for TutorialView
     * @method layout
     * @chainable
     */

  }, {
    key: "layout",
    value: function layout() {
      if (!this.$element) {
        throw new Error('Expected $element to be defined. `body` tag does not exist in the DOM');
      }

      this.tutorial.html = this.$tutorialView;
      this.$element.append(this.$tutorialView);
      return this;
    }
    /**
     * Lifecycle method should be run once on application init.
     *
     * @for TutorialView
     * @method enable
     * @chainable
     */

  }, {
    key: "enable",
    value: function enable() {
      var _this = this;

      this._eventBus.on(_eventNames.EVENT.TOGGLE_TUTORIAL, this._onTutorialToggleHandler);

      this._eventBus.on(_eventNames.EVENT.AIRPORT_CHANGE, this._onAirportChangeHandler);

      this.$tutorialPrevious.on('click', function (event) {
        return _this.tutorial_prev(event);
      });
      this.$tutorialNext.on('click', function (event) {
        return _this.tutorial_next(event);
      });
      return this;
    }
    /**
     * Disable any click handlers.
     *
     * @for TutorialView
     * @method disable
     * @chainable
     */

  }, {
    key: "disable",
    value: function disable() {
      var _this2 = this;

      this._eventBus.off(_eventNames.EVENT.TOGGLE_TUTORIAL, this._onTutorialToggleHandler);

      this._eventBus.off(_eventNames.EVENT.AIRPORT_CHANGE, this._onAirportChangeHandler);

      this.$tutorialPrevious.off('click', function (event) {
        return _this2.tutorial_prev(event);
      });
      this.$tutorialNext.off('click', function (event) {
        return _this2.tutorial_next(event);
      });
      return this.destroy();
    }
    /**
     * Tear down the view and unset any properties.
     *
     * @for TutorialView
     * @method destroy
     * @chainable
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.$tutorialView = null;
      this.$tutorialPrevious = null;
      this.$tutorialNext = null;
      this.tutorial = {};
      this.tutorial.steps = [];
      this.tutorial.step = 0;
      this.tutorial.open = false;
      return this;
    }
    /**
     * Return whether the tutorial dialog is currently open
     *
     * @for TutorialView
     * @method isTutorialDialogOpen
     * @return {boolean}
     */

  }, {
    key: "isTutorialDialogOpen",
    value: function isTutorialDialogOpen() {
      return this.$tutorialView.hasClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
    }
    /**
     * Reloads the tutorial when the airport is changed.
     *
     * @for TutorialView
     * @method onAirportChange
     */

  }, {
    key: "onAirportChange",
    value: function onAirportChange() {
      this.tutorial_init_pre();
      this.tutorial_update_content();
    }
    /**
     * @for TutorialView
     * @method tutorial_init_pre
     */

  }, {
    key: "tutorial_init_pre",
    value: function tutorial_init_pre() {
      this.tutorial = {};
      this.tutorial.steps = [];
      this.tutorial.step = 0;
      var tutorial_position = [0.1, 0.85];
      var departureAircraft = prop.aircraft.list.filter(function (aircraftModel) {
        return aircraftModel.isDeparture();
      })[0];
      this.tutorial_step({
        title: 'Welcome!',
        text: ['Welcome to the tutorial for the openScope Air Traffic Control Simulator. You can show/hide this', 'tutorial at any time by expanding the "?" icon at the bottom right.'].join(' '),
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Moving Around',
        text: ['To move the middle of the radar screen, use the right click button and drag.', 'Zoom in and out by scrolling, and press the middle mouse button or scroll wheel to reset the zoom.', 'To select an aircraft when it is in your airspace, simply left-click.'].join(' '),
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Flight Strip Bay',
        text: ['On the right, there\'s a row of strips, one for each aircraft. You may need to pull it out with the', '\'|<\' tab. Each strip has a bar on its left side, colored blue for departures and red for arrivals.'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Reading Flight Strips',
        text: ['Click the bottom departure strip ({CALLSIGN}).The aircraft\'s callsign will appear in the command', 'entry box, and the strip will be offset (indicating the aircraft is selected).', 'The left column shows the callsign, aircraft type (in this case "{MODEL}", for a "{MODELNAME}"), and the CID.', 'The next column shows the assigned squawk code, assigned altitude, and filed cruise altitude.', 'The last two columns show the arrival/departure airport, and the flight plan route, respectively.'].join(' '),
        parse: function parse(t) {
          if (prop.aircraft.list.length <= 0) {
            return t;
          }

          return t.replace('{CALLSIGN}', departureAircraft.callsign).replace('{MODEL}', departureAircraft.model.icao.toUpperCase()).replace('{MODELNAME}', departureAircraft.model.name);
        },
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Departures: Issuing IFR Clearance',
        text: ['Let\'s work on getting some departures moving. The first step is always to clear the aircraft to its destination.', 'With {CALLSIGN} selected, simply type "caf" (for "cleared as filed") and press enter. As needed, you can also change the aircraft\'s', 'routing, and much more-- refer to the full list of commands <a title="openScope Command Reference" href="https://github.com/openscope/openscope/blob/develop/documentation/commands.md" target="_blank">here</a>.'].join(' '),
        parse: function parse(t) {
          if (prop.aircraft.list.length <= 0) {
            return t;
          }

          return t.replace('{CALLSIGN}', departureAircraft.callsign);
        },
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Taxiing',
        text: ['Now tell them "taxi {RUNWAY}" to have them taxi to the runway.', 'The aircraft should appear on the scope after about 3 seconds.'].join(' '),
        parse: function parse(t) {
          if (prop.aircraft.list.length <= 0) {
            return t;
          }

          return t.replace('{RUNWAY}', departureAircraft.fms.departureRunwayModel.name);
        },
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Takeoff',
        text: ['Now the aircraft is ready for takeoff. Click the aircraft again (or use the PgUp key)', 'and type "takeoff" (or "to") to clear the aircraft for takeoff.', 'Once it\'s going fast enough, it should lift off the ground and you should', 'see its altitude increasing. Meanwhile, read the next step.'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Moving aircraft',
        text: ['Once {CALLSIGN} has taken off, you\'ll notice it will climb to {INIT_ALT} by itself. This is one of the instructions ', 'we gave them when we cleared them "as filed". Aircraft get better fuel efficiency when they are able to climb directly', 'from the ground to their cruise altitude without leveling off, so let\'s keep them climbing! Click it and type "cvs" (for', '"climb via SID"). Then they will follow the altitudes and speeds defined in the {SID_NAME} departure. You can also simply', 'give a direct climb, lifting the restrictions on the SID. Feel free to click the speedup button on the right side of the ', 'input box (it\'s two small arrows) to watch the departure climb along the SID. Then just click it again to return to 1x speed.'].join(' '),
        parse: function parse(t) {
          if (prop.aircraft.list.length <= 0) {
            return t;
          }

          return t.replace('{CALLSIGN}', departureAircraft.callsign).replace('{INIT_ALT}', _AirportController["default"].airport_get().initial_alt).replace('{SID_NAME}', departureAircraft.destination);
        },
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Projection Lines',
        text: ['If you zoom out and click on {CALLSIGN}, you will see a solid blue line that shows their flight plan', 'route. You will see the SID and some initial waypoints and airways represented by the blue line. To keep', 'traffic manageable, it is in your best interest to get them out of your airspace! To do this, you can', 'issue the "pd" command (later on in this tutorial) to give them a shortcut and get them out of your', 'airspace faster!'].join(' '),
        parse: function parse(t) {
          if (prop.aircraft.list.length <= 0) {
            return t;
          }

          return t.replace('{CALLSIGN}', departureAircraft.callsign);
        },
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Basic Control Instructions: Altitude',
        text: ['You can assign altitudes with the "climb" command, or any of its aliases (other words that', 'act identically). Running the command "climb" is the same as the commands "descend", "d",', '"clear", "c", "altitude", or "a". Just use whichever feels correct in your situation.', 'Remember, just as in real ATC, altitudes are ALWAYS written in hundreds of feet, eg. "descend 30" for 3,000ft or "climb', ' 100" for 10,000ft.'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Basic Control Instructions: Radar Vectors',
        text: ['Radar vectors are an air traffic controller\'s way of telling aircraft to fly a specific magnetic heading. We can give aircraft radar', 'vectors in three ways. Usually, you will use "t l ###" or "t r ###". Be careful, as it is both easy', 'and dangerous to give a turn in the wrong direction. If the heading is only slightly left or right, to avoid choosing the wrong direction,', 'you can tell them to "fly heading" by typing "fh ###", and the aircraft will simply turn the shortest direction', 'to face that heading. You can also instruct an aircraft to turn left and right by a given number of degrees if you give only a two-digit number.'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Basic Control Instructions: Speed',
        text: ['Making good use of speed control can also help keep the pace manageable and allow you to carefully', 'squeeze aircraft closer and closer to minimums while still maintaining safety. To enter speed instructions,', 'use the "+" and "-" keys on the numpad or "sp", followed by the speed, in knots. Note that this assigned', 'speed is indicated airspeed, and our radar scope can only display groundspeed; so, the values may be different.'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Proceed Direct',
        text: ['The proceed direct command ("pd") instructs an aircraft to go directly to a waypoint which already', 'exists in their flight plan. For example, if an aircraft is flying to fixes [A, B, C, D, ...], issuing', 'the command "pd B" will cause the aircraft to skip A and go directly to B, then to C, D, and the rest', 'of their route.'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Bon voyage, aircraft!',
        text: ['When the aircraft leaves your airspace, it will switch to center and', 'automatically be removed from your flight strip bay.'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Arrivals',
        text: ['Now, onto arrivals. Click on any arriving aircraft in the radar screen; after you\'ve', 'selected it, use the altitude/heading/speed controls you\'ve learned in order to', 'guide it to the intercept of the ILS for the runway. The aircraft must be at an appropriate', 'altitude and flying an appropriate heading (more on this later) in order for it to catch the ILS and land!'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Approach Clearances',
        text: ['You can clear aircraft for an ILS approach with the "i" command, followed by a runway name.', 'When you do so, the aircraft will attempt to intercept the localiser, represented by the', 'extended centerline. Try giving radar vectors to aim the aircraft across the final approach course, with ', 'an intercept angle of 30 degrees or less, then tell them "i {RUNWAY}" to clear it for the ILS approach.', 'It should then guide itself down to the runway without any further input from us. If you have trouble,', 'get the airplane lower and have them join the approach further out from the airport.'].join(' '),
        parse: function parse(t) {
          // This isn't robust. If there are multiple runways in use, or the arrival a/c has filed to land
          // elsewhere then the tutorial message will not be correct. However, it's not a bad guess, and hopefully
          // the player hasn't dicked with it too much.
          return t.replace('{RUNWAY}', _AirportController["default"].airport_get().arrivalRunwayModel.name);
        },
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Combining Instructions',
        text: ['You can combine as many commands into a single instruction as you\'d like, for example', '"caf cvs taxi 30C" for departures, "fh 250 d 30 i 26 - 180" for arrivals, or any other time you need.'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Projected Track Lines (PTLs)',
        text: ['Called "PTLs" in approach controls, and "vector lines" in centers, a useful tool is a line pointing', 'directly ahead of an aircraft, whose length is determined by the aircraft\'s speed. To increment these', 'PTLs up/down, use the F1/F2 keys, and they will be adjusted based on the increments specified in the', 'settings menu.'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Range/Bearing Measurement Tool',
        text: ['To easily determine the heading/distance between two points/fixes/aircraft, simply hold the "Ctrl"', 'button and left click two points. Pressing Shift+Ctrl will cause the click to snap to the nearest aircraft', 'or fix. If snapped to an aircraft, a time will also be displayed, based on the aircraft\'s current speed.', 'To clear all range/bearing lines, press the ESC key.'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'Airport Guides & Command Reference',
        text: ['For further help on how any particular airport or command works, check out the airport guide', '(through the "?" menu), or see the <a title="openScope Command Reference" href="https://github.com/openscope/openscope/blob/develop/documentation/commands.md" target="_blank">openScope Command Reference</a>', 'for a comprehensive list of the available aircraft and scope commands.'].join(' '),
        side: 'left',
        position: tutorial_position
      });
      this.tutorial_step({
        title: 'That\'s it!',
        text: ['Remember, minimum separation in an approach control is 3 miles laterally or 1000 feet vertically. Keep them separated,', 'keep them moving, and you\'ll be a controller in no time!'].join(' '),
        side: 'left',
        position: tutorial_position
      });
    }
    /**
     * Open/close the tutorial modal
     *
     * This method may be triggered via `EventBus.trigger()`
     *
     * @for TutorialView
     * @method tutorial_toggle
     */

  }, {
    key: "tutorial_toggle",
    value: function tutorial_toggle() {
      if (this.isTutorialDialogOpen()) {
        this.tutorial_close();
        return;
      }

      this.tutorial_open();
    }
    /**
     * @method tutorial_get
     */

  }, {
    key: "tutorial_get",
    value: function tutorial_get() {
      var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (!step) {
        step = this.tutorial.step;
      }

      return this.tutorial.steps[step];
    }
    /**
     * @method tutorial_move
     */

  }, {
    key: "tutorial_move",
    value: function tutorial_move() {
      var step = this.tutorial_get();
      var padding = [30, 10];
      var left = step.position[0] * ((0, _jquery["default"])(window).width() - this.$tutorialView.outerWidth() - padding[0]);
      var top = step.position[1] * (0, _jquery["default"])(window).height();
      top -= this.$tutorialView.outerHeight() - padding[1]; //  left += step.padding[0];
      //  top  += step.padding[1];

      this.$tutorialView.offset({
        top: (0, _core.round)(top),
        left: (0, _core.round)(left)
      });
    }
    /**
     * @method tutorial_step
     */

  }, {
    key: "tutorial_step",
    value: function tutorial_step(options) {
      this.tutorial.steps.push(new _TutorialStep["default"](options));
    }
    /**
     * @method tutorial_update_content
     */

  }, {
    key: "tutorial_update_content",
    value: function tutorial_update_content() {
      var step = this.tutorial_get();
      this.$tutorialView.find('h1').html(step.title);
      this.$tutorialView.find('main').html(step.getText());
      this.$tutorialView.removeClass('left right');

      if (step.side === _selectors.SELECTORS.CLASSNAMES.LEFT) {
        this.$tutorialView.addClass(_selectors.SELECTORS.CLASSNAMES.LEFT);
      } else if (step.side === _selectors.SELECTORS.CLASSNAMES.RIGHT) {
        this.$tutorialView.addClass(_selectors.SELECTORS.CLASSNAMES.RIGHT);
      }

      this.tutorial_move();
    }
    /**
     * @method tutorial_open
     */

  }, {
    key: "tutorial_open",
    value: function tutorial_open() {
      this.$tutorialView.addClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
      this.$toggleTutorial.addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
      this.tutorial_update_content();
    }
    /**
     * @method tutorial_close
     */

  }, {
    key: "tutorial_close",
    value: function tutorial_close() {
      this.$tutorialView.removeClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
      this.$toggleTutorial.removeClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
      this.tutorial_move();
    } // TODO: this method never gets called anywhere else, remove

    /**
     * @method tutorial_complete
     */

  }, {
    key: "tutorial_complete",
    value: function tutorial_complete() {
      if (!(0, _has2["default"])(localStorage, _storageKeys.STORAGE_KEY.FIRST_RUN_TIME)) {
        this.tutorial_open();
      }

      localStorage[_storageKeys.STORAGE_KEY.FIRST_RUN_TIME] = _TimeKeeper["default"].gameTimeInSeconds;
    }
    /**
     * @method tutorial_next
     */

  }, {
    key: "tutorial_next",
    value: function tutorial_next() {
      if (this.tutorial.step === this.tutorial.steps.length - 1) {
        this.tutorial_close();
        return;
      }

      this.tutorial.step = (0, _core.clamp)(0, this.tutorial.step + 1, this.tutorial.steps.length - 1);

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.TUTORIAL, 'next', "".concat(this.tutorial.step));

      this.tutorial_update_content();
    }
    /**
     * @method tutorial_prev
     */

  }, {
    key: "tutorial_prev",
    value: function tutorial_prev() {
      this.tutorial.step = (0, _core.clamp)(0, this.tutorial.step - 1, this.tutorial.steps.length - 1);

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.TUTORIAL, 'prev', "".concat(this.tutorial.step));

      this.tutorial_update_content();
    }
  }]);

  return TutorialView;
}();

exports["default"] = TutorialView;

},{"../EventTracker":259,"../airport/AirportController":284,"../constants/eventNames":308,"../constants/selectors":316,"../constants/storageKeys":318,"../constants/trackableEvents":334,"../engine/TimeKeeper":338,"../lib/EventBus":346,"../math/core":349,"./TutorialStep":383,"jquery":1,"lodash/has":201}],385:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jquery = _interopRequireDefault(require("jquery"));

var _keys2 = _interopRequireDefault(require("lodash/keys"));

var _AirportController = _interopRequireDefault(require("../airport/AirportController"));

var _EventBus = _interopRequireDefault(require("../lib/EventBus"));

var _EventTracker = _interopRequireDefault(require("../EventTracker"));

var _GameController = _interopRequireDefault(require("../game/GameController"));

var _SettingsController = _interopRequireDefault(require("./SettingsController"));

var _TrafficRateController = _interopRequireDefault(require("./TrafficRateController"));

var _TutorialView = _interopRequireDefault(require("./TutorialView"));

var _speech = require("../speech");

var _eventNames = require("../constants/eventNames");

var _selectors = require("../constants/selectors");

var _trackableEvents = require("../constants/trackableEvents");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Listens for events that occur in the UI and delegates work to the correct place
 *
 * @class UiController
 */
var UiController =
/*#__PURE__*/
function () {
  /**
   * @constructor
   */
  function UiController() {
    _classCallCheck(this, UiController);

    /**
     * Local reference to `EventBus` singleton
     *
     * @for UiController
     * @property _eventBus
     * @type {EventBus}
     * @default null
     */
    this._eventBus = null;
    /**
     * @for UiController
     * @property tutorialView
     * @type {TutorialView}
     * @default null
     */

    this.tutorialView = null;
    /**
     * @for UiController
     * @property settingsController
     * @type {SettingsController}
     * @default null
     */

    this.settingsController = null;
    /**
     * Element of the airport selection dialog
     *
     * @for UiController
     * @property $airportDialog
     * @type {Jquery|Element}
     * @default null
     */

    this.$airportDialog = null;
    /**
     * Element of the body of the airport selection dialog
     *
     * @for UiController
     * @property $airportDialogBody
     * @type {Jquery|Element}
     * @default null
     */

    this.$airportDialogBody = null;
    /**
     * Element of the airport guide dialog
     *
     * @for UiController
     * @property $airportGuideDialog
     * @type {Jquery|Element}
     * @default null
     */

    this.$airportGuideDialog = null;
    /**
     * Element of the airport guide dialog
     *
     * @for UiController
     * @property $changelogDialog
     * @type {Jquery|Element}
     * @default null
     */

    this.$changelogDialog = null;
    /**
     * Root element used to find all other DOM elements needed by this class
     *
     * @for UiController
     * @property $element
     * @type {Jquery|Element}
     * @default null
     */

    this.$element = null;
    /**
     * Footer button element used to toggle fast-forward mode on/off
     *
     * @for UiController
     * @property $fastForwards
     * @type {Jquery|Element}
     * @default null
     */

    this.$fastForwards = null;
    /**
     * Footer button element which opens the openScope github page in a new tab
     *
     * @for UiController
     * @property $githubLinkElement
     * @type {Jquery|Element}
     * @default null
     */

    this.$githubLinkElement = null;
    /**
     * Element in center of screen to unpause when paused
     *
     * @for UiController
     * @property $pausedImg
     * @type {Jquery|Element}
     * @default null
     */

    this.$pausedImg = null;
    /**
     * Footer button element used to pause when the sim is running
     *
     * @for UiController
     * @property $togglePause
     * @type {Jquery|Element}
     * @default null
     */

    this.$togglePause = null;
    /**
     * Footer button element used to toggle speech synthesis on/off
     *
     * @for UiController
     * @property $toggleSpeech
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleSpeech = null;
    /**
     * Footer button element used to toggle the airport selection dialog on/off
     *
     * @for UiController
     * @property $switchAirport
     * @type {Jquery|Element}
     * @default null
     */

    this.$switchAirport = null;
    /**
     * Footer button element used to toggle the airport guide on/off
     *
     * @for UiController
     * @property $toggleAirportGuide
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleAirportGuide = null;
    /**
     * Footer button element used to toggle the airport guide on/off
     *
     * @for UiController
     * @property $toggleChangelog
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleChangelog = null;
    /**
     * Footer button element used to toggle fix and runway labels on/off
     *
     * @for UiController
     * @property $toggleLabels
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleLabels = null;
    /**
     * Footer button element used to toggle the options menu on/off
     *
     * @for UiController
     * @property $toggleOptions
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleOptions = null;
    /**
     * Footer button element used to toggle restricted areas on/off
     *
     * @for UiController
     * @property $toggleRestrictedAreas
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleRestrictedAreas = null;
    /**
     * Footer button element used to toggle SIDs on/off
     *
     * @for UiController
     * @property $toggleSids
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleSids = null;
    /**
     * Footer button element used to toggle STARs on/off
     *
     * @for UiController
     * @property $toggleStars
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleStars = null;
    /**
     * Footer button element used to toggle terrain on/off
     *
     * @for UiController
     * @property $toggleTerrain
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleTerrain = null;
    /**
     * Footer button element used to toggle the traffic rate menu on/off
     *
     * @for UiController
     * @property $toggleTraffic
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleTraffic = null;
    /**
     * Footer button element used to toggle the tutoral on/off
     *
     * @for UiController
     * @property $toggleTutorial
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleTutorial = null;
    /**
     * Footer button element used to toggle the video map on/off
     *
     * @for UiController
     * @property $toggleVideoMap
     * @type {Jquery|Element}
     * @default null
     */

    this.$toggleVideoMap = null;
    /**
     * Footer button element used as a hook to
     * activate/show option
     *
     * @property $tutorialDialog
     * @type {Jquery|Element}
     * @default null
     */

    this.$tutorialDialog = null;
  }
  /**
   * Initialization method
   *
   * Called from the `AppController` after instantiation of the `AircraftController`
   *
   * @for UiController
   * @method init
   * @param $element {jQuery Element}
   */


  _createClass(UiController, [{
    key: "init",
    value: function init($element) {
      this._eventBus = _EventBus["default"];
      this.tutorialView = new _TutorialView["default"]($element);
      this.settingsController = new _SettingsController["default"]($element);
      this.trafficRateController = new _TrafficRateController["default"]($element);
      this.$element = $element;
      this.$airportDialog = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.AIRPORT_SWITCH);
      this.$airportDialogBody = this.$airportDialog.find(_selectors.SELECTORS.DOM_SELECTORS.DIALOG_BODY);
      this.$airportGuideDialog = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.AIRPORT_GUIDE_CONTAINER);
      this.$changelogDialog = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.CHANGELOG_CONTAINER);
      this.$tutorialDialog = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TUTORIAL);
      this.$fastForwards = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.FAST_FORWARDS);
      this.$githubLinkElement = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.GITHUB_EXTERNAL_LINK);
      this.$pausedImg = this.$element.find("".concat(_selectors.SELECTORS.DOM_SELECTORS.PAUSED, " img"));
      this.$switchAirport = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.SWITCH_AIRPORT);
      this.$toggleAirportGuide = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_AIRPORT_GUIDE);
      this.$toggleAirspace = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_AIRSPACE);
      this.$toggleChangelog = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_CHANGELOG);
      this.$toggleLabels = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_LABELS);
      this.$toggleOptions = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_OPTIONS);
      this.$togglePause = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_PAUSE);
      this.$toggleRestrictedAreas = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_RESTRICTED_AREAS);
      this.$toggleSids = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_SIDS);
      this.$toggleSpeech = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_SPEECH);
      this.$toggleStars = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_STARS);
      this.$toggleTerrain = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_TERRAIN);
      this.$toggleTutorial = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_TUTORIAL);
      this.$toggleVideoMap = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_VIDEO_MAP);
      this.$toggleTraffic = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_TRAFFIC);
      return this.setupHandlers().enable();
    }
    /**
     * @for UiController
     * @method setupHandlers
     * @chainable
     */

  }, {
    key: "setupHandlers",
    value: function setupHandlers() {
      return this;
    }
    /**
     * Enable event handlers
     *
     * should be run only once on instantiation
     *
     * @for UiController
     * @method enable
     */

  }, {
    key: "enable",
    value: function enable() {
      var _this = this;

      // TODO: move these to properly bound handler methods
      this.$fastForwards.on('click', function (event) {
        return _GameController["default"].game_timewarp_toggle(event);
      });
      this.$githubLinkElement.on('click', function (event) {
        return _this.onClickGithubLink(event);
      });
      this.$pausedImg.on('click', function (event) {
        return _GameController["default"].game_unpause(event);
      });
      this.$switchAirport.on('click', function (event) {
        return _this.onToggleAirportList(event);
      });
      this.$toggleAirportGuide.on('click', function (event) {
        return _this.onToggleAirportGuide(event);
      });
      this.$toggleAirspace.on('click', function (event) {
        return _this.onToggleAirspace(event);
      });
      this.$toggleChangelog.on('click', function (event) {
        return _this.onToggleChangelog(event);
      });
      this.$toggleLabels.on('click', function (event) {
        return _this.onToggleLabels(event);
      });
      this.$togglePause.on('click', function (event) {
        return _GameController["default"].game_pause_toggle(event);
      });
      this.$toggleRestrictedAreas.on('click', function (event) {
        return _this.onToggleRestrictedAreas(event);
      });
      this.$toggleSids.on('click', function (event) {
        return _this.onToggleSids(event);
      });
      this.$toggleSpeech.on('click', function (event) {
        return (0, _speech.speech_toggle)(event);
      });
      this.$toggleStars.on('click', function (event) {
        return _this.onToggleStars(event);
      });
      this.$toggleTerrain.on('click', function (event) {
        return _this.onToggleTerrain(event);
      });
      this.$toggleTutorial.on('click', function (event) {
        return _this.onToggleTutorial(event);
      });
      this.$toggleOptions.on('click', function (event) {
        return _this.onToggleOptions(event);
      });
      this.$toggleVideoMap.on('click', function (event) {
        return _this.onToggleVideoMap(event);
      });
      this.$toggleTraffic.on('click', function (event) {
        return _this.onToggleTraffic(event);
      });
      return this;
    }
    /**
     * Disable event handlers
     *
     * @for UiController
     * @method disable
     */

  }, {
    key: "disable",
    value: function disable() {
      var _this2 = this;

      this.$fastForwards.off('click', function (event) {
        return _GameController["default"].game_timewarp_toggle(event);
      });
      this.$githubLinkElement.off('click', function (event) {
        return _this2.onClickGithubLink(event);
      });
      this.$pausedImg.off('click', function (event) {
        return _GameController["default"].game_unpause(event);
      });
      this.$switchAirport.off('click', function (event) {
        return _this2.onToggleAirportList(event);
      });
      this.$toggleAirportGuide.off('click', function (event) {
        return _this2.onToggleAirportGuide(event);
      });
      this.$toggleAirspace.off('click', function (event) {
        return _this2.onToggleAirspace(event);
      });
      this.$toggleChangelog.off('click', function (event) {
        return _this2.onToggleChangelog(event);
      });
      this.$toggleLabels.off('click', function (event) {
        return _this2.onToggleLabels(event);
      });
      this.$togglePause.off('click', function (event) {
        return _GameController["default"].game_pause_toggle(event);
      });
      this.$toggleRestrictedAreas.off('click', function (event) {
        return _this2.onToggleRestrictedAreas(event);
      });
      this.$toggleSids.off('click', function (event) {
        return _this2.onToggleSids(event);
      });
      this.$toggleSpeech.off('click', function (event) {
        return (0, _speech.speech_toggle)(event);
      });
      this.$toggleStars.off('click', function (event) {
        return _this2.onToggleStars(event);
      });
      this.$toggleTerrain.off('click', function (event) {
        return _this2.onToggleTerrain(event);
      });
      this.$toggleTutorial.off('click', function (event) {
        return _this2.onToggleTutorial(event);
      });
      this.$toggleOptions.off('click', function (event) {
        return _this2.onToggleOptions(event);
      });
      this.$toggleVideoMap.off('click', function (event) {
        return _this2.onToggleVideoMap(event);
      });
      this.$toggleTraffic.off('click', function (event) {
        return _this2.onToggleTraffic(event);
      });
      return this.destroy();
    }
    /**
     * Tear down the instance
     *
     * @for UiController
     * @method destroy
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._eventBus = null;
      this.tutorialView = null;
      this.settingsController = null;
      this.$element = null;
      this.$airportDialog = null;
      this.$airportDialogBody = null;
      this.$airportGuideDialog = null;
      this.$changelogDialog = null;
      this.$tutorialDialog = null;
      this.$fastForwards = null;
      this.$githubLinkElement = null;
      this.$pausedImg = null;
      this.$switchAirport = null;
      this.$toggleAirportGuide = null;
      this.$toggleChangelog = null;
      this.$toggleLabels = null;
      this.$toggleOptions = null;
      this.$togglePause = null;
      this.$toggleRestrictedAreas = null;
      this.$toggleSids = null;
      this.$toggleSpeech = null;
      this.$toggleStars = null;
      this.$toggleTerrain = null;
      this.$toggleTutorial = null;
      this.$toggleVideoMap = null;
      this.$onToggleTraffic = null;
      return this;
    }
    /**
     * @for uiController
     * @method ui_init
     */

  }, {
    key: "ui_init",
    value: function ui_init() {
      this.tutorialView.tutorial_init_pre();
      this.$fastForwards.prop('title', 'Set time warp to 2');
    }
    /**
     * Close all open dialogs and return focus to the command bar
     *
     * @for UiController
     * @method closeAllDialogs
     */

  }, {
    key: "closeAllDialogs",
    value: function closeAllDialogs() {
      if (this.isTutorialDialogOpen()) {
        this.tutorialView.tutorial_close();
      }

      if (this.settingsController.isDialogOpen()) {
        this.onToggleOptions();
      }

      if (this.trafficRateController.isDialogOpen()) {
        this.onToggleTraffic();
      }

      if (this.isAirportSelectionDialogOpen()) {
        this.onToggleAirportList();
      }

      if (this.isAirportGuideDialogOpen()) {
        this.onToggleAirportGuide();
      }

      if (this.isChangelogDialogOpen()) {
        this.onToggleChangelog();
      }
    }
  }, {
    key: "isChangelogDialogOpen",
    value: function isChangelogDialogOpen() {
      return this.$changelogDialog.hasClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
    }
    /**
     * Returns whether the airport selection dialog is open
     *
     * @for UiController
     * @method isAirportSelectionDialogOpen
     * @return {boolean}
     */

  }, {
    key: "isAirportSelectionDialogOpen",
    value: function isAirportSelectionDialogOpen() {
      return this.$airportDialog.hasClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
    }
    /**
     * Returns whether the airport guide dialog is open
     *
     * @for UiController
     * @method isAirportGuideDialogOpen
     * @return {boolean}
     */

  }, {
    key: "isAirportGuideDialogOpen",
    value: function isAirportGuideDialogOpen() {
      return this.$airportGuideDialog.hasClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
    }
    /**
     * Returns whether the tutorial dialog is open
     *
     * @for UiController
     * @method isTutorialDialogOpen
     * @return {boolean}
     */

  }, {
    key: "isTutorialDialogOpen",
    value: function isTutorialDialogOpen() {
      return this.$tutorialDialog.hasClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
    }
    /**
     * @for uiController
     * @method onClickAirportListItemHandler
     * @paam event {jquery event}
     */

  }, {
    key: "onClickAirportListItemHandler",
    value: function onClickAirportListItemHandler(event) {
      if (event.data !== _AirportController["default"].airport_get().icao) {
        _AirportController["default"].airport_set(event.data);

        this._onClickCloseAirportDialog();
      }
    }
    /**
     * @for UiController
     * @method ui_complete
     */

  }, {
    key: "ui_complete",
    value: function ui_complete() {
      this._buildAirportList();
    }
    /**
     * Loop through each airport defined in the `AirportController` and build
     * a list item that can be appended to the #airport-list element.
     *
     * @for UiController
     * @method _buildAirportList
     * @private
     */

  }, {
    key: "_buildAirportList",
    value: function _buildAirportList() {
      var _this3 = this;

      // clear out the contents of this element
      this.$airportDialogBody.empty();
      var airports = (0, _keys2["default"])(_AirportController["default"].airports).sort();
      var difficulty = '';

      for (var i = 0; i < airports.length; i++) {
        var _AirportController$ai = _AirportController["default"].airports[airports[i]],
            name = _AirportController$ai.name,
            icao = _AirportController$ai.icao,
            level = _AirportController$ai.level;
        difficulty = this._buildAirportListIconForDifficultyLevel(level);
        var $airportListItem = (0, _jquery["default"])(this._buildAirportListItemTemplate(icao, difficulty, name)); // TODO: replace with an onClick() handler

        $airportListItem.click(icao.toLowerCase(), function (event) {
          if (event.data !== _AirportController["default"].airport_get().icao) {
            _AirportController["default"].airport_set(event.data);

            _this3._onClickCloseAirportDialog();
          }
        });
        this.$airportDialogBody.append($airportListItem);
      }
    }
    /**
     * Given a `difficultyLevel`, create a string with the correct icon char code
     * that can be used in the airport list
     *
     * @for UiController
     * @method _buildAirportListIconForDifficultyLevel
     * @param difficultyLevel {string}
     * @return difficulty {string}
     * @private
     */

  }, {
    key: "_buildAirportListIconForDifficultyLevel",
    value: function _buildAirportListIconForDifficultyLevel(difficultyLevel) {
      var difficulty;
      var icon = '&#9992;';

      switch (difficultyLevel) {
        case 'beginner':
          difficulty = icon;
          break;

        case 'easy':
          difficulty = icon.repeat(2);
          break;

        case 'medium':
          difficulty = icon.repeat(3);
          break;

        case 'hard':
          difficulty = icon.repeat(4);
          break;

        case 'expert':
          difficulty = icon.repeat(5);
          break;

        default:
          difficulty = '?';
          break;
      }

      return difficulty;
    }
    /**
     * @for uiController
     * @method _buildAirportListItemTemplate
     * @param icao {string}
     * @param difficulty {string}
     * @param name {string}
     * @return {DOM element|string}
     */

  }, {
    key: "_buildAirportListItemTemplate",
    value: function _buildAirportListItemTemplate(icao, difficulty, name) {
      return "\n            <li class=\"airport-list-item icao-".concat(icao.toLowerCase(), "\">\n                <span style=\"font-size: 7pt\" class=\"difficulty\">").concat(difficulty, "</span>\n                <span class=\"icao\">").concat(icao.toUpperCase(), "</span>\n                <span class=\"name\">").concat(name, "</span>\n            </li>\n        ");
    }
    /**
     * @for UiController
     * @method ui_log
     */

  }, {
    key: "ui_log",
    value: function ui_log(message) {
      var warn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var html = (0, _jquery["default"])("<span class=\"item\"><span class=\"message\">".concat(message, "</span></span>"));

      if (warn) {
        html.addClass(_selectors.SELECTORS.CLASSNAMES.WARN);

        _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.UI_LOG, 'error', message);
      }

      var $log = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.LOG);
      $log.append(html);
      $log.scrollTop($log.get(0).scrollHeight);

      _GameController["default"].game_timeout(function (uiLogView) {
        uiLogView.addClass(_selectors.SELECTORS.CLASSNAMES.HIDDEN);
        setTimeout(function () {
          uiLogView.remove();
        }, 10000);
      }, 3, window, html);
    }
    /**
     * @for UiController
     * @method _onClickOpenAirportDialog
     */

  }, {
    key: "_onClickOpenAirportDialog",
    value: function _onClickOpenAirportDialog() {
      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.AIRPORTS, 'airport-switcher', 'open');

      this.$airportDialog.addClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
      var $previousActiveAirport = this.$airportDialogBody.find(_selectors.SELECTORS.DOM_SELECTORS.AIRPORT_LIST_ITEM_IS_ACTIVE); // Remove the active class from a no-longer-selected airport in the list.

      if ($previousActiveAirport.length !== 0) {
        $previousActiveAirport.removeClass(_selectors.SELECTORS.CLASSNAMES.AIRPORT_LIST_ITEM_IS_ACTIVE);
      }

      var icao = _AirportController["default"].airport_get().icao.toLowerCase();

      (0, _jquery["default"])(".icao-".concat(icao)).addClass(_selectors.SELECTORS.CLASSNAMES.AIRPORT_LIST_ITEM_IS_ACTIVE);
      this.$switchAirport.addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
    }
    /**
     * @for UiController
     * @method _onClickCloseAirportDialog
     * @private
     */

  }, {
    key: "_onClickCloseAirportDialog",
    value: function _onClickCloseAirportDialog() {
      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.AIRPORTS, 'airport-switcher', 'close');

      this.$airportDialog.removeClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
      this.$switchAirport.removeClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
    }
    /**
     * @for UiController
     * @method onToggleAirportList
     */

  }, {
    key: "onToggleAirportList",
    value: function onToggleAirportList() {
      if (this.$airportDialog.hasClass(_selectors.SELECTORS.CLASSNAMES.OPEN)) {
        this._onClickCloseAirportDialog();

        return;
      }

      this._onClickOpenAirportDialog();
    }
    /**
     * @for UiController
     * @method onToggleAirportGuide
     */

  }, {
    key: "onToggleAirportGuide",
    value: function onToggleAirportGuide() {
      var labelButtonElement = (0, _jquery["default"])(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_AIRPORT_GUIDE);

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'airport-guide', "airport-guide:".concat(labelButtonElement.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE)));

      labelButtonElement.toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

      this._eventBus.trigger(_eventNames.EVENT.TOGGLE_AIRPORT_GUIDE);
    }
    /**
     * @for UiController
     * @method onToggleAirspace
     * @param event {jquery event}
     */

  }, {
    key: "onToggleAirspace",
    value: function onToggleAirspace(event) {
      var $airspaceButtonElement = (0, _jquery["default"])(event.target).closest(_selectors.SELECTORS.DOM_SELECTORS.CONTROL);
      $airspaceButtonElement.toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'airspace', "".concat($airspaceButtonElement.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE)));

      this._eventBus.trigger(_eventNames.EVENT.TOGGLE_AIRSPACE);
    }
    /**
     * @for UiController
     * @method onToggleChangelog
     */

  }, {
    key: "onToggleChangelog",
    value: function onToggleChangelog() {
      this._eventBus.trigger(_eventNames.EVENT.TOGGLE_CHANGELOG);
    }
    /**
     * @for UiController
     * @method onToggleLabels
     * @param {jquery event}
     */

  }, {
    key: "onToggleLabels",
    value: function onToggleLabels(event) {
      var labelButtonElement = (0, _jquery["default"])(event.target).closest(_selectors.SELECTORS.DOM_SELECTORS.CONTROL);

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'fix-runway-labels', "".concat(labelButtonElement.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE)));

      labelButtonElement.toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

      this._eventBus.trigger(_eventNames.EVENT.TOGGLE_LABELS);
    }
    /**
     * @for UiController
     * @method onToggleRestrictedAreas
     */

  }, {
    key: "onToggleRestrictedAreas",
    value: function onToggleRestrictedAreas(event) {
      var restrictedButtonElement = (0, _jquery["default"])(event.target).closest(_selectors.SELECTORS.DOM_SELECTORS.CONTROL);
      restrictedButtonElement.toggleClass("".concat(_selectors.SELECTORS.DOM_SELECTORS.WARNING_BUTTON, " ").concat(_selectors.SELECTORS.CLASSNAMES.ACTIVE));

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'restricted', "".concat(restrictedButtonElement.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE)));

      this._eventBus.trigger(_eventNames.EVENT.TOGGLE_RESTRICTED_AREAS);
    }
    /**
    * @for UiController
    * @method onToggleOptions
    */

  }, {
    key: "onToggleOptions",
    value: function onToggleOptions() {
      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.SETTINGS, 'toggle-dialog', "".concat(this.$toggleOptions.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE)));

      this.$toggleOptions.toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
      this.settingsController.toggleDialog();
    }
    /**
     * @for UiController
     * @method onToggleSids
     * @param event {jquery event}
     */

  }, {
    key: "onToggleSids",
    value: function onToggleSids(event) {
      var $sisdButtonElement = (0, _jquery["default"])(event.target).closest(_selectors.SELECTORS.DOM_SELECTORS.CONTROL);
      $sisdButtonElement.toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'sids', "".concat($sisdButtonElement.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE)));

      this._eventBus.trigger(_eventNames.EVENT.TOGGLE_SID_MAP);
    }
    /**
     * @for UiController
     * @method onToggleStars
     * @param event {jquery event}
     */

  }, {
    key: "onToggleStars",
    value: function onToggleStars(event) {
      var $starsButtonElement = (0, _jquery["default"])(event.target).closest(_selectors.SELECTORS.DOM_SELECTORS.CONTROL);
      $starsButtonElement.toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'stars', "".concat($starsButtonElement.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE)));

      this._eventBus.trigger(_eventNames.EVENT.TOGGLE_STAR_MAP);
    }
    /**
     * @for UiController
     * @method onToggleTerrain
     * @param event {jquery event}
     */

  }, {
    key: "onToggleTerrain",
    value: function onToggleTerrain(event) {
      var $terrainButtonElement = (0, _jquery["default"])(event.target).closest(_selectors.SELECTORS.DOM_SELECTORS.CONTROL);
      $terrainButtonElement.toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'terrain', "".concat($terrainButtonElement.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE)));

      this._eventBus.trigger(_eventNames.EVENT.TOGGLE_TERRAIN);
    }
    /**
    * @for UiController
    * @method onToggleTutorial
    * @param event {jquery event}
    */

  }, {
    key: "onToggleTutorial",
    value: function onToggleTutorial(event) {
      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'tutorial');

      this._eventBus.trigger(_eventNames.EVENT.TOGGLE_TUTORIAL);
    }
    /**
     * @for UiController
     * @method onToggleVideoMap
     * @param event {jquery event}
     */

  }, {
    key: "onToggleVideoMap",
    value: function onToggleVideoMap(event) {
      var $videoMapButtonElement = (0, _jquery["default"])(event.target).closest(_selectors.SELECTORS.DOM_SELECTORS.CONTROL);
      $videoMapButtonElement.toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'video-map', "".concat($videoMapButtonElement.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE)));

      this._eventBus.trigger(_eventNames.EVENT.TOGGLE_VIDEO_MAP);
    }
    /**
     * Provides a hook to track a click event for ga
     *
     * @for UiController
     * @method onClickGithubLink
     * @param event {jquery event}
     */

  }, {
    key: "onClickGithubLink",
    value: function onClickGithubLink(event) {
      _EventTracker["default"].recordClickOnOutboundLink(event.target.href);
    }
    /**
     * Handler for toggling the traffic volume view
     *
     * @for UiController
     * @method onToggleTraffic
     * @param event {jquery event}
     */

  }, {
    key: "onToggleTraffic",
    value: function onToggleTraffic(event) {
      _EventTracker["default"].recordEvent(_trackableEvents.TRACKABLE_EVENT.OPTIONS, 'traffic', "".concat(!this.$toggleTraffic.hasClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE)));

      this.$toggleTraffic.toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
      this.trafficRateController.toggleDialog();
    }
  }]);

  return UiController;
}();

var _default = new UiController();

exports["default"] = _default;

},{"../EventTracker":259,"../airport/AirportController":284,"../constants/eventNames":308,"../constants/selectors":316,"../constants/trackableEvents":334,"../game/GameController":339,"../lib/EventBus":346,"../speech":375,"./SettingsController":381,"./TrafficRateController":382,"./TutorialView":384,"jquery":1,"lodash/keys":227}],386:[function(require,module,exports){
"use strict";

var _logLevel = require("./constants/logLevel");

/**
 *
 * The functions contained in this file should be migrated over to the `math/`
 * files as soon as possible.
 *
 * These functions are all attached to the `window` and are global to the
 * entire app. This is a problem because it polutes the global namespace,
 * and files that don't need it have access to it. These functions should be imported
 * only as needed.
 *
 * These functions should also have corresponding tests.
 *
 */
window.AudioContext = window.AudioContext || window.webkitAudioContext;
/*eslint-disable*/
// String repetition copied from http://stackoverflow.com/a/5450113

if (!String.prototype.hasOwnProperty('repeat')) {
  String.prototype.repeat = function (count) {
    if (count < 1) {
      return '';
    }

    var result = '';
    var pattern = this.valueOf();

    while (count > 1) {
      if (count & 1) result += pattern;
      count >>= 1, pattern += pattern;
    }

    return result + pattern;
  };
}
/**
 * Necessary for Internet Explorer 11 (IE11) to not die while using String.fromCodePoint()
 * This function is not natively available in IE11, as noted on this MSDN page:
 * https://msdn.microsoft.com/en-us/library/dn890630(v=vs.94).aspx
 *
 * Apparently, it is fine with pre-Win8.1 MS Edge 11, but never okay in IE.
 * Here, the function is added to the String prototype to make later code usable.
 *
 * Solution from: http://xahlee.info/js/js_unicode_code_point.html
*/


if (!String.fromCodePoint) {
  // ES6 Unicode Shims 0.1 , © 2012 Steven Levithan , MIT License
  String.fromCodePoint = function fromCodePoint() {
    var chars = [];
    var point;
    var offset;
    var units;

    for (var i = 0; i < arguments.length; i++) {
      point = arguments[i];
      offset = point - 0x10000;
      units = point > 0xFFFF ? [0xD800 + (offset >> 10), 0xDC00 + (offset & 0x3FF)] : [point];
      chars.push(String.fromCharCode.apply(null, units));
    }

    return chars.join('');
  };
}

var log = function log(message) {
  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _logLevel.LOG.INFO;
  var logStrings = {
    0: 'DEBUG',
    1: 'INFO',
    2: 'WARN',
    3: 'ERROR',
    4: 'FATAL'
  };

  if (prop.log <= level) {
    var text = "[ ".concat(logStrings[level], " ]");

    if (level >= _logLevel.LOG.WARNING) {
      console.warn(text, message);
    } else {
      console.log(text, message);
    }
  }
};

window.log = log;

},{"./constants/logLevel":312}],387:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.leftPad = exports.choose_weight = exports.choose = exports.unicodeToString = void 0;

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Helper method to translate a unicode character into a readable string value
 *
 * @method unicodeToString
 * @param char {characterCode}
 * @return {string}
 */
var unicodeToString = function unicodeToString(_char) {
  return "\\u".concat(_char.charCodeAt(0).toString(16).toUpperCase());
};
/**
 *
 *
 * @function choose
 * @param list
 * @return
 */


exports.unicodeToString = unicodeToString;

var choose = function choose(list) {
  var randomIndexFromLength = Math.floor(Math.random() * list.length);
  return list[randomIndexFromLength];
};
/**
 *
 *
 * @function choose_weight
 */


exports.choose = choose;

var choose_weight = function choose_weight(l) {
  if (l.length === 0) {
    return;
  }

  if (!(0, _isArray2["default"])(l[0])) {
    return choose(l);
  } // l = [[item, weight], [item, weight] ... ];


  var weight = 0;

  for (var i = 0; i < l.length; i++) {
    weight += l[i][1];
  }

  var randomWeight = Math.random() * weight;
  weight = 0;

  for (var _i = 0; _i < l.length; _i++) {
    weight += l[_i][1];

    if (weight > randomWeight) {
      return l[_i][0];
    }
  }

  return null;
};
/**
 * Prepends zeros to front of str/num to make it the desired length
 *
 * @function leftPad
 * @param value {number|string}  original value
 * @param length {number}        total character length of return string
 * @return {string}              a string of the desired length prepended with zeros when `value` is < `length`
 */


exports.choose_weight = choose_weight;

var leftPad = function leftPad(value, length) {
  if (value.toString().length >= length) {
    return value.toString();
  }

  var x = "0000000000000".concat(value);
  return x.substr(x.length - length, length);
};

exports.leftPad = leftPad;

},{"lodash/isArray":209}],388:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assembleProceduralRouteString = assembleProceduralRouteString;
exports.parseSpeedRestriction = exports.parseAltitudeRestriction = void 0;

var _globalConstants = require("../constants/globalConstants");

var _routeConstants = require("../constants/routeConstants");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Combine entry, procedure/airway name, and exit to form a correctly formatted procedural route string
 *
 * @function assembleProceduralRouteString
 * @param entryFix {string} ICAO identifier of fix where we enter the airway/procedure
 * @param procedureOrAirway {string} ICAO identifier of the airway/procedure
 * @param exitFix {string} ICAO identifier of fix where we exit the airway/procedure
 * @return {string} correctly formatted procedural route string
 */
function assembleProceduralRouteString(entryFix, procedureOrAirway, exitFix) {
  return "".concat(entryFix).concat(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER).concat(procedureOrAirway) + "".concat(_routeConstants.PROCEDURE_OR_AIRWAY_SEGMENT_DIVIDER).concat(exitFix);
}
/**
 * Parses the restriction string using the specfied regular expression
 *
 * @param restrictionText {string}
 * @param regex {RegExp}
 * @param multiplier {number}
 * @returns {array}
 */


function _parseRestriction(restrictionText, regex) {
  var multiplier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  if (restrictionText == null) {
    return [];
  }

  var match = restrictionText.match(regex);

  if (match === null) {
    return [];
  }

  var _match = _slicedToArray(match, 3),
      value = _match[1],
      limit = _match[2];

  return [parseInt(value, 10) * multiplier, limit];
}
/**
 * Parses an altitude restriction string in the form A80+ or A140- or A160
 * into a array containing the altitude and the optional limit symbol
 * eg. A80+  => [8000, '+']
 *     A140- => [14000, '-']
 *     A160  => [16000, '']
 *
 * @param restrictionText {string}
 * @returns {array} or an empty array if not valid
 */


var parseAltitudeRestriction = function parseAltitudeRestriction(restrictionText) {
  return _parseRestriction(restrictionText, _globalConstants.REGEX.ALTITUDE_RESTRICTION, 100);
};
/**
 * Parses a speed restriction string in the form S250+ or S220-
 * into a array containing the speed and the optional limit symbol
 * eg. S250+ => [250, '+']
 *     S220- => [220, '-']
 *     S230  => [230, '']
 *
 * @param restrictionText {string}
 * @returns {array} or an empty array if not valid
 */


exports.parseAltitudeRestriction = parseAltitudeRestriction;

var parseSpeedRestriction = function parseSpeedRestriction(restrictionText) {
  return _parseRestriction(restrictionText, _globalConstants.REGEX.SPEED_RESTRICTION);
};

exports.parseSpeedRestriction = parseSpeedRestriction;

},{"../constants/globalConstants":310,"../constants/routeConstants":314}],389:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRadioCardinalDirectionNameForHeading = exports.getCardinalDirection = exports.radio_trend = exports.radio_altitude = exports.radio_spellOut = exports.radio_heading = exports.radio_runway = exports.groupNumbers = exports.getGrouping = exports.digits_decimal = exports.digits_integer = exports.radio_runway_names = exports.radio_cardinalDir_names = exports.radio_names = void 0;

var _clone2 = _interopRequireDefault(require("lodash/clone"));

var _compact2 = _interopRequireDefault(require("lodash/compact"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _core = require("../math/core");

var _circle = require("../math/circle");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @property CARDINAL_DIRECTION
 * @type {Array}
 * @final
 */
var CARDINAL_DIRECTION = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];
/**
 * @property radio_names
 * @type {Object}
 * @final
 */

var radio_names = {
  0: 'zero',
  1: 'one',
  2: 'two',
  3: 'three',
  4: 'four',
  5: 'five',
  6: 'six',
  7: 'seven',
  8: 'eight',
  9: 'niner',
  10: 'ten',
  11: 'eleven',
  12: 'twelve',
  13: 'thirteen',
  14: 'fourteen',
  15: 'fifteen',
  16: 'sixteen',
  17: 'seventeen',
  18: 'eighteen',
  19: 'nineteen',
  20: 'twenty',
  30: 'thirty',
  40: 'fourty',
  50: 'fifty',
  60: 'sixty',
  70: 'seventy',
  80: 'eighty',
  90: 'ninety',
  a: 'alpha',
  b: 'bravo',
  c: 'charlie',
  d: 'delta',
  e: 'echo',
  f: 'foxtrot',
  g: 'golf',
  h: 'hotel',
  i: 'india',
  j: 'juliet',
  k: 'kilo',
  l: 'lima',
  m: 'mike',
  n: 'november',
  o: 'oscar',
  p: 'papa',
  q: 'quebec',
  r: 'romeo',
  s: 'sierra',
  t: 'tango',
  u: 'uniform',
  v: 'victor',
  w: 'whiskey',
  x: 'x-ray',
  y: 'yankee',
  z: 'zulu',
  '-': 'dash',
  '.': 'point'
}; // TODO: this and CARDINAL_DIRECTION seem to be duplicating logic. look into smoothing that out by using
// just this enum and `toUpperCase()` where necessary.

/**
 * @property radio_cardinalDir_names
 * @type {Object}
 * @final
 */

exports.radio_names = radio_names;
var radio_cardinalDir_names = {
  n: 'north',
  nw: 'northwest',
  w: 'west',
  sw: 'southwest',
  s: 'south',
  se: 'southeast',
  e: 'east',
  ne: 'northeast'
}; // TODO: probably do this with Object.assign

exports.radio_cardinalDir_names = radio_cardinalDir_names;
var radio_runway_names = (0, _clone2["default"])(radio_names);
exports.radio_runway_names = radio_runway_names;
radio_runway_names.l = 'left';
radio_runway_names.c = 'center';
radio_runway_names.r = 'right'; // TODO: how is this different from lpad?
// NOT IN USE

/**
 * Force a number to a string with a specific # of digits
 *
 * If the rounded integer has more digits than requested, it will be returned
 * anyway, as chopping them off the end would change the value by orders of
 * magnitude, which is almost definitely going to be undesirable.
 *
 * @param number
 * @param digits
 * @truncate {boolean}
 * @return {string} with leading zeros to reach 'digits' places
 */

var digits_integer = function digits_integer(number, digits) {
  var truncate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (truncate) {
    number = Math.floor(number).toString();
  } else {
    number = Math.round(number).toString();
  }

  if (number.length > digits) {
    return number;
  } // add leading zeros


  while (number.length < digits) {
    number = "0".concat(number);
  }

  return number;
};
/**
 * Round a number to a specific # of digits after the decimal
 *
 * Also supports negative digits. Ex: '-2' would do 541.246 --> 500
 *
 * @param {boolean} force - (optional) Forces presence of trailing zeros.
 *                          Must be set to true if you want '3' to be able to go to '3.0', or
 *                          for '32.168420' to not be squished to '32.16842'. If true, fxn will
 *                          return a string, because otherwise, js removes all trailing zeros.
 * @param {boolean} truncate - (optional) Selects shortening method.
 *                          to truncate: 'true', to round: 'false' (default)
 * @return {number}         if !force
 * @return {string}         if force
 */


exports.digits_integer = digits_integer;

var digits_decimal = function digits_decimal(number, digits, force, truncate) {
  var shorten = truncate ? Math.floor : Math.round;

  if (!force) {
    return shorten(number * Math.pow(10, digits)) / Math.pow(10, digits);
  } // check if needs extra trailing zeros


  if (digits <= 0) {
    return (shorten(number * Math.pow(10, digits)) / Math.pow(10, digits)).toString();
  }

  number = number.toString();

  for (var i = 0; i < number.length; i++) {
    if (number[i] === '.') {
      var trailingDigits = number.length - (i + 1);

      if (trailingDigits === digits) {
        return number.toString();
      } else if (trailingDigits < digits) {
        // add trailing zeros
        return number + Array(digits - trailingDigits + 1).join('0');
      } else if (trailingDigits > digits) {
        if (truncate) {
          return number.substr(0, number.length - (trailingDigits - digits));
        }

        var len = number.length - (trailingDigits - digits + 1);
        var part1 = number.substr(0, len);
        var part2 = digits === 0 ? '' : shorten(parseInt(number.substr(len, 2), 10) / 10).toString();
        return part1 + part2;
      }
    }
  }
};
/**
 *
 * @function getGrouping
 * @param groupable {array}
 * @return {string}
 */


exports.digits_decimal = digits_decimal;

var getGrouping = function getGrouping(groupable) {
  var digit1 = groupable[0];
  var digit2 = groupable[1];

  if (digit1 === '0') {
    if (digit2 === '0') {
      return 'hundred';
    } // just digits (eg 'zero seven')


    return "".concat(radio_names[digit1], " ").concat(radio_names[digit2]);
  } else if (digit1 === '1') {
    // exact number (eg 'seventeen')
    return radio_names[groupable];
  } else if (digit1 >= 2) {
    var firstDigit = "".concat(digit1, "0");

    if (digit2 === '0') {
      // to avoid 'five twenty zero'
      return radio_names[firstDigit];
    } // combo number (eg 'fifty one')


    return "".concat(radio_names[firstDigit], " ").concat(radio_names[digit2]);
  }

  return "".concat(radio_names[digit1], " ").concat(radio_names[digit2]);
}; // TODO: this needs to be simplified

/**
 *
 * @function groupNumbers
 * @param callsign {string}
 * @param airline {string} (optional)
 * @return
 */


exports.getGrouping = getGrouping;

var groupNumbers = function groupNumbers(callsign, airline) {
  if (!/^\d+$/.test(callsign)) {
    // GA, eg '117KS' = 'one-one-seven-kilo-sierra')
    if (airline === 'November') {
      // callsign "November"
      var _s = [];

      for (var k in callsign) {
        // one after another (eg 'one one seven kilo sierra')
        _s.push(radio_names[callsign[k]]);
      }

      return _s.join(' ');
    } // airline grouped, eg '3110A' = 'thirty-one-ten-alpha'
    // divide callsign into alpha/numeric sections


    var sections = [];
    var cs = callsign;
    var thisIsDigit;
    var index = cs.length - 1;
    var lastWasDigit = !isNaN(parseInt(cs[index], 10));
    index--;

    while (index >= 0) {
      thisIsDigit = !isNaN(parseInt(cs[index], 10));

      while (thisIsDigit === lastWasDigit) {
        index--;
        thisIsDigit = !isNaN(parseInt(cs[index], 10));

        if (index < 0) {
          break;
        }
      }

      sections.unshift(cs.substr(index + 1));
      cs = cs.substr(0, index + 1);
      lastWasDigit = thisIsDigit;
    } // build words, section by section


    var s = [];

    for (var i in sections) {
      if (isNaN(parseInt(sections[i], 10))) {
        // alpha section
        s.push(radio_spellOut(sections[i]));
      } else {
        // numeric section
        switch (sections[i].length) {
          case 0:
            s.push(sections[i]);
            break;

          case 1:
            s.push(radio_names[sections[i]]);
            break;

          case 2:
            s.push(getGrouping(sections[i]));
            break;

          case 3:
            s.push("".concat(radio_names[sections[i][0]], " ").concat(getGrouping(sections[i].substr(1))));
            break;

          case 4:
            s.push("".concat(getGrouping(sections[i].substr(0, 2)), " ").concat(getGrouping(sections[i].substr(2))));
            break;

          default:
            s.push(radio_spellOut(sections[i]));
            break;
        }
      }
    }

    return s.join(' ');
  } else {
    // TODO: this block is unreachable
    switch (callsign.length) {
      case 0:
        return callsign;
        break;

      case 1:
        return radio_names[callsign];
        break;

      case 2:
        return getGrouping(callsign);
        break;

      case 3:
        return "".concat(radio_names[callsign[0]], " ").concat(getGrouping(callsign.substr(1)));
        break;

      case 4:
        if (callsign[1] === '0' && callsign[2] === '0' && callsign[3] === '0') {
          return "".concat(radio_names[callsign[0]], " thousand");
        }

        return "".concat(getGrouping(callsign.substr(0, 2)), " ").concat(getGrouping(callsign.substr(2)));
        break;

      default:
        return callsign;
    }
  }
};
/**
 *
 * @funtion radio_runway
 * @param input {string}
 * @return
 */


exports.groupNumbers = groupNumbers;

var radio_runway = function radio_runway(input) {
  input = "".concat(input, " ");
  input = input.toLowerCase();
  return (0, _compact2["default"])((0, _map2["default"])(input, function (letterOrNumber, i) {
    return radio_runway_names[input[i]];
  })).join(' ');
};
/**
 *
 * @function radio_heading
 * @param heading {string}
 * @return {string}
 */


exports.radio_runway = radio_runway;

var radio_heading = function radio_heading(heading) {
  var str = heading.toString();

  switch (str.length) {
    case 1:
      return "zero zero ".concat(radio_names[str]);

    case 2:
      return "zero ".concat(radio_names[str[0]], " ").concat(radio_names[str[1]]);

    default:
      return "".concat(radio_names[str[0]], " ").concat(radio_names[str[1]], " ").concat(radio_names[str[2]]);
  }

  return heading;
};
/**
 *
 * @function radio_spellOut
 * @param alphanumeric
 * @return
 */


exports.radio_heading = radio_heading;

var radio_spellOut = function radio_spellOut(alphanumeric) {
  var str = alphanumeric.toString();
  var arr = [];

  if (!str) {
    return;
  } // TODO: change to _map()


  for (var i = 0; i < str.length; i++) {
    arr.push(radio_names[str[i]]);
  }

  return arr.join(' ');
};
/**
 *
 * @function radio_altitude
 * @param altitude
 * @return
 */


exports.radio_spellOut = radio_spellOut;

var radio_altitude = function radio_altitude(altitude) {
  var alt_s = altitude.toString();
  var s = []; // TODO can this block be simplified?

  if (altitude >= 18000) {
    s.push('flight level', radio_names[alt_s[0]], radio_names[alt_s[1]], radio_names[alt_s[2]]);
  } else if (altitude >= 10000) {
    s.push(radio_names[alt_s[0]], radio_names[alt_s[1]], 'thousand');

    if (!(altitude % (Math.floor(altitude / 1000) * 1000) === 0)) {
      s.push(radio_names[alt_s[2]], 'hundred');
    }
  } else if (altitude >= 1000) {
    s.push(radio_names[alt_s[0]], 'thousand');

    if (!(altitude % (Math.floor(altitude / 1000) * 1000) === 0)) {
      s.push(radio_names[alt_s[1]], 'hundred');
    }
  } else if (altitude >= 100) {
    s.push(radio_names[alt_s[0]], 'hundred');
  } else {
    return altitude;
  }

  return s.join(' ');
};
/**
 * Return a portion of a control instruction (as a string) indicating the correct
 * direction of a change in assigned altitude or speed.
 *
 * @function radio_trend
 * @param category {string} either 'altitude' or 'speed'
 * @param currentValue {number} current altitude/speed of the aircraft
 * @param nextValue {number} the altitude/speed being assigned to the aircraft
 * @return {string}
 */


exports.radio_altitude = radio_altitude;

var radio_trend = function radio_trend(category, currentValue, nextValue) {
  var CATEGORIES = {
    altitude: ['descend and maintain', 'climb and maintain', 'maintain'],
    speed: ['reduce speed to', 'increase speed to', 'maintain present speed of']
  };

  if (currentValue > nextValue) {
    return CATEGORIES[category][0];
  }

  if (currentValue < nextValue) {
    return CATEGORIES[category][1];
  }

  return CATEGORIES[category][2];
};
/**
 *
 * @function getCardinalDirection
 * @param angle
 * @return {string}
 */


exports.radio_trend = radio_trend;

var getCardinalDirection = function getCardinalDirection(angle) {
  return CARDINAL_DIRECTION[(0, _core.round)(angle / (0, _circle.tau)() * 8)];
};
/**
 * Return a cardinalDirection when provided a heading
 *
 * @function getRadioCardinalDirectionNameForHeading
 * @param  heading {number}
 * @return {string}
 */


exports.getCardinalDirection = getCardinalDirection;

var getRadioCardinalDirectionNameForHeading = function getRadioCardinalDirectionNameForHeading(heading) {
  var cardinalDirection = getCardinalDirection((0, _circle.radians_normalize)(heading + Math.PI)).toLowerCase();
  return radio_cardinalDir_names[cardinalDirection];
};

exports.getRadioCardinalDirectionNameForHeading = getRadioCardinalDirectionNameForHeading;

},{"../math/circle":348,"../math/core":349,"lodash/clone":182,"lodash/compact":184,"lodash/map":231}],390:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDiscreteTransponderCode = exports.isValidTransponderCode = exports.generateTransponderCode = void 0;

var _generalUtilities = require("./generalUtilities");

var _core = require("../math/core");

var _globalConstants = require("../constants/globalConstants");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * The highest decimal value allowed for a 4-digit
 * octal transponder code
 *
 * @property MAX_TRANSPONDER_CODE
 * @type {number}
 * @final
 */
var MAX_TRANSPONDER_CODE = 4095;
/**
 * List of transponder codes that are reserved
 *
 * This enum should be used only during the generation of
 * `AircraftModel` objects.
 *
 * The codes listed should still be assignable at the
 * controler's discretion
 *
 * Source: https://en.wikipedia.org/wiki/List_of_transponder_codes
 *
 * @property TRANSPONDER_CODES
 * @type {array<object>}
 * @final
 */

var TRANSPONDER_CODES = [{
  // ICAO
  prefix: null,
  reserved: []
}, {
  // Europe
  prefix: /^([elb])/,
  reserved: []
}, {
  // Canda
  prefix: /^c/,
  reserved: []
}, {
  // Belgium
  prefix: /^eb/,
  reserved: [// Assigned for VFR traffic under Flight Information Services (BXL FIC)
  // 0041–0057
  /^00(4[1-7]|5[0-7])$/, // For testing stations
  '7777']
}, {
  // Germany
  prefix: /^e[dt]/,
  reserved: [// Parachute dropping
  '0025', // For testing stations
  '7777']
}, {
  // Netherlands
  prefix: /^eh/,
  reserved: [// For testing stations
  '7777']
}, {
  // UK
  prefix: /^eg/,
  reserved: [// Parachute drop
  '0033', // Sudden military climb out from low-level operations
  '7001', // Aerobatic & displays
  '7004']
}, {
  // USA
  prefix: /^k/,
  reserved: [// VFR - 12xx
  /^12[0-7][0-7]$/, // Reserved for use by SR-71, YF-12, U-2 and B-57, pressure suit flights,
  // and aircraft operations above FL600. And many others
  // 4400–4477
  /^44[0-7]{2}$/, // Reserved for use by Continental NORAD Region (CONR)
  // 7501–7577
  /^75(0[1-7]|[1-7][0-7])$/, // Reserved for special use by FAA
  // 7601–7607, 7701–7707
  /^7[67]0[1-7]$/, // External ARTCC subsets (Discrete codes of blocks only except for first primary
  // block, which is used as the ARTCC's non-discrete code if all discrete codes are assigned)
  // Not reserved as it implies they are useable
  // 7610–7676, 7710–7776
  // /^7[67]([1-6][0-7]|7[1-6])$/,
  // Military & for testing stations
  '7777']
}, // {
//     // Washington DC
//     prefix: /^k/,
//     reserved: [
//         // Reserved for special use by Potomac TRACON
//         // 5061–5062
//         /^506[12]$/
//     ]
// },
{
  // France
  prefix: /^lf/,
  reserved: [// VFR
  '7001']
}, {
  // Australia
  prefix: /^y/,
  reserved: [// Civil flights engaged in littoral surveillance
  '7615']
}];
/**
 * Gets the array of squawk code objects that match the specifed ICAO airport code
 *
 * @method _getCodes
 * @param icao {string}
 * @returns {array}
 * @private
 */

function _getCodes(icao) {
  return TRANSPONDER_CODES.filter(function (item) {
    return (item.prefix === null || item.prefix.test(icao)) && item.reserved.length !== 0;
  });
}
/**
 * Helper used to test if the `transponderCode` matches the
 * String or RegExp in `against`
 *
 * @param transponderCode {string}
 * @param testAgainst {string|RegExp}
 * @private
 */


function _isMatch(transponderCode, testAgainst) {
  if (testAgainst instanceof RegExp) {
    return testAgainst.test(transponderCode);
  } else if (typeof testAgainst === 'string') {
    return transponderCode === testAgainst;
  }

  throw new TypeError("Invalid parameter for testAgainst, expected string or RegExp, but got ".concat(_typeof(testAgainst)));
}
/**
 * Helper used to determine if a given `transponderCode` is reserved
 * in the country or region of the specified `icao` airport code
 *
 * @method _isReserved
 * @param icao {string}
 * @param transponderCode {string}
 * @returns {boolean}
 * @private
 */


function _isReserved(icao, transponderCode) {
  return _getCodes(icao).some(function (item) {
    return item.reserved.some(function (test) {
      return _isMatch(transponderCode, test);
    });
  });
}
/**
 * Helper used to generate a new 4 digit octal transponder code
 *
 * @returns {string}
 */


var generateTransponderCode = function generateTransponderCode() {
  var code = (0, _core.randint)(0, MAX_TRANSPONDER_CODE).toString(8);
  return (0, _generalUtilities.leftPad)(code, 4);
};
/**
 * Boolean helper used to determine if a given `transponderCode` is both
 * the correct length and an octal number.
 *
 * @method isValidTransponderCode
 * @param transponderCode {string}
 * @return {boolean}
 */


exports.generateTransponderCode = generateTransponderCode;

var isValidTransponderCode = function isValidTransponderCode(transponderCode) {
  return _globalConstants.REGEX.TRANSPONDER_CODE.test(transponderCode);
};
/**
 * Helper used to determine if a given `transponderCode` is both
 * valid and not reserved in the country or region of the
 * specified `icao` airport code
 *
 * @method isDiscreteTransponderCode
 * @param icao {string}
 * @param transponderCode {string}
 * @return {boolean}
 */


exports.isValidTransponderCode = isValidTransponderCode;

var isDiscreteTransponderCode = function isDiscreteTransponderCode(icao, transponderCode) {
  if (!isValidTransponderCode(transponderCode)) {
    return false;
  }

  if (transponderCode.endsWith('00')) {
    return false;
  }

  return !_isReserved(icao, transponderCode);
};

exports.isDiscreteTransponderCode = isDiscreteTransponderCode;

},{"../constants/globalConstants":310,"../math/core":349,"./generalUtilities":387}],391:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseElevation = exports.parseCoordinate = exports.heading_to_string = exports.convertStringToNumber = exports.convertToThousands = exports.convertMinutesToSeconds = exports.degreesToRadians = exports.radiansToDegrees = exports.nm_ft = exports.kn_ms = exports.ft_km = exports.km_ft = exports.m_ft = exports.nm = exports.km = exports.NUMBER_CONSTANTS = exports.UNIT_CONVERSION_CONSTANTS = exports.DECIMAL_RADIX = void 0;

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));

var _startsWith2 = _interopRequireDefault(require("lodash/startsWith"));

var _circle = require("../math/circle");

var _core = require("../math/core");

var _globalConstants = require("../constants/globalConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @property DECIMAL_RADIX
 * @type {number}
 * @final
 */
var DECIMAL_RADIX = 10; // TODO: This should be moved to its own file once it has been filled in a little more

/**
 * @property UNIT_CONVERSION_CONSTANTS
 * @type {Object}
 */

exports.DECIMAL_RADIX = DECIMAL_RADIX;
var UNIT_CONVERSION_CONSTANTS = {
  /**
  * nautical miles to feet
  *
  * @property NM_FT
  * @type {Number}
  * @final
  */
  NM_FT: 6076.115485564,

  /**
   * nautical mile per kilometer ratio
   *
   * @property NM_KM
   * @type {number}
   * @final
   */
  NM_KM: 1.852,

  /**
   * Meters to feet ratio
   *
   * @property M_FT
   * @type {number}
   * @final
   */
  M_FT: 0.3048,

  /**
   * kilometer per foot ratio
   *
   * @property KM_FT
   * @type {number}
   * @final
   */
  KM_FT: 0.0003048,

  /**
   * knots per m/s ratio
   *
   * @property KN_MS
   * @type {number}
   * @final
   */
  KN_MS: 0.51444444,

  /**
   * Number used to obtain altitude in feet from flight level
   *
   * @property FL_FT
   * @type {number}
   * @final
   */
  FL_FT: 100,

  /**
   * Number used to obtain flight level from altitude in feet
   *
   * @property FT_FL
   * @type {number}
   * @final
   */
  FT_FL: 0.01
}; // TODO: This should be moved to its own file once it has been filled in a little more

/**
 * @property NUMBER_CONSTANTS
 * @type {Object}
 * @final
 */

exports.UNIT_CONVERSION_CONSTANTS = UNIT_CONVERSION_CONSTANTS;
var NUMBER_CONSTANTS = {
  /**
   * Degrees in a circle
   *
   * @property FULL_CIRCLE_DEGREES
   * @type {number}
   * @final
   */
  FULL_CIRCLE_DEGREES: 360
};
/**
 * nautical miles --> kilometers
 *
 * @function km
 * @param nm {number}
 * @return {number}
 */

exports.NUMBER_CONSTANTS = NUMBER_CONSTANTS;

var km = function km() {
  var nm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return nm * UNIT_CONVERSION_CONSTANTS.NM_KM;
};
/**
 * kilometers --> nautical miles
 *
 * @function nm
 * @param kilometers {number}
 * @return {number}
 */


exports.km = km;

var nm = function nm() {
  var kilometers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return kilometers / UNIT_CONVERSION_CONSTANTS.NM_KM;
};
/**
 * meters -> feet
 *
 * @function m_ft
 * @param {number} [meters=0]
 * @return {number}
 */


exports.nm = nm;

var m_ft = function m_ft() {
  var meters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return meters / UNIT_CONVERSION_CONSTANTS.M_FT;
};
/**
 * kilometers --> feet
 *
 * @function km_ft
 * @param kilometers {number}
 * @return {number}
 */


exports.m_ft = m_ft;

var km_ft = function km_ft() {
  var kilometers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return kilometers / UNIT_CONVERSION_CONSTANTS.KM_FT;
};
/**
 * feet --> kilometers
 *
 * @function ft_km
 * @param nm {number}
 * @return {number}
 */


exports.km_ft = km_ft;

var ft_km = function ft_km() {
  var ft = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return ft * UNIT_CONVERSION_CONSTANTS.KM_FT;
};
/**
 * knots to m/s
 *
 * @function kn_ms
 * @param kn {number}
 * @return {number}
 */


exports.ft_km = ft_km;

var kn_ms = function kn_ms() {
  var kn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return kn * UNIT_CONVERSION_CONSTANTS.KN_MS;
};
/**
 * nautical miles to feet
 *
 * @function nm_ft
 * @param nm {number}
 * @return {number}
 */


exports.kn_ms = kn_ms;

var nm_ft = function nm_ft(nm) {
  return nm * UNIT_CONVERSION_CONSTANTS.NM_FT;
};
/**
 * convert radians to degrees
 *
 * @function radiansToDegrees
 * @param radians {number}
 * @return {number}
 */


exports.nm_ft = nm_ft;

var radiansToDegrees = function radiansToDegrees(radians) {
  return radians / (0, _circle.tau)() * NUMBER_CONSTANTS.FULL_CIRCLE_DEGREES;
};
/**
 * convert degrees to radians
 *
 * @function degreesToRadians
 * @param degrees {number}
 * @return {number}
 */


exports.radiansToDegrees = radiansToDegrees;

var degreesToRadians = function degreesToRadians(degrees) {
  return degrees / NUMBER_CONSTANTS.FULL_CIRCLE_DEGREES * (0, _circle.tau)();
};
/**
 * @function convertMinutesToSeconds
 * @param minutes {number}
 * @return {number}
 */


exports.degreesToRadians = degreesToRadians;

var convertMinutesToSeconds = function convertMinutesToSeconds(minutes) {
  return minutes * 60;
};
/**
 * Utility function to convert a number to thousands.
 *
 * Given a flightlevel FL180, this function outputs 18,000
 *
 * @function covertToThousands
 * @param  {number} value
 * @return {number}
 */


exports.convertMinutesToSeconds = convertMinutesToSeconds;

var convertToThousands = function convertToThousands(value) {
  return parseInt(value, DECIMAL_RADIX) * UNIT_CONVERSION_CONSTANTS.FL_FT;
};
/**
 * Attempt to convert a string to a number
 *
 * The implementor will have to handle the case where `parseInt` returns `NaN`
 *
 * @function convertStringToNumber
 * @param  value {string|*}
 * @return {number|NaN}
 */


exports.convertToThousands = convertToThousands;

var convertStringToNumber = function convertStringToNumber(value) {
  return parseInt(value, DECIMAL_RADIX);
};
/**
 * Convert a heading in radians to a 360 degree string
 *
 * @function heading_to_string
 * @param heading {string}  heading in radians
 * @return {string}
 */


exports.convertStringToNumber = convertStringToNumber;

var heading_to_string = function heading_to_string(heading) {
  heading = (0, _core.round)((0, _core.mod)(radiansToDegrees(heading), 360)).toString();

  if (heading === '0') {
    heading = '360';
  }

  if (heading.length === 1) {
    heading = "00".concat(heading);
  }

  if (heading.length === 2) {
    heading = "0".concat(heading);
  }

  return heading;
};
/**
 * Accept a lat/long coordinate and return a value in decimal notation
 *
 * Latitude and Longitude numbers may be one of the following forms:
 *   Decimal degrees - 'N47.112388112'
 *   Decimal minutes - 'N38d38.109808'
 *   Decimal seconds - 'N58d27m12.138'
 *
 * @function parseCoordinate
 * @param coordinate {string}
 * @return transformedCoordinate {number}
 */


exports.heading_to_string = heading_to_string;

var parseCoordinate = function parseCoordinate(coordinate) {
  var match = _globalConstants.REGEX.LAT_LONG.exec(coordinate); // If coordinate already in WGS84 ESPG:4326 form ('39.427618, -75.296011'), just return it as-is


  if (match == null) {
    return coordinate;
  }

  var degrees = parseFloat(match[2]);
  var minutes = 0;
  var seconds = 0; // Gather minutes/seconds as decimal of a degree, if available

  if (match[5] != null) {
    minutes = parseFloat(match[5]) * _globalConstants.TIME.ONE_MINUTE_IN_HOURS;

    if (match[8] != null) {
      seconds = parseFloat(match[8]) * _globalConstants.TIME.ONE_SECOND_IN_HOURS;
    }
  }

  var decimalDegrees = degrees + minutes + seconds; // Apply negative to value if coordinate is "South" or "West"

  if (_globalConstants.REGEX.SW.test(match[1])) {
    decimalDegrees *= -1;
  }

  return decimalDegrees;
};
/**
 * Accept a string elevation and return a number representing elevation in ft.
 *
 * @function parseElevation
 * @param elevation {string}    ex: 13.4ft, 3m, 5ft
 * @return {number}             elevation in feet
 */


exports.parseCoordinate = parseCoordinate;

var parseElevation = function parseElevation(elevation) {
  // TODO: move to master REGEX constant
  // this regex will catch the following: `-`, `m`, `ft`, `Infinity`, and is used to extract a number
  // from a string containing these symbols.
  var REGEX = /(-)|(m|ft|Infinity)/gi; // if its a number, we're done here.
  // This will catch whole numbers, floats, Infinity and -Infinity.
  // This checks if strings are given will skip the regex and exit early
  // Also stops the function from returning NaN

  if ((0, _isNumber2["default"])(elevation) || elevation === 'Infinity' || elevation === '-Infinity') {
    return parseFloat(elevation);
  }

  var parsedElevation = elevation.replace(REGEX, '');
  var elevationUnit = elevation.match(REGEX); // if its in meters, convert it to feet

  if ((0, _includes2["default"])(elevationUnit, 'm')) {
    parsedElevation = m_ft(parsedElevation);
  } // if it came in as a negative number,return it as a negative number


  if ((0, _startsWith2["default"])(elevation, '-')) {
    parsedElevation *= -1;
  }

  return parseFloat(parsedElevation);
};

exports.parseElevation = parseElevation;

},{"../constants/globalConstants":310,"../math/circle":348,"../math/core":349,"lodash/includes":206,"lodash/isNumber":220,"lodash/startsWith":240}],392:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEmptyOrNotArray = exports.isEmptyObject = void 0;

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * This will return true if it is not an object or it is empty
 *
 * @funtion isNotObjectOrIsEmpty
 * @param value {*}
 * @return {boolean}
 */
var isEmptyObject = function isEmptyObject(value) {
  return (0, _isObject2["default"])(value) && (0, _isEmpty2["default"])(value);
};
/**
 * This will return true if it is not an array or it is empty
 *
 * @funtion isNotObjectOrIsEmpty
 * @param value {*}
 * @return {boolean}
 */


exports.isEmptyObject = isEmptyObject;

var isEmptyOrNotArray = function isEmptyOrNotArray(value) {
  return !(0, _isArray2["default"])(value) || (0, _isEmpty2["default"])(value);
};

exports.isEmptyOrNotArray = isEmptyOrNotArray;

},{"lodash/isArray":209,"lodash/isEmpty":213,"lodash/isObject":221}]},{},[342])

//# sourceMappingURL=bundle.min.js.map
